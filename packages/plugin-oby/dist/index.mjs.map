{"version":3,"file":"index.mjs","sources":["../../../node_modules/oby/dist/symbols.js","../../../node_modules/oby/dist/utils.js","../../../node_modules/oby/dist/objects/callable.js","../../../node_modules/oby/dist/constants.js","../../../node_modules/oby/dist/lazy.js","../../../node_modules/oby/dist/objects/owner.js","../../../node_modules/oby/dist/objects/superroot.js","../../../node_modules/oby/dist/context.js","../../../node_modules/oby/dist/methods/batch.js","../../../node_modules/oby/dist/methods/is_observable_boolean.js","../../../node_modules/oby/dist/methods/is_observable_frozen.js","../../../node_modules/oby/dist/methods/is_untracked.js","../../../node_modules/oby/dist/objects/scheduler.sync.js","../../../node_modules/oby/dist/objects/observable.js","../../../node_modules/oby/dist/objects/observables.js","../../../node_modules/oby/dist/objects/observer.js","../../../node_modules/oby/dist/objects/memo.js","../../../node_modules/oby/dist/methods/memo.js","../../../node_modules/oby/dist/methods/boolean.js","../../../node_modules/oby/dist/methods/cleanup.js","../../../node_modules/oby/dist/objects/context.js","../../../node_modules/oby/dist/methods/context.js","../../../node_modules/oby/dist/methods/disposed.js","../../../node_modules/oby/dist/objects/scheduler.async.js","../../../node_modules/oby/dist/objects/effect.js","../../../node_modules/oby/dist/methods/effect.js","../../../node_modules/oby/dist/methods/resolve.js","../../../node_modules/oby/dist/objects/root.js","../../../node_modules/oby/dist/methods/for.cache.keyed.js","../../../node_modules/oby/dist/methods/is_observable.js","../../../node_modules/oby/dist/methods/get.js","../../../node_modules/oby/dist/objects/suspense.js","../../../node_modules/oby/dist/methods/suspense.js","../../../node_modules/oby/dist/methods/for.cache.unkeyed.js","../../../node_modules/oby/dist/methods/is_store.js","../../../node_modules/oby/dist/methods/untrack.js","../../../node_modules/oby/dist/methods/for.js","../../../node_modules/oby/dist/methods/warmup.js","../../../node_modules/oby/dist/methods/switch.js","../../../node_modules/oby/dist/methods/ternary.js","../../../node_modules/oby/dist/methods/if.js","../../../node_modules/oby/dist/methods/is_batching.js","../../../node_modules/oby/dist/methods/observable.js","../../../node_modules/oby/dist/methods/owner.js","../../../node_modules/oby/dist/methods/is_observable_writable.js","../../../node_modules/oby/dist/methods/target.js","../../../node_modules/oby/dist/methods/readonly.js","../../../node_modules/oby/dist/methods/root.js","../../../node_modules/oby/dist/methods/selector.js","../../../node_modules/oby/dist/methods/store.js","../../../node_modules/oby/dist/methods/suspended.js","../../../node_modules/oby/dist/methods/tick.js","../../../node_modules/oby/dist/methods/try_catch.js","../../../node_modules/oby/dist/methods/untracked.js","../../../node_modules/oby/dist/methods/with.js","../../../node_modules/oby/dist/methods/$.js","../src/index.ts"],"sourcesContent":["/* MAIN */\nconst SYMBOL_CACHED = Symbol('Cached');\nconst SYMBOL_OBSERVABLE = Symbol('Observable');\nconst SYMBOL_OBSERVABLE_BOOLEAN = Symbol('Observable.Boolean');\nconst SYMBOL_OBSERVABLE_FROZEN = Symbol('Observable.Frozen');\nconst SYMBOL_OBSERVABLE_READABLE = Symbol('Observable.Readable');\nconst SYMBOL_OBSERVABLE_WRITABLE = Symbol('Observable.Writable');\nconst SYMBOL_STORE = Symbol('Store');\nconst SYMBOL_STORE_KEYS = Symbol('Store.Keys');\nconst SYMBOL_STORE_OBSERVABLE = Symbol('Store.Observable');\nconst SYMBOL_STORE_TARGET = Symbol('Store.Target');\nconst SYMBOL_STORE_VALUES = Symbol('Store.Values');\nconst SYMBOL_STORE_UNTRACKED = Symbol('Store.Untracked');\nconst SYMBOL_SUSPENSE = Symbol('Suspense');\nconst SYMBOL_UNCACHED = Symbol('Uncached');\nconst SYMBOL_UNTRACKED = Symbol('Untracked');\nconst SYMBOL_UNTRACKED_UNWRAPPED = Symbol('Untracked.Unwrapped');\n/* EXPORT */\nexport { SYMBOL_CACHED, SYMBOL_OBSERVABLE, SYMBOL_OBSERVABLE_BOOLEAN, SYMBOL_OBSERVABLE_FROZEN, SYMBOL_OBSERVABLE_READABLE, SYMBOL_OBSERVABLE_WRITABLE, SYMBOL_STORE, SYMBOL_STORE_KEYS, SYMBOL_STORE_OBSERVABLE, SYMBOL_STORE_TARGET, SYMBOL_STORE_VALUES, SYMBOL_STORE_UNTRACKED, SYMBOL_SUSPENSE, SYMBOL_UNCACHED, SYMBOL_UNTRACKED, SYMBOL_UNTRACKED_UNWRAPPED };\n","/* MAIN */\nconst castArray = (value) => {\n    return isArray(value) ? value : [value];\n};\nconst castError = (error) => {\n    if (error instanceof Error)\n        return error;\n    if (typeof error === 'string')\n        return new Error(error);\n    return new Error('Unknown error');\n};\nconst { is } = Object;\nconst { isArray } = Array;\nconst isEqual = (a, b) => {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n        const valueA = a[i];\n        const valueB = b[i];\n        if (!is(valueA, valueB))\n            return false;\n    }\n    return true;\n};\nconst isFunction = (value) => {\n    return typeof value === 'function';\n};\nconst isObject = (value) => {\n    return (value !== null) && (typeof value === 'object');\n};\nconst isSymbol = (value) => {\n    return typeof value === 'symbol';\n};\nconst noop = () => {\n    return;\n};\nconst nope = () => {\n    return false;\n};\n/* EXPORT */\nexport { castArray, castError, is, isArray, isEqual, isFunction, isObject, isSymbol, noop, nope };\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE, SYMBOL_OBSERVABLE_FROZEN, SYMBOL_OBSERVABLE_READABLE, SYMBOL_OBSERVABLE_WRITABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN - FUNCTIONS */\nfunction frozenFunction() {\n    if (arguments.length) {\n        throw new Error('A readonly Observable can not be updated');\n    }\n    else {\n        return this;\n    }\n}\nfunction readableFunction() {\n    if (arguments.length) {\n        throw new Error('A readonly Observable can not be updated');\n    }\n    else {\n        return this.get();\n    }\n}\nfunction writableFunction(fn) {\n    if (arguments.length) {\n        if (isFunction(fn)) {\n            return this.C(fn);\n        }\n        else {\n            return this.set(fn); //TSC\n        }\n    }\n    else {\n        return this.get();\n    }\n}\n/* MAIN - GENERATORS */\nconst frozen = (value) => {\n    const fn = frozenFunction.bind(value); //TSC\n    fn[SYMBOL_OBSERVABLE] = true;\n    fn[SYMBOL_OBSERVABLE_FROZEN] = true;\n    return fn;\n};\nconst readable = (value) => {\n    //TODO: Make a frozen one instead if disposed\n    const fn = readableFunction.bind(value); //TSC\n    fn[SYMBOL_OBSERVABLE] = true;\n    fn[SYMBOL_OBSERVABLE_READABLE] = value;\n    return fn;\n};\nconst writable = (value) => {\n    const fn = writableFunction.bind(value); //TSC\n    fn[SYMBOL_OBSERVABLE] = true;\n    fn[SYMBOL_OBSERVABLE_WRITABLE] = value;\n    return fn;\n};\n/* EXPORT */\nexport { frozen, readable, writable };\n","/* IMPORT */\nimport { frozen } from './objects/callable.js';\n/* MAIN */\nconst DIRTY_NO = 0; // The observer is not dirty, for sure\nconst DIRTY_MAYBE_NO = 1; // The observer is not dirty, possibly\nconst DIRTY_MAYBE_YES = 2; // The observer is dirty, possibly\nconst DIRTY_YES = 3; // The observer is dirty, for sure\nconst OBSERVABLE_FALSE = frozen(false);\nconst OBSERVABLE_TRUE = frozen(true);\nconst UNAVAILABLE = new Proxy({}, new Proxy({}, { get() { throw new Error('Unavailable value'); } })); //TSC\nconst UNINITIALIZED = function () { }; //TSC\n/* EXPORT */\nexport { DIRTY_NO, DIRTY_MAYBE_NO, DIRTY_MAYBE_YES, DIRTY_YES };\nexport { OBSERVABLE_FALSE, OBSERVABLE_TRUE };\nexport { UNAVAILABLE, UNINITIALIZED };\n","/* IMPORT */\n/* MAIN */\nconst lazyArrayEach = (arr, fn) => {\n    if (arr instanceof Array) {\n        for (let i = 0, l = arr.length; i < l; i++) {\n            fn(arr[i]);\n        }\n    }\n    else if (arr) {\n        fn(arr);\n    }\n};\nconst lazyArrayEachRight = (arr, fn) => {\n    if (arr instanceof Array) {\n        for (let i = arr.length - 1; i >= 0; i--) {\n            fn(arr[i]);\n        }\n    }\n    else if (arr) {\n        fn(arr);\n    }\n};\nconst lazyArrayPush = (obj, key, value) => {\n    const arr = obj[key];\n    if (arr instanceof Array) {\n        arr.push(value);\n    }\n    else if (arr) {\n        obj[key] = [arr, value];\n    }\n    else {\n        obj[key] = value;\n    }\n};\nconst lazySetAdd = (obj, key, value) => {\n    const set = obj[key];\n    if (set instanceof Set) {\n        set.add(value);\n    }\n    else if (set) {\n        if (value !== set) {\n            const s = new Set();\n            s.add(set);\n            s.add(value);\n            obj[key] = s;\n        }\n    }\n    else {\n        obj[key] = value;\n    }\n};\nconst lazySetDelete = (obj, key, value) => {\n    const set = obj[key];\n    if (set instanceof Set) {\n        set.delete(value);\n    }\n    else if (set === value) {\n        obj[key] = undefined;\n    }\n};\nconst lazySetEach = (set, fn) => {\n    if (set instanceof Set) {\n        for (const value of set) {\n            fn(value);\n        }\n    }\n    else if (set) {\n        fn(set);\n    }\n};\n/* EXPORT */\nexport { lazyArrayEach, lazyArrayEachRight, lazyArrayPush };\nexport { lazySetAdd, lazySetDelete, lazySetEach };\n","/* IMPORT */\nimport { UNAVAILABLE } from '../constants.js';\nimport { OBSERVER, OWNER, setObserver, setOwner } from '../context.js';\nimport { lazyArrayEachRight } from '../lazy.js';\nimport { castError } from '../utils.js';\n/* HELPERS */\nconst onCleanup = (cleanup) => cleanup.call(cleanup);\nconst onDispose = (owner) => owner.Q(true);\n/* MAIN */\n//TODO: Throw when registering stuff O disposing, maybe\nclass Owner {\n    constructor() {\n        /* VARIABLES */\n        this.disposed = false;\n        this.B = undefined;\n        this.S = undefined;\n        this.D = undefined;\n        this.K = undefined;\n        this.T = undefined;\n        this.U = undefined;\n    }\n    /* API */\n    catch(error, silent) {\n        const { S } = this;\n        if (S) {\n            S(error); //TODO: This assumes that the error handler won't throw immediately, which we know, but Owner shouldn't know\n            return true;\n        }\n        else {\n            if (this.parent?.catch(error, true))\n                return true;\n            if (silent)\n                return false;\n            // console.error ( error.stack ); // <-- Log \"error.stack\" to better understand where the error happened\n            throw error;\n        }\n    }\n    Q(deep) {\n        lazyArrayEachRight(this.D, onDispose);\n        lazyArrayEachRight(this.K, onDispose);\n        lazyArrayEachRight(this.U, onDispose);\n        lazyArrayEachRight(this.B, onCleanup);\n        this.B = undefined;\n        this.disposed = deep;\n        this.S = undefined;\n        this.K = undefined;\n        this.U = undefined;\n    }\n    get(symbol) {\n        return this.context?.[symbol];\n    }\n    E(fn, owner, observer) {\n        const ownerPrev = OWNER;\n        const observerPrev = OBSERVER;\n        setOwner(owner);\n        setObserver(observer);\n        try {\n            return fn();\n        }\n        catch (error) {\n            this.catch(castError(error), false); // Bubbling the error up\n            return UNAVAILABLE; // Returning a value that is the least likely to cause bugs\n        }\n        finally {\n            setOwner(ownerPrev);\n            setObserver(observerPrev);\n        }\n    }\n}\n/* EXPORT */\nexport default Owner;\n","/* IMPORT */\nimport Owner from './owner.js';\n/* MAIN */\nclass SuperRoot extends Owner {\n    constructor() {\n        /* VARIABLES */\n        super(...arguments);\n        this.context = {};\n    }\n}\n/* EXPORT */\nexport default SuperRoot;\n","/* IMPORT */\nimport SuperRoot from './objects/superroot.js';\n/* MAIN - READ */\n// This module relies on live-binding of exported variables to avoid a bunch of property accesses\nlet BATCH;\nlet SUPER_OWNER = new SuperRoot();\nlet OBSERVER;\nlet OWNER = SUPER_OWNER;\n/* MAIN - WRITE */\n// Unfortunately live-bounded exports can't just be overridden, so we need these functions\nconst setBatch = (value) => BATCH = value;\nconst setObserver = (value) => OBSERVER = value;\nconst setOwner = (value) => OWNER = value;\n/* EXPORT */\nexport { BATCH, OBSERVER, OWNER, SUPER_OWNER };\nexport { setBatch, setObserver, setOwner };\n","/* IMPORT */\nimport { setBatch } from '../context.js';\nimport { noop } from '../utils.js';\n/* HELPERS */\nlet M = 0;\nlet resolve = noop;\n/* MAIN */\nconst batch = async (fn) => {\n    if (!M) {\n        setBatch(new Promise(r => resolve = r));\n    }\n    try {\n        M += 1;\n        return await fn();\n    }\n    finally {\n        M -= 1;\n        if (!M) {\n            setBatch(undefined);\n            resolve();\n        }\n    }\n};\n/* MAIN */\nexport default batch;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE_BOOLEAN } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservableBoolean = (value) => {\n    return isFunction(value) && (SYMBOL_OBSERVABLE_BOOLEAN in value);\n};\n/* EXPORT */\nexport default isObservableBoolean;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE_FROZEN, SYMBOL_OBSERVABLE_READABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservableFrozen = (value) => {\n    return isFunction(value) && ((SYMBOL_OBSERVABLE_FROZEN in value) || !!value[SYMBOL_OBSERVABLE_READABLE]?.parent?.disposed);\n};\n/* EXPORT */\nexport default isObservableFrozen;\n","/* IMPORT */\nimport { SYMBOL_UNTRACKED, SYMBOL_UNTRACKED_UNWRAPPED } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isUntracked = (value) => {\n    return isFunction(value) && ((SYMBOL_UNTRACKED in value) || (SYMBOL_UNTRACKED_UNWRAPPED in value));\n};\n/* EXPORT */\nexport default isUntracked;\n","/* IMPORT */\n/* MAIN */\n// This ensures that there's only one flushing of the queue happening at the same time\nclass Scheduler {\n    constructor() {\n        /* VARIABLES */\n        this.A1 = [];\n        this.M = 0;\n        this.A2 = false;\n        /* QUEING API */\n        this.N = () => {\n            if (this.A2)\n                return;\n            if (this.M)\n                return;\n            if (!this.A1.length)\n                return;\n            try {\n                this.A2 = true;\n                while (true) {\n                    const queue = this.A1;\n                    if (!queue.length)\n                        break;\n                    this.A1 = [];\n                    for (let i = 0, l = queue.length; i < l; i++) {\n                        queue[i].C();\n                    }\n                }\n            }\n            finally {\n                this.A2 = false;\n            }\n        };\n        this.E = (fn) => {\n            this.M += 1;\n            fn();\n            this.M -= 1;\n            this.N();\n        };\n        /* SCHEDULING API */\n        this.F = (observer) => {\n            this.A1.push(observer);\n        };\n    }\n}\n/* EXPORT */\nexport default new Scheduler();\n","/* IMPORT */\nimport { DIRTY_MAYBE_NO, DIRTY_YES, UNINITIALIZED } from '../constants.js';\nimport { OBSERVER } from '../context.js';\nimport Scheduler from './scheduler.sync.js';\nimport { is, nope } from '../utils.js';\n/* MAIN */\nclass Observable {\n    /* CONSTRUCTOR */\n    constructor(value, options, parent) {\n        this.K = new Set();\n        this.value = value;\n        if (parent) {\n            this.parent = parent;\n        }\n        if (options?.equals !== undefined) {\n            this.equals = options.equals || nope;\n        }\n    }\n    /* API */\n    get() {\n        if (!this.parent?.disposed) {\n            this.parent?.C();\n            OBSERVER?.A.L(this);\n        }\n        return this.value;\n    }\n    set(value) {\n        const equals = this.equals || is;\n        const fresh = (this.value === UNINITIALIZED) || !equals(value, this.value);\n        if (!fresh)\n            return value;\n        this.value = value;\n        Scheduler.M += 1;\n        this.I(DIRTY_YES);\n        Scheduler.M -= 1;\n        Scheduler.N();\n        return value;\n    }\n    I(J) {\n        for (const observer of this.K) {\n            if (observer.J !== DIRTY_MAYBE_NO || observer.A.has(this)) { // Maybe this is a potential future dependency we haven't re-read yet\n                if (observer.sync) {\n                    observer.J = Math.max(observer.J, J);\n                    Scheduler.F(observer);\n                }\n                else {\n                    observer.I(J);\n                }\n            }\n        }\n    }\n    C(fn) {\n        const value = fn(this.value);\n        return this.set(value);\n    }\n}\n/* EXPORT */\nexport default Observable;\n","/* IMPORT */\n/* MAIN */\n// Dedicated data structures for managing A efficiently\n// We use an array if the list is small enough, as that's faster than a Set, and only switch to Sets O that\nclass ObservablesArray {\n    /* CONSTRUCTOR */\n    constructor(observer) {\n        this.observer = observer;\n        this.A = [];\n        this.P = 0;\n    }\n    /* API */\n    Q(deep) {\n        if (deep) {\n            const { observer, A } = this;\n            for (let i = 0; i < A.length; i++) {\n                A[i].K.delete(observer);\n            }\n        }\n        this.P = 0;\n    }\n    R() {\n        const { observer, A, P } = this;\n        const observablesLength = A.length;\n        if (P < observablesLength) {\n            for (let i = P; i < observablesLength; i++) {\n                A[i].K.delete(observer);\n            }\n            A.length = P;\n        }\n    }\n    empty() {\n        return !this.A.length;\n    }\n    has(observable) {\n        const index = this.A.indexOf(observable);\n        return index >= 0 && index < this.P;\n    }\n    L(observable) {\n        const { observer, A, P } = this;\n        const observablesLength = A.length;\n        if (observablesLength > 0) {\n            if (A[P] === observable) {\n                this.P += 1;\n                return;\n            }\n            const index = A.indexOf(observable);\n            if (index >= 0 && index < P) {\n                return;\n            }\n            if (P < observablesLength - 1) {\n                this.R();\n            }\n            else if (P === observablesLength - 1) {\n                A[P].K.delete(observer);\n            }\n        }\n        observable.K.add(observer);\n        A[this.P++] = observable;\n        if (P === 128) { // Switching to a Set, as indexOf checks may get artbirarily expensive otherwise\n            observer.A = new ObservablesSet(observer, A);\n        }\n    }\n    C() {\n        const { A } = this;\n        for (let i = 0, l = A.length; i < l; i++) {\n            A[i].parent?.C();\n        }\n    }\n}\nclass ObservablesSet {\n    /* CONSTRUCTOR */\n    constructor(observer, A) {\n        this.observer = observer;\n        this.A = new Set(A);\n    }\n    /* API */\n    Q(deep) {\n        for (const observable of this.A) {\n            observable.K.delete(this.observer);\n        }\n    }\n    R() {\n        return;\n    }\n    empty() {\n        return !this.A.size;\n    }\n    has(observable) {\n        return this.A.has(observable);\n    }\n    L(observable) {\n        const { observer, A } = this;\n        const sizePrev = A.size;\n        observable.K.add(observer);\n        const sizeNext = A.size;\n        if (sizePrev === sizeNext)\n            return; // Cheaper than Set.has+Set.add\n        A.add(observable);\n    }\n    C() {\n        for (const observable of this.A) {\n            observable.parent?.C();\n        }\n    }\n}\n/* EXPORT */\nexport { ObservablesArray, ObservablesSet };\n","/* IMPORT */\nimport { DIRTY_NO, DIRTY_MAYBE_NO, DIRTY_MAYBE_YES, DIRTY_YES } from '../constants.js';\nimport { OWNER, SUPER_OWNER } from '../context.js';\nimport { lazyArrayPush } from '../lazy.js';\nimport { ObservablesArray, ObservablesSet } from './observables.js';\nimport Owner from './owner.js';\n/* MAIN */\nclass Observer extends Owner {\n    /* CONSTRUCTOR */\n    constructor() {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = OWNER.context;\n        this.J = DIRTY_YES;\n        this.A = new ObservablesArray(this);\n        if (OWNER !== SUPER_OWNER) {\n            lazyArrayPush(this.parent, 'K', this);\n        }\n    }\n    /* API */\n    Q(deep) {\n        this.A.Q(deep);\n        super.Q(deep);\n    }\n    H(fn) {\n        this.Q(false);\n        this.J = DIRTY_MAYBE_NO; // Resetting the trip flag, we didn't re-execute just yet\n        try {\n            return this.E(fn, this, this);\n        }\n        finally {\n            this.A.R();\n        }\n    }\n    run() {\n        throw new Error('Abstract method');\n    }\n    I(J) {\n        throw new Error('Abstract method');\n    }\n    C() {\n        if (this.disposed)\n            return; // Disposed, it shouldn't be updated again\n        if (this.J === DIRTY_MAYBE_YES) { // Maybe we are dirty, let's check with our A, to be sure\n            this.A.C();\n        }\n        if (this.J === DIRTY_YES) { // We are dirty, let's H\n            this.J = DIRTY_MAYBE_NO; // Trip flag, to be able to tell if we caused ourselves to be dirty again\n            this.run();\n            if (this.J === DIRTY_MAYBE_NO) { // Not dirty anymore\n                this.J = DIRTY_NO;\n            }\n            else { // Maybe we are still dirty, let's check again\n                this.C();\n            }\n        }\n        else { // Not dirty\n            this.J = DIRTY_NO;\n        }\n    }\n}\n/* EXPORT */\nexport default Observer;\n","/* IMPORT */\nimport { DIRTY_MAYBE_YES, UNAVAILABLE, UNINITIALIZED } from '../constants.js';\nimport Observable from './observable.js';\nimport Observer from './observer.js';\n/* MAIN */\nclass Memo extends Observer {\n    /* CONSTRUCTOR */\n    constructor(fn, options) {\n        super();\n        this.fn = fn;\n        this.observable = new Observable(UNINITIALIZED, options, this);\n        if (options?.sync === true) {\n            this.sync = true;\n            this.C();\n        }\n    }\n    /* API */\n    run() {\n        const G = super.H(this.fn);\n        if (!this.disposed && this.A.empty()) {\n            this.disposed = true;\n        }\n        if (G !== UNAVAILABLE) {\n            this.observable.set(G);\n        }\n    }\n    I(J) {\n        const statusPrev = this.J;\n        if (statusPrev >= J)\n            return;\n        this.J = J;\n        if (statusPrev === DIRTY_MAYBE_YES)\n            return;\n        this.observable.I(DIRTY_MAYBE_YES);\n    }\n}\n/* EXPORT */\nexport default Memo;\n","/* IMPORT */\nimport isObservableFrozen from './is_observable_frozen.js';\nimport isUntracked from './is_untracked.js';\nimport { frozen, readable } from '../objects/callable.js';\nimport Memo from '../objects/memo.js';\n/* MAIN */\nconst memo = (fn, options) => {\n    if (isObservableFrozen(fn)) {\n        return fn;\n    }\n    else if (isUntracked(fn)) {\n        return frozen(fn());\n    }\n    else {\n        const memo = new Memo(fn, options);\n        const observable = readable(memo.observable);\n        return observable;\n    }\n};\n/* EXPORT */\nexport default memo;\n","/* IMPORT */\nimport isObservableBoolean from './is_observable_boolean.js';\nimport isObservableFrozen from './is_observable_frozen.js';\nimport isUntracked from './is_untracked.js';\nimport memo from './memo.js';\nimport { SYMBOL_OBSERVABLE_BOOLEAN } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst boolean = (value) => {\n    if (isFunction(value)) {\n        if (isObservableFrozen(value) || isUntracked(value)) {\n            return !!value();\n        }\n        else if (isObservableBoolean(value)) {\n            return value;\n        }\n        else {\n            const boolean = memo(() => !!value());\n            boolean[SYMBOL_OBSERVABLE_BOOLEAN] = true;\n            return boolean;\n        }\n    }\n    else {\n        return !!value;\n    }\n};\n/* EXPORT */\nexport default boolean;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazyArrayPush } from '../lazy.js';\n/* MAIN */\nconst cleanup = (fn) => {\n    lazyArrayPush(OWNER, 'B', fn);\n};\n/* EXPORT */\nexport default cleanup;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazyArrayPush } from '../lazy.js';\nimport Owner from './owner.js';\n/* MAIN */\nclass Context extends Owner {\n    /* CONSTRUCTOR */\n    constructor(context) {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = { ...OWNER.context, ...context };\n        lazyArrayPush(this.parent, 'D', this);\n    }\n    /* API */\n    E(fn) {\n        return super.E(fn, this, undefined);\n    }\n}\n/* EXPORT */\nexport default Context;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport Context from '../objects/context.js';\nimport { isSymbol, noop } from '../utils.js';\nfunction context(symbolOrContext, fn) {\n    if (isSymbol(symbolOrContext)) {\n        return OWNER.context[symbolOrContext];\n    }\n    else {\n        return new Context(symbolOrContext).E(fn || noop);\n    }\n}\n/* EXPORT */\nexport default context;\n","/* IMPORT */\nimport cleanup from './cleanup.js';\nimport { readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\n/* MAIN */\nconst disposed = () => {\n    const observable = new Observable(false);\n    const A4 = () => observable.set(true);\n    cleanup(A4);\n    return readable(observable);\n};\n/* EXPORT */\nexport default disposed;\n","/* IMPORT */\nimport { BATCH } from '../context.js';\n/* MAIN */\n// Using 2 microtasks to give a chance to things using 1 microtask (like refs in Voby) to run first\nclass Scheduler {\n    constructor() {\n        /* VARIABLES */\n        this.A1 = [];\n        this.A2 = false;\n        this.A3 = false;\n        /* QUEUING API */\n        this.N = () => {\n            if (this.A2)\n                return;\n            if (!this.A1.length)\n                return;\n            try {\n                this.A2 = true;\n                while (true) {\n                    const queue = this.A1;\n                    if (!queue.length)\n                        break;\n                    this.A1 = [];\n                    for (let i = 0, l = queue.length; i < l; i++) {\n                        queue[i].C();\n                    }\n                }\n            }\n            finally {\n                this.A2 = false;\n            }\n        };\n        this.queue = () => {\n            if (this.A3)\n                return;\n            this.A3 = true;\n            this.resolve();\n        };\n        this.resolve = () => {\n            queueMicrotask(() => {\n                queueMicrotask(() => {\n                    if (BATCH) {\n                        BATCH.finally(this.resolve);\n                    }\n                    else {\n                        this.A3 = false;\n                        this.N();\n                    }\n                });\n            });\n        };\n        /* SCHEDULING API */\n        this.F = (effect) => {\n            this.A1.push(effect);\n            this.queue();\n        };\n    }\n}\n/* EXPORT */\nexport default new Scheduler();\n","/* IMPORT */\nimport { lazyArrayPush } from '../lazy.js';\nimport Observer from './observer.js';\nimport Scheduler from './scheduler.async.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nclass Effect extends Observer {\n    /* CONSTRUCTOR */\n    constructor(fn, options) {\n        super();\n        this.fn = fn;\n        if (options?.suspense !== false) {\n            const suspense = this.get(SYMBOL_SUSPENSE);\n            if (suspense) {\n                this.suspense = suspense;\n            }\n        }\n        if (options?.sync === true) {\n            this.sync = true;\n        }\n        if (options?.sync === 'init') {\n            this.init = true;\n            this.C();\n        }\n        else {\n            this.F();\n        }\n    }\n    /* API */\n    run() {\n        const G = super.H(this.fn);\n        if (isFunction(G)) {\n            lazyArrayPush(this, 'B', G);\n        }\n    }\n    F() {\n        if (this.suspense?.suspended)\n            return;\n        if (this.sync) {\n            this.C();\n        }\n        else {\n            Scheduler.F(this);\n        }\n    }\n    I(J) {\n        const statusPrev = this.J;\n        if (statusPrev >= J)\n            return;\n        this.J = J;\n        if (!this.sync || (statusPrev !== 2 && statusPrev !== 3)) { // It isn't currently executing, so let's F it\n            this.F();\n        }\n    }\n    C() {\n        if (this.suspense?.suspended)\n            return;\n        super.C();\n    }\n}\n/* EXPORT */\nexport default Effect;\n","/* IMPORT */\nimport Effect from '../objects/effect.js';\n/* MAIN */\nconst effect = (fn, options) => {\n    const effect = new Effect(fn, options);\n    const Q = () => effect.Q(true);\n    return Q;\n};\n/* EXPORT */\nexport default effect;\n","/* IMPORT */\nimport memo from './memo.js';\nimport { frozen } from '../objects/callable.js';\nimport { SYMBOL_OBSERVABLE, SYMBOL_UNTRACKED, SYMBOL_UNTRACKED_UNWRAPPED } from '../symbols.js';\nimport { isFunction } from '../utils.js';\nfunction resolve(value) {\n    if (isFunction(value)) {\n        if (SYMBOL_UNTRACKED_UNWRAPPED in value) {\n            return resolve(value());\n        }\n        else if (SYMBOL_UNTRACKED in value) {\n            return frozen(resolve(value()));\n        }\n        else if (SYMBOL_OBSERVABLE in value) {\n            return value;\n        }\n        else {\n            return memo(() => resolve(value()));\n        }\n    }\n    if (value instanceof Array) {\n        const resolved = new Array(value.length);\n        for (let i = 0, l = resolved.length; i < l; i++) {\n            resolved[i] = resolve(value[i]);\n        }\n        return resolved;\n    }\n    else {\n        return value;\n    }\n}\n/* EXPORT */\nexport default resolve;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazySetAdd, lazySetDelete } from '../lazy.js';\nimport Owner from './owner.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\n/* MAIN */\nclass Root extends Owner {\n    /* CONSTRUCTOR */\n    constructor(V) {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = OWNER.context;\n        if (V) {\n            const suspense = this.get(SYMBOL_SUSPENSE);\n            if (suspense) {\n                this.A0 = true;\n                lazySetAdd(this.parent, 'T', this);\n            }\n        }\n    }\n    /* API */\n    Q(deep) {\n        if (this.A0) {\n            lazySetDelete(this.parent, 'T', this);\n        }\n        super.Q(deep);\n    }\n    E(fn) {\n        const Q = () => this.Q(true);\n        const fnWithDispose = () => fn(Q);\n        return super.E(fnWithDispose, this, undefined);\n    }\n}\n/* EXPORT */\nexport default Root;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazySetAdd, lazySetDelete } from '../lazy.js';\nimport cleanup from './cleanup.js';\nimport resolve from './resolve.js';\nimport { frozen, readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport Root from '../objects/root.js';\nimport { SYMBOL_CACHED, SYMBOL_SUSPENSE, SYMBOL_UNCACHED } from '../symbols.js';\n/* HELPERS */\nconst DUMMY_INDEX = frozen(-1);\nclass MappedRoot extends Root {\n}\n/* MAIN */\nclass CacheKeyed {\n    /* CONSTRUCTOR */\n    constructor(fn) {\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.suspense = OWNER.get(SYMBOL_SUSPENSE);\n        this.A5 = new Map();\n        this.A6 = false; // The A6 is flipped with each iteration, the T that don't have the updated one are disposed, it's like a cheap M basically\n        this.A7 = 0; // Number of previous items\n        this.A8 = 0; // Number of previous items that got reused\n        this.A9 = 0; // Number of next items\n        /* API */\n        this.cleanup = () => {\n            if (!this.A7)\n                return; // There was nothing AA, no need to cleanup\n            if (this.A7 === this.A8)\n                return; // All the previous items were reused, no need to cleanup\n            const { A5, A6 } = this;\n            if (!A5.size)\n                return; // Nothing to Q of\n            if (this.A9) { // Regular cleanup\n                A5.forEach((mapped, value) => {\n                    if (mapped.A6 === A6)\n                        return;\n                    mapped.Q(true);\n                    A5.delete(value);\n                });\n            }\n            else { // There is nothing O, disposing quickly\n                this.A5.forEach(mapped => {\n                    mapped.Q(true);\n                });\n                this.A5 = new Map();\n            }\n        };\n        this.Q = () => {\n            if (this.suspense) {\n                lazySetDelete(this.parent, 'T', this.T);\n            }\n            this.A7 = this.A5.size;\n            this.A8 = 0;\n            this.A9 = 0;\n            this.cleanup();\n        };\n        this.AA = () => {\n            this.A6 = !this.A6;\n            this.A8 = 0;\n            this.A9 = 0;\n        };\n        this.O = (values) => {\n            this.A9 = values.length;\n            this.cleanup();\n            this.A7 = this.A9;\n            this.A8 = 0;\n        };\n        this.map = (values) => {\n            this.AA();\n            const { A5, A6, fn, AB } = this;\n            const results = new Array(values.length);\n            let resultsCached = true; // Whether all results are cached, if so this enables an optimization\n            let resultsUncached = true; // Whether all results are anew, if so this enables an optimization in Voby\n            let A8 = 0;\n            for (let i = 0, l = values.length; i < l; i++) {\n                const value = values[i];\n                const cached = A5.get(value);\n                if (cached && cached.A6 !== A6) {\n                    resultsUncached = false;\n                    A8 += 1;\n                    cached.A6 = A6;\n                    cached.index?.set(i);\n                    results[i] = cached.G; //TSC\n                }\n                else {\n                    resultsCached = false;\n                    const mapped = new MappedRoot(false);\n                    if (cached) {\n                        cleanup(() => mapped.Q(true));\n                    }\n                    mapped.E(() => {\n                        let index = DUMMY_INDEX;\n                        if (AB) {\n                            mapped.index = new Observable(i);\n                            index = readable(mapped.index);\n                        }\n                        const G = results[i] = resolve(fn(value, index));\n                        mapped.A6 = A6;\n                        mapped.G = G;\n                        if (!cached) {\n                            A5.set(value, mapped);\n                        }\n                    });\n                }\n            }\n            this.A8 = A8;\n            this.O(values);\n            if (resultsCached) {\n                results[SYMBOL_CACHED] = true;\n            }\n            if (resultsUncached) {\n                results[SYMBOL_UNCACHED] = true;\n            }\n            return results;\n        };\n        this.T = () => {\n            return Array.from(this.A5.values());\n        };\n        this.fn = fn;\n        this.AB = (fn.length > 1);\n        if (this.suspense) {\n            lazySetAdd(this.parent, 'T', this.T);\n        }\n    }\n}\n/* EXPORT */\nexport default CacheKeyed;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservable = (value) => {\n    return isFunction(value) && (SYMBOL_OBSERVABLE in value);\n};\n/* EXPORT */\nexport default isObservable;\n","/* IMPORT */\nimport isObservable from './is_observable.js';\nimport { isFunction } from '../utils.js';\nfunction get(value, getFunction = true) {\n    const is = getFunction ? isFunction : isObservable;\n    if (is(value)) {\n        return value();\n    }\n    else {\n        return value;\n    }\n}\n/* EXPORT */\nexport default get;\n","/* IMPORT */\nimport { DIRTY_MAYBE_YES, DIRTY_YES } from '../constants.js';\nimport { OWNER } from '../context.js';\nimport { lazyArrayEach, lazyArrayPush, lazySetEach } from '../lazy.js';\nimport Effect from './effect.js';\nimport Owner from './owner.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nclass Suspense extends Owner {\n    /* CONSTRUCTOR */\n    constructor() {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = { ...OWNER.context, [SYMBOL_SUSPENSE]: this };\n        lazyArrayPush(this.parent, 'U', this);\n        this.suspended = (OWNER.get(SYMBOL_SUSPENSE)?.suspended || 0);\n    }\n    /* API */\n    A4(force) {\n        if (!this.suspended && !force)\n            return; // Already suspended, this can happen at instantion time\n        const suspendedPrev = this.suspended;\n        const suspendedNext = suspendedPrev + (force ? 1 : -1);\n        this.suspended = suspendedNext;\n        if (!!suspendedPrev === !!suspendedNext)\n            return; // Same state, nothing to pause or resume\n        /* NOTIFYING OBSERVERS, ROOTS AND SUSPENSES */\n        this.observable?.set(!!suspendedNext);\n        const notifyOwner = (owner) => {\n            lazyArrayEach(owner.D, notifyOwner);\n            lazyArrayEach(owner.K, notifyObserver);\n            lazyArrayEach(owner.U, notifySuspense);\n            lazySetEach(owner.T, notifyRoot);\n        };\n        const notifyObserver = (observer) => {\n            if (observer instanceof Effect) {\n                if (observer.J === DIRTY_MAYBE_YES || observer.J === DIRTY_YES) {\n                    if (observer.init) {\n                        observer.C();\n                    }\n                    else {\n                        observer.F();\n                    }\n                }\n            }\n            notifyOwner(observer);\n        };\n        const notifyRoot = (root) => {\n            if (isFunction(root)) {\n                root().forEach(notifyOwner);\n            }\n            else {\n                notifyOwner(root);\n            }\n        };\n        const notifySuspense = (suspense) => {\n            suspense.A4(force);\n        };\n        notifyOwner(this);\n    }\n    E(fn) {\n        return super.E(fn, this, undefined);\n    }\n}\n/* EXPORT */\nexport default Suspense;\n","/* IMPORT */\nimport boolean from './boolean.js';\nimport effect from './effect.js';\nimport get from './get.js';\nimport Suspense from '../objects/suspense.js';\n/* MAIN */\nconst suspense = (when, fn) => {\n    const suspense = new Suspense();\n    const condition = boolean(when);\n    const A4 = () => suspense.A4(get(condition));\n    effect(A4, { sync: true });\n    return suspense.E(fn);\n};\n/* EXPORT */\nexport default suspense;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazySetAdd, lazySetDelete } from '../lazy.js';\nimport cleanup from './cleanup.js';\nimport get from './get.js';\nimport memo from './memo.js';\nimport resolve from './resolve.js';\nimport suspense from './suspense.js';\nimport { frozen, readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport Root from '../objects/root.js';\nimport { SYMBOL_CACHED, SYMBOL_SUSPENSE, SYMBOL_UNCACHED } from '../symbols.js';\n/* HELPERS */\nconst DUMMY_INDEX = frozen(-1);\nclass MappedRoot extends Root {\n}\n/* MAIN */\n//TODO: Optimize this more\nclass CacheUnkeyed {\n    /* CONSTRUCTOR */\n    constructor(fn, pooled) {\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.suspense = OWNER.get(SYMBOL_SUSPENSE);\n        this.A5 = new Map();\n        this.AC = [];\n        this.AD = 0;\n        /* API */\n        this.cleanup = () => {\n            let pooled = 0;\n            let poolable = Math.max(0, this.pooled ? this.AD - this.AC.length : 0);\n            this.A5.forEach(mapped => {\n                if (poolable > 0 && pooled++ < poolable) {\n                    mapped.suspended?.set(true);\n                    this.AC.push(mapped);\n                }\n                else {\n                    mapped.Q(true);\n                }\n            });\n        };\n        this.Q = () => {\n            if (this.suspense) {\n                lazySetDelete(this.parent, 'T', this.T);\n            }\n            this.A5.forEach(mapped => {\n                mapped.Q(true);\n            });\n            this.AC.forEach(mapped => {\n                mapped.Q(true);\n            });\n        };\n        this.map = (values) => {\n            const { A5, fn, AB } = this;\n            const cacheNext = new Map();\n            const results = new Array(values.length);\n            const AC = this.AC;\n            const pooled = this.pooled;\n            let resultsCached = true; // Whether all results are cached, if so this enables an optimization\n            let resultsUncached = true; // Whether all results are anew, if so this enables an optimization in Voby\n            let leftovers = [];\n            if (A5.size) {\n                for (let i = 0, l = values.length; i < l; i++) {\n                    const value = values[i];\n                    const cached = A5.get(value);\n                    if (cached) {\n                        resultsUncached = false;\n                        A5.delete(value);\n                        cacheNext.set(value, cached);\n                        cached.index?.set(i);\n                        results[i] = cached.G; //TSC\n                    }\n                    else {\n                        leftovers.push(i);\n                    }\n                }\n            }\n            else {\n                leftovers = new Array(results.length);\n            }\n            outer: for (let i = 0, l = leftovers.length; i < l; i++) {\n                const index = leftovers[i] || i;\n                const value = values[index];\n                const isDuplicate = cacheNext.has(value);\n                if (!isDuplicate) {\n                    for (const [key, mapped] of A5.entries()) {\n                        A5.delete(key);\n                        cacheNext.set(value, mapped);\n                        mapped.index?.set(index);\n                        mapped.value?.set(value);\n                        results[index] = mapped.G; //TSC\n                        continue outer;\n                    }\n                }\n                resultsCached = false;\n                let mapped;\n                if (pooled && AC.length) {\n                    mapped = AC.pop(); //TSC\n                    mapped.index?.set(index);\n                    mapped.value?.set(value);\n                    mapped.suspended?.set(false);\n                    results[index] = mapped.G; //TSC\n                }\n                else {\n                    mapped = new MappedRoot(false);\n                    mapped.E(() => {\n                        let $index = DUMMY_INDEX;\n                        if (AB) {\n                            mapped.index = new Observable(index);\n                            $index = readable(mapped.index);\n                        }\n                        const observable = mapped.value = new Observable(value);\n                        const suspended = pooled ? new Observable(false) : undefined;\n                        const $value = memo(() => get(observable.get())); //TSC\n                        const G = results[index] = suspended ? suspense(() => suspended.get(), () => resolve(fn($value, $index))) : resolve(fn($value, $index));\n                        mapped.value = observable;\n                        mapped.G = G;\n                        mapped.suspended = suspended;\n                    });\n                }\n                if (isDuplicate) { // Expensive, not reusable\n                    cleanup(() => mapped.Q(true));\n                }\n                else { // Cheap, reusable\n                    cacheNext.set(value, mapped);\n                }\n            }\n            this.AD = Math.max(this.AD, results.length);\n            this.cleanup();\n            this.A5 = cacheNext;\n            if (resultsCached) {\n                results[SYMBOL_CACHED] = true;\n            }\n            if (resultsUncached) {\n                results[SYMBOL_UNCACHED] = true;\n            }\n            return results;\n        };\n        this.T = () => {\n            return [...this.A5.values(), ...this.AC.values()];\n        };\n        this.fn = fn;\n        this.AB = (fn.length > 1);\n        this.pooled = pooled;\n        if (this.suspense) {\n            lazySetAdd(this.parent, 'T', this.T);\n        }\n    }\n}\n/* EXPORT */\nexport default CacheUnkeyed;\n","/* IMPORT */\nimport { SYMBOL_STORE } from '../symbols.js';\nimport { isObject } from '../utils.js';\n/* MAIN */\nconst isStore = (value) => {\n    return isObject(value) && (SYMBOL_STORE in value);\n};\n/* EXPORT */\nexport default isStore;\n","/* IMPORT */\nimport { OBSERVER, setObserver } from '../context.js';\nimport { isFunction } from '../utils.js';\nfunction untrack(fn) {\n    if (isFunction(fn)) {\n        const observerPrev = OBSERVER;\n        if (observerPrev) {\n            try {\n                setObserver(undefined);\n                return fn();\n            }\n            finally {\n                setObserver(observerPrev);\n            }\n        }\n        else {\n            return fn();\n        }\n    }\n    else {\n        return fn;\n    }\n}\n/* EXPORT */\nexport default untrack;\n","/* IMPORT */\nimport cleanup from './cleanup.js';\nimport CacheKeyed from './for.cache.keyed.js';\nimport CacheUnkeyed from './for.cache.unkeyed.js';\nimport get from './get.js';\nimport isObservable from './is_observable.js';\nimport isStore from './is_store.js';\nimport memo from './memo.js';\nimport resolve from './resolve.js';\nimport untrack from './untrack.js';\nimport { frozen } from '../objects/callable.js';\nimport { SYMBOL_CACHED, SYMBOL_STORE_VALUES } from '../symbols.js';\nimport { isArray, isEqual } from '../utils.js';\nfunction _for(values, fn, fallback = [], options) {\n    if (isArray(values) && !isStore(values)) { // Fast path for plain arrays\n        const isUnkeyed = !!options?.unkeyed;\n        return frozen(untrack(() => {\n            if (values.length) {\n                return values.map((value, index) => {\n                    return resolve(fn(isUnkeyed && !isObservable(value) ? frozen(value) : value, index));\n                });\n            }\n            else {\n                return resolve(fallback);\n            }\n        }));\n    }\n    else { // Regular path\n        const { Q, map } = options?.unkeyed ? new CacheUnkeyed(fn, !!options.pooled) : new CacheKeyed(fn); //TSC\n        cleanup(Q);\n        const value = memo(() => {\n            return get(values) ?? [];\n        }, {\n            equals: (next, prev) => {\n                return !!next && !!prev && !next.length && !prev.length && !isStore(next) && !isStore(prev);\n            }\n        });\n        return memo(() => {\n            const array = value();\n            if (isStore(array)) {\n                array[SYMBOL_STORE_VALUES];\n            }\n            return untrack(() => {\n                const results = map(array);\n                return results?.length ? results : resolve(fallback);\n            });\n        }, {\n            equals: (next, prev) => {\n                return isArray(next) && !!next[SYMBOL_CACHED] && isArray(prev) && isEqual(next, prev);\n            }\n        });\n    }\n}\n/* EXPORT */\nexport default _for;\n","/* IMPORT */\nimport untrack from './untrack.js';\n/* MAIN */\n// This function ensures an Observable contains a fresh value, mainly to try to push it into a frozen state, if possible\nconst warmup = (value) => {\n    untrack(value);\n    return value;\n};\n/* EXPORT */\nexport default warmup;\n","/* IMPORT */\nimport get from './get.js';\nimport isObservableBoolean from './is_observable_boolean.js';\nimport isObservableFrozen from './is_observable_frozen.js';\nimport isUntracked from './is_untracked.js';\nimport memo from './memo.js';\nimport resolve from './resolve.js';\nimport warmup from './warmup.js';\nimport { frozen } from '../objects/callable.js';\nimport { is, isFunction } from '../utils.js';\n/* HELPERS */\nconst match = (condition, values, fallback) => {\n    for (let i = 0, l = values.length; i < l; i++) {\n        const value = values[i];\n        if (value.length === 1)\n            return value[0];\n        if (is(value[0], condition))\n            return value[1];\n    }\n    return fallback;\n};\nfunction _switch(when, values, fallback) {\n    const isDynamic = isFunction(when) && !isObservableFrozen(when) && !isUntracked(when);\n    if (isDynamic) {\n        if (isObservableBoolean(when)) {\n            return memo(() => resolve(match(when(), values, fallback)));\n        }\n        const value = warmup(memo(() => match(when(), values, fallback)));\n        if (isObservableFrozen(value)) {\n            return frozen(resolve(value()));\n        }\n        else {\n            return memo(() => resolve(get(value)));\n        }\n    }\n    else {\n        const value = match(get(when), values, fallback);\n        return frozen(resolve(value));\n    }\n}\n/* EXPORT */\nexport default _switch;\n","/* IMPORT */\nimport boolean from './boolean.js';\nimport _switch from './switch.js';\n/* MAIN */\nconst ternary = (when, valueTrue, valueFalse) => {\n    const condition = boolean(when);\n    return _switch(condition, [[true, valueTrue], [valueFalse]]);\n};\n/* EXPORT */\nexport default ternary;\n","/* IMPORT */\nimport ternary from './ternary.js';\nfunction _if(when, valueTrue, valueFalse) {\n    return ternary(when, valueTrue, valueFalse);\n}\n/* EXPORT */\nexport default _if;\n","/* IMPORT */\nimport { BATCH } from '../context.js';\nimport SchedulerAsync from '../objects/scheduler.async.js';\nimport SchedulerSync from '../objects/scheduler.sync.js';\n/* MAIN */\nconst isBatching = () => {\n    return !!BATCH || SchedulerAsync.A3 || SchedulerAsync.A2 || SchedulerSync.A2;\n};\n/* EXPORT */\nexport default isBatching;\n","/* IMPORT */\nimport { writable } from '../objects/callable.js';\nimport ObservableClass from '../objects/observable.js';\nfunction observable(value, options) {\n    return writable(new ObservableClass(value, options));\n}\n/* EXPORT */\nexport default observable;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport Observer from '../objects/observer.js';\nimport Root from '../objects/root.js';\nimport SuperRoot from '../objects/superroot.js';\nimport Suspense from '../objects/suspense.js';\n/* MAIN */\nconst owner = () => {\n    const isSuperRoot = (OWNER instanceof SuperRoot);\n    const isRoot = (OWNER instanceof Root);\n    const isSuspense = (OWNER instanceof Suspense);\n    const isComputation = (OWNER instanceof Observer);\n    return { isSuperRoot, isRoot, isSuspense, isComputation };\n};\n/* EXPORT */\nexport default owner;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE_WRITABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservableWritable = (value) => {\n    return isFunction(value) && (SYMBOL_OBSERVABLE_WRITABLE in value);\n};\n/* EXPORT */\nexport default isObservableWritable;\n","/* IMPORT */\nimport { UNAVAILABLE } from '../constants.js';\nimport { SYMBOL_OBSERVABLE_READABLE, SYMBOL_OBSERVABLE_WRITABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst target = (observable) => {\n    if (isFunction(observable)) {\n        return observable[SYMBOL_OBSERVABLE_READABLE] || observable[SYMBOL_OBSERVABLE_WRITABLE] || UNAVAILABLE;\n    }\n    else {\n        return observable;\n    }\n};\n/* EXPORT */\nexport default target;\n","/* IMPORT */\nimport isObservableWritable from './is_observable_writable.js';\nimport target from './target.js';\nimport { readable } from '../objects/callable.js';\n/* MAIN */\nconst readonly = (observable) => {\n    if (isObservableWritable(observable)) {\n        return readable(target(observable));\n    }\n    else {\n        return observable;\n    }\n};\n/* EXPORT */\nexport default readonly;\n","/* IMPORT */\nimport Root from '../objects/root.js';\n/* MAIN */\nconst root = (fn) => {\n    return new Root(true).E(fn);\n};\n/* EXPORT */\nexport default root;\n","/* IMPORT */\nimport { OBSERVABLE_FALSE, OBSERVABLE_TRUE } from '../constants.js';\nimport cleanup from './cleanup.js';\nimport effect from './effect.js';\nimport isObservableFrozen from './is_observable_frozen.js';\nimport memo from './memo.js';\nimport untrack from './untrack.js';\nimport warmup from './warmup.js';\nimport { readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport { is } from '../utils.js';\n/* HELPERS */\nclass DisposableMap extends Map {\n    constructor() {\n        super(...arguments);\n        this.disposed = false;\n    }\n}\nclass SelectedObservable extends Observable {\n    constructor() {\n        super(...arguments);\n        this.AE = 1;\n    }\n    /* API */\n    call() {\n        if (this.AF.disposed)\n            return;\n        this.AE -= 1;\n        if (this.AE)\n            return;\n        this.AF.delete(this.AG);\n    }\n}\n/* MAIN */\nconst selector = (AG) => {\n    /* NORMALIZING SOURCE */\n    AG = warmup(memo(AG));\n    /* FROZEN SOURCE */\n    if (isObservableFrozen(AG)) {\n        const sourceValue = untrack(AG);\n        return (value) => {\n            return (value === sourceValue) ? OBSERVABLE_TRUE : OBSERVABLE_FALSE;\n        };\n    }\n    /* SELECTEDS */\n    let AF = new DisposableMap();\n    let selectedValue = untrack(AG);\n    effect(() => {\n        const valuePrev = selectedValue;\n        const valueNext = AG();\n        if (is(valuePrev, valueNext))\n            return;\n        selectedValue = valueNext;\n        AF.get(valuePrev)?.set(false);\n        AF.get(valueNext)?.set(true);\n    }, { suspense: false, sync: true });\n    /* CLEANUP ALL */\n    const cleanupAll = () => {\n        AF.disposed = true;\n    };\n    cleanup(cleanupAll);\n    /* SELECTOR */\n    return (value) => {\n        /* INIT */\n        let selected = AF.get(value);\n        if (selected) {\n            selected.AE += 1;\n        }\n        else {\n            selected = new SelectedObservable(value === selectedValue);\n            selected.AF = AF;\n            selected.AG = value;\n            AF.set(value, selected);\n        }\n        /* CLEANUP */\n        cleanup(selected);\n        /* RETURN */\n        return readable(selected);\n    };\n};\n/* EXPORT */\nexport default selector;\n","/* IMPORT */\nimport { BATCH, OBSERVER } from '../context.js';\nimport { lazySetAdd, lazySetDelete, lazySetEach } from '../lazy.js';\nimport cleanup from './cleanup.js';\nimport effect from './effect.js';\nimport isBatching from './is_batching.js';\nimport isStore from './is_store.js';\nimport untrack from './untrack.js';\nimport { readable } from '../objects/callable.js';\nimport ObservableClass from '../objects/observable.js';\nimport { SYMBOL_STORE, SYMBOL_STORE_KEYS, SYMBOL_STORE_OBSERVABLE, SYMBOL_STORE_TARGET, SYMBOL_STORE_VALUES, SYMBOL_STORE_UNTRACKED } from '../symbols.js';\nimport { castArray, is, isArray, isFunction, isObject, noop, nope } from '../utils.js';\n/* CLASSES */\nclass StoreMap extends Map {\n    AH(key, value) {\n        super.set(key, value);\n        return value;\n    }\n}\nclass StoreCleanable {\n    constructor() {\n        this.AE = 0;\n    }\n    listen() {\n        this.AE += 1;\n        cleanup(this);\n    }\n    call() {\n        this.AE -= 1;\n        if (this.AE)\n            return;\n        this.Q();\n    }\n    Q() { }\n}\nclass StoreKeys extends StoreCleanable {\n    constructor(parent, observable) {\n        super();\n        this.parent = parent;\n        this.observable = observable;\n    }\n    Q() {\n        this.parent.keys = undefined;\n    }\n}\nclass StoreValues extends StoreCleanable {\n    constructor(parent, observable) {\n        super();\n        this.parent = parent;\n        this.observable = observable;\n    }\n    Q() {\n        this.parent.values = undefined;\n    }\n}\nclass StoreHas extends StoreCleanable {\n    constructor(parent, key, observable) {\n        super();\n        this.parent = parent;\n        this.key = key;\n        this.observable = observable;\n    }\n    Q() {\n        this.parent.has?.delete(this.key);\n    }\n}\nclass StoreProperty extends StoreCleanable {\n    constructor(parent, key, observable, AI) {\n        super();\n        this.parent = parent;\n        this.key = key;\n        this.observable = observable;\n        this.AI = AI;\n    }\n    Q() {\n        this.parent.AJ?.delete(this.key);\n    }\n}\nconst StoreListenersRegular = {\n    /* VARIABLES */\n    AK: 0,\n    AL: new Set(),\n    AM: new Set(),\n    /* API */\n    AN: () => {\n        const { AL, AM } = StoreListenersRegular;\n        const traversed = new Set();\n        const traverse = (AI) => {\n            if (traversed.has(AI))\n                return;\n            traversed.add(AI);\n            lazySetEach(AI.AO, traverse);\n            lazySetEach(AI.AP, listener => {\n                AL.add(listener);\n            });\n        };\n        AM.forEach(traverse);\n        return () => {\n            AL.forEach(listener => {\n                listener();\n            });\n        };\n    },\n    V: (AI) => {\n        StoreListenersRegular.AM.add(AI);\n        StoreScheduler.F();\n    },\n    reset: () => {\n        StoreListenersRegular.AL = new Set();\n        StoreListenersRegular.AM = new Set();\n    }\n};\nconst StoreListenersRoots = {\n    /* VARIABLES */\n    AK: 0,\n    AM: new Map(),\n    /* API */\n    AN: () => {\n        const { AM } = StoreListenersRoots;\n        return () => {\n            AM.forEach((rootsSet, store) => {\n                const T = Array.from(rootsSet);\n                lazySetEach(store.AQ, listener => {\n                    listener(T);\n                });\n            });\n        };\n    },\n    V: (store, root) => {\n        const T = StoreListenersRoots.AM.get(store) || new Set();\n        T.add(root);\n        StoreListenersRoots.AM.set(store, T);\n        StoreScheduler.F();\n    },\n    AR: (current, parent, key) => {\n        if (!parent.AO) {\n            const root = current?.store || untrack(() => parent.store[key]);\n            StoreListenersRoots.V(parent, root);\n        }\n        else {\n            const traversed = new Set();\n            const traverse = (AI) => {\n                if (traversed.has(AI))\n                    return;\n                traversed.add(AI);\n                lazySetEach(AI.AO, parent => {\n                    if (!parent.AO) {\n                        StoreListenersRoots.V(parent, AI.store);\n                    }\n                    traverse(parent);\n                });\n            };\n            traverse(current || parent);\n        }\n    },\n    reset: () => {\n        StoreListenersRoots.AM = new Map();\n    }\n};\nconst StoreScheduler = {\n    /* VARIABLES */\n    AK: false,\n    /* API */\n    N: () => {\n        const flushRegular = StoreListenersRegular.AN();\n        const flushRoots = StoreListenersRoots.AN();\n        StoreScheduler.reset();\n        flushRegular();\n        flushRoots();\n    },\n    AS: () => {\n        if (isBatching()) {\n            if (BATCH) {\n                BATCH.finally(StoreScheduler.AS);\n            }\n            else {\n                setTimeout(StoreScheduler.AS, 0);\n            }\n        }\n        else {\n            StoreScheduler.N();\n        }\n    },\n    reset: () => {\n        StoreScheduler.AK = false;\n        StoreListenersRegular.reset();\n        StoreListenersRoots.reset();\n    },\n    F: () => {\n        if (StoreScheduler.AK)\n            return;\n        StoreScheduler.AK = true;\n        queueMicrotask(StoreScheduler.AS);\n    }\n};\n/* CONSTANTS */\nconst NODES = new WeakMap();\nconst SPECIAL_SYMBOLS = new Set([SYMBOL_STORE, SYMBOL_STORE_KEYS, SYMBOL_STORE_OBSERVABLE, SYMBOL_STORE_TARGET, SYMBOL_STORE_VALUES]);\nconst UNREACTIVE_KEYS = new Set(['__proto__', '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'prototype', 'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toSource', 'toString', 'valueOf']);\nconst STORE_TRAPS = {\n    /* API */\n    get: (target, key) => {\n        if (SPECIAL_SYMBOLS.has(key)) {\n            if (key === SYMBOL_STORE)\n                return true;\n            if (key === SYMBOL_STORE_TARGET)\n                return target;\n            if (key === SYMBOL_STORE_KEYS) {\n                if (isListenable()) {\n                    const AI = getNodeExisting(target);\n                    AI.keys || (AI.keys = getNodeKeys(AI));\n                    AI.keys.listen();\n                    AI.keys.observable.get();\n                }\n                return;\n            }\n            if (key === SYMBOL_STORE_VALUES) {\n                if (isListenable()) {\n                    const AI = getNodeExisting(target);\n                    AI.values || (AI.values = getNodeValues(AI));\n                    AI.values.listen();\n                    AI.values.observable.get();\n                }\n                return;\n            }\n            if (key === SYMBOL_STORE_OBSERVABLE) {\n                return (key) => {\n                    key = (typeof key === 'number') ? String(key) : key;\n                    const AI = getNodeExisting(target);\n                    const getter = AI.AT?.get(key);\n                    if (getter)\n                        return getter.bind(AI.store);\n                    AI.AJ || (AI.AJ = new StoreMap());\n                    const value = target[key];\n                    const property = AI.AJ.get(key) || AI.AJ.AH(key, getNodeProperty(AI, key, value));\n                    const options = AI.equals ? { equals: AI.equals } : undefined;\n                    property.observable || (property.observable = getNodeObservable(AI, value, options));\n                    const observable = readable(property.observable);\n                    return observable;\n                };\n            }\n        }\n        if (UNREACTIVE_KEYS.has(key))\n            return target[key];\n        const AI = getNodeExisting(target);\n        const getter = AI.AT?.get(key);\n        const value = getter || target[key];\n        AI.AJ || (AI.AJ = new StoreMap());\n        const listenable = isListenable();\n        const proxiable = isProxiable(value);\n        const property = listenable || proxiable ? AI.AJ.get(key) || AI.AJ.AH(key, getNodeProperty(AI, key, value)) : undefined;\n        if (property?.AI) {\n            lazySetAdd(property.AI, 'AO', AI);\n        }\n        if (property && listenable) {\n            const options = AI.equals ? { equals: AI.equals } : undefined;\n            property.listen();\n            property.observable || (property.observable = getNodeObservable(AI, value, options));\n            property.observable.get();\n        }\n        if (getter) {\n            return getter.call(AI.store);\n        }\n        else {\n            if (typeof value === 'function' && value === Array.prototype[key]) {\n                return function () {\n                    return value.apply(AI.store, arguments);\n                };\n            }\n            return property?.AI?.store || value;\n        }\n    },\n    set: (target, key, value) => {\n        value = getTarget(value);\n        const AI = getNodeExisting(target);\n        const setter = AI.AU?.get(key);\n        if (setter) {\n            setter.call(AI.store, value);\n        }\n        else {\n            const targetIsArray = isArray(target);\n            const valuePrev = target[key];\n            const hadProperty = !!valuePrev || (key in target);\n            const equals = AI.equals || is;\n            if (hadProperty && equals(value, valuePrev) && (key !== 'length' || !targetIsArray))\n                return true; // Array.prototype.length is special, it gets updated AA this trap is called, we need to special-case it...\n            const lengthPrev = targetIsArray && target['length'];\n            target[key] = value;\n            const lengthNext = targetIsArray && target['length'];\n            if (targetIsArray && key !== 'length' && lengthPrev !== lengthNext) { // Inferring updating the length property, since it happens implicitly\n                AI.AJ?.get('length')?.observable?.set(lengthNext);\n            }\n            AI.values?.observable.set(0);\n            if (!hadProperty) {\n                AI.keys?.observable.set(0);\n                AI.has?.get(key)?.observable.set(true);\n            }\n            const property = AI.AJ?.get(key);\n            if (property?.AI) {\n                lazySetDelete(property.AI, 'AO', AI);\n            }\n            if (property) {\n                property.observable?.set(value);\n                property.AI = isProxiable(value) ? NODES.get(value) || getNode(value, key, AI) : undefined;\n            }\n            if (property?.AI) {\n                lazySetAdd(property.AI, 'AO', AI);\n            }\n            if (StoreListenersRoots.AK) {\n                StoreListenersRoots.AR(property?.AI, AI, key);\n            }\n            if (StoreListenersRegular.AK) {\n                StoreListenersRegular.V(AI);\n            }\n            if (targetIsArray && key === 'length') { // Inferring deleting keys, since it happens implicitly\n                const lengthPrev = Number(valuePrev);\n                const lengthNext = Number(value);\n                for (let i = lengthNext; i < lengthPrev; i++) {\n                    if (i in target)\n                        continue;\n                    STORE_TRAPS.deleteProperty(target, `${i}`, true);\n                }\n            }\n        }\n        return true;\n    },\n    deleteProperty: (target, key, _force) => {\n        const hasProperty = (key in target);\n        if (!_force && !hasProperty)\n            return true;\n        const deleted = Reflect.deleteProperty(target, key);\n        if (!deleted)\n            return false;\n        const AI = getNodeExisting(target);\n        AI.AT?.delete(key);\n        AI.AU?.delete(key);\n        AI.keys?.observable.set(0);\n        AI.values?.observable.set(0);\n        AI.has?.get(key)?.observable.set(false);\n        const property = AI.AJ?.get(key);\n        if (StoreListenersRoots.AK) {\n            StoreListenersRoots.AR(property?.AI, AI, key);\n        }\n        if (property?.AI) {\n            lazySetDelete(property.AI, 'AO', AI);\n        }\n        if (property) {\n            property.observable?.set(undefined);\n            property.AI = undefined;\n        }\n        if (StoreListenersRegular.AK) {\n            StoreListenersRegular.V(AI);\n        }\n        return true;\n    },\n    defineProperty: (target, key, descriptor) => {\n        const AI = getNodeExisting(target);\n        const equals = AI.equals || is;\n        const hadProperty = (key in target);\n        const descriptorPrev = Reflect.getOwnPropertyDescriptor(target, key);\n        if ('value' in descriptor && isStore(descriptor.value)) {\n            descriptor = { ...descriptor, value: getTarget(descriptor.value) };\n        }\n        if (descriptorPrev && isEqualDescriptor(descriptorPrev, descriptor, equals))\n            return true;\n        const defined = Reflect.defineProperty(target, key, descriptor);\n        if (!defined)\n            return false;\n        if (!descriptor.get) {\n            AI.AT?.delete(key);\n        }\n        else if (descriptor.get) {\n            AI.AT || (AI.AT = new StoreMap());\n            AI.AT.set(key, descriptor.get);\n        }\n        if (!descriptor.set) {\n            AI.AU?.delete(key);\n        }\n        else if (descriptor.set) {\n            AI.AU || (AI.AU = new StoreMap());\n            AI.AU.set(key, descriptor.set);\n        }\n        if (hadProperty !== !!descriptor.enumerable) {\n            AI.keys?.observable.set(0);\n        }\n        AI.has?.get(key)?.observable.set(true);\n        const property = AI.AJ?.get(key);\n        if (StoreListenersRoots.AK) {\n            StoreListenersRoots.AR(property?.AI, AI, key);\n        }\n        if (property?.AI) {\n            lazySetDelete(property.AI, 'AO', AI);\n        }\n        if (property) {\n            if ('get' in descriptor) {\n                property.observable?.set(descriptor.get);\n                property.AI = undefined;\n            }\n            else {\n                const value = descriptor.value;\n                property.observable?.set(value);\n                property.AI = isProxiable(value) ? NODES.get(value) || getNode(value, key, AI) : undefined;\n            }\n        }\n        if (property?.AI) {\n            lazySetAdd(property.AI, 'AO', AI);\n        }\n        if (StoreListenersRoots.AK) {\n            StoreListenersRoots.AR(property?.AI, AI, key);\n        }\n        if (StoreListenersRegular.AK) {\n            StoreListenersRegular.V(AI);\n        }\n        return true;\n    },\n    has: (target, key) => {\n        if (key === SYMBOL_STORE)\n            return true;\n        if (key === SYMBOL_STORE_TARGET)\n            return true;\n        const value = (key in target);\n        if (isListenable()) {\n            const AI = getNodeExisting(target);\n            AI.has || (AI.has = new StoreMap());\n            const has = AI.has.get(key) || AI.has.AH(key, getNodeHas(AI, key, value));\n            has.listen();\n            has.observable.get();\n        }\n        return value;\n    },\n    ownKeys: (target) => {\n        const keys = Reflect.ownKeys(target);\n        if (isListenable()) {\n            const AI = getNodeExisting(target);\n            AI.keys || (AI.keys = getNodeKeys(AI));\n            AI.keys.listen();\n            AI.keys.observable.get();\n        }\n        return keys;\n    }\n};\nconst STORE_UNTRACK_TRAPS = {\n    /* API */\n    has: (target, key) => {\n        if (key === SYMBOL_STORE_UNTRACKED)\n            return true;\n        return (key in target);\n    }\n};\n/* HELPERS */\nconst getNode = (value, key, parent, equals) => {\n    if (isStore(value))\n        return getNodeExisting(getTarget(value));\n    const store = isFrozenLike(value, key, parent) ? value : new Proxy(value, STORE_TRAPS);\n    const gettersAndSetters = getGettersAndSetters(value);\n    const AI = { AO: parent, store };\n    if (gettersAndSetters) {\n        const { AT, AU } = gettersAndSetters;\n        if (AT)\n            AI.AT = AT;\n        if (AU)\n            AI.AU = AU;\n    }\n    if (equals === false) {\n        AI.equals = nope;\n    }\n    else if (equals) {\n        AI.equals = equals;\n    }\n    else if (parent?.equals) {\n        AI.equals = parent.equals;\n    }\n    NODES.set(value, AI);\n    return AI;\n};\nconst getNodeExisting = (value) => {\n    const AI = NODES.get(value);\n    if (!AI)\n        throw new Error('Impossible');\n    return AI;\n};\nconst getNodeFromStore = (store) => {\n    return getNodeExisting(getTarget(store));\n};\nconst getNodeKeys = (AI) => {\n    const observable = getNodeObservable(AI, 0, { equals: false });\n    const keys = new StoreKeys(AI, observable);\n    return keys;\n};\nconst getNodeValues = (AI) => {\n    const observable = getNodeObservable(AI, 0, { equals: false });\n    const values = new StoreValues(AI, observable);\n    return values;\n};\nconst getNodeHas = (AI, key, value) => {\n    const observable = getNodeObservable(AI, value);\n    const has = new StoreHas(AI, key, observable);\n    return has;\n};\nconst getNodeObservable = (AI, value, options) => {\n    return new ObservableClass(value, options);\n};\nconst getNodeProperty = (AI, key, value) => {\n    const observable = undefined;\n    const propertyNode = isProxiable(value) ? NODES.get(value) || getNode(value, key, AI) : undefined;\n    const property = new StoreProperty(AI, key, observable, propertyNode);\n    AI.AJ || (AI.AJ = new StoreMap());\n    AI.AJ.set(key, property);\n    return property;\n};\nconst getGettersAndSetters = (value) => {\n    if (isArray(value))\n        return;\n    let AT;\n    let AU;\n    const keys = Object.keys(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(value, key);\n        if (!descriptor)\n            continue;\n        const { get, set } = descriptor;\n        if (get) {\n            AT || (AT = new StoreMap());\n            AT.set(key, get);\n        }\n        if (set) {\n            AU || (AU = new StoreMap());\n            AU.set(key, set);\n        }\n        if (get && !set) { // This ensures that settings throws without first reading the getter, very cheaply\n            AU || (AU = new StoreMap());\n            AU.set(key, throwNoSetterError);\n        }\n    }\n    if (!AT && !AU)\n        return;\n    return { AT, AU };\n};\nconst getStore = (value, options) => {\n    if (isStore(value))\n        return value;\n    const AI = NODES.get(value) || getNode(value, undefined, undefined, options?.equals);\n    return AI.store;\n};\nconst getTarget = (value) => {\n    if (isStore(value))\n        return value[SYMBOL_STORE_TARGET];\n    return value;\n};\nconst getUntracked = (value) => {\n    if (!isObject(value))\n        return value;\n    if (isUntracked(value))\n        return value;\n    return new Proxy(value, STORE_UNTRACK_TRAPS);\n};\nconst isEqualDescriptor = (a, b, equals) => {\n    return (!!a.configurable === !!b.configurable && !!a.enumerable === !!b.enumerable && !!a.writable === !!b.writable && equals(a.value, b.value) && a.get === b.get && a.set === b.set);\n};\nconst isFrozenLike = (value, key, parent) => {\n    if (Object.isFrozen(value))\n        return true;\n    if (!parent || key === undefined)\n        return false;\n    const target = store.unwrap(parent.store);\n    const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n    if (descriptor?.configurable || descriptor?.writable)\n        return false;\n    return true;\n};\nconst isListenable = () => {\n    return !!OBSERVER;\n};\nconst isProxiable = (value) => {\n    if (value === null || typeof value !== 'object')\n        return false;\n    if (SYMBOL_STORE in value)\n        return true;\n    if (SYMBOL_STORE_UNTRACKED in value)\n        return false;\n    if (isArray(value))\n        return true;\n    const prototype = Object.getPrototypeOf(value);\n    if (prototype === null)\n        return true;\n    return (Object.getPrototypeOf(prototype) === null);\n};\nconst isUntracked = (value) => {\n    if (value === null || typeof value !== 'object')\n        return false;\n    return (SYMBOL_STORE_UNTRACKED in value);\n};\nconst throwNoSetterError = () => {\n    throw new TypeError('Cannot set property value of #<Object> which has only a getter');\n};\n/* MAIN */\n//TODO: Maybe have the \"on\" method trigger immediately too like \"$.on\", or maybe the other way around, which seems more flexible\n//TODO: Explore converting target values back to numbers (the Proxy always receives strings) whenever possible, to save memory\n//TODO: Implement \"_onRoots\" better, perhaps provding string paths instead, which should be more powerful\nconst store = (value, options) => {\n    if (!isObject(value))\n        return value;\n    if (isUntracked(value))\n        return value;\n    return getStore(value, options);\n};\n/* UTILITIES */\nstore.on = (target, listener) => {\n    /* VARIABLES */\n    const targets = isStore(target) ? [target] : castArray(target);\n    const selectors = targets.filter(isFunction);\n    const AM = targets.filter(isStore).map(getNodeFromStore);\n    /* ON */\n    StoreListenersRegular.AK += 1;\n    const disposers = selectors.map(selector => {\n        let inited = false;\n        return effect(() => {\n            if (inited) {\n                StoreListenersRegular.AL.add(listener);\n                StoreScheduler.F();\n            }\n            inited = true;\n            selector();\n        }, { suspense: false, sync: true });\n    });\n    AM.forEach(AI => {\n        lazySetAdd(AI, 'AP', listener);\n    });\n    /* OFF */\n    return () => {\n        StoreListenersRegular.AK -= 1;\n        disposers.forEach(disposer => {\n            disposer();\n        });\n        AM.forEach(AI => {\n            lazySetDelete(AI, 'AP', listener);\n        });\n    };\n};\nstore._onRoots = (target, listener) => {\n    if (!isStore(target))\n        return noop;\n    const AI = getNodeFromStore(target);\n    if (AI.AO)\n        throw new Error('Only top-level stores are supported');\n    /* ON */\n    StoreListenersRoots.AK += 1;\n    lazySetAdd(AI, 'AQ', listener);\n    /* OFF */\n    return () => {\n        StoreListenersRoots.AK -= 1;\n        lazySetDelete(AI, 'AQ', listener);\n    };\n};\nstore.reconcile = (() => {\n    //TODO: Support AT, AU and symbols (symbols could be supported with Reflect.ownKeys, but that's like 2x slower)\n    const getType = (value) => {\n        if (isArray(value))\n            return 1;\n        if (isProxiable(value))\n            return 2;\n        return 0;\n    };\n    const reconcileOuter = (prev, next) => {\n        const uprev = getTarget(prev);\n        const unext = getTarget(next);\n        reconcileInner(prev, next);\n        const prevType = getType(uprev);\n        const nextType = getType(unext);\n        if (prevType === 1 || nextType === 1) {\n            prev.length = next.length;\n        }\n        return prev;\n    };\n    const reconcileInner = (prev, next) => {\n        const uprev = getTarget(prev);\n        const unext = getTarget(next);\n        const prevKeys = Object.keys(uprev);\n        const nextKeys = Object.keys(unext);\n        for (let i = 0, l = nextKeys.length; i < l; i++) {\n            const key = nextKeys[i];\n            const prevValue = uprev[key];\n            const nextValue = unext[key];\n            if (!is(prevValue, nextValue)) {\n                const prevType = getType(prevValue);\n                const nextType = getType(nextValue);\n                if (prevType && prevType === nextType) {\n                    reconcileInner(prev[key], nextValue);\n                    if (prevType === 1) {\n                        prev[key].length = nextValue.length;\n                    }\n                }\n                else {\n                    prev[key] = nextValue;\n                }\n            }\n            else if (prevValue === undefined && !(key in uprev)) {\n                prev[key] = undefined;\n            }\n        }\n        for (let i = 0, l = prevKeys.length; i < l; i++) {\n            const key = prevKeys[i];\n            if (!(key in unext)) {\n                delete prev[key];\n            }\n        }\n        return prev;\n    };\n    const reconcile = (prev, next) => {\n        return untrack(() => {\n            return reconcileOuter(prev, next);\n        });\n    };\n    return reconcile;\n})();\nstore.untrack = (value) => {\n    return getUntracked(value);\n};\nstore.unwrap = (value) => {\n    return getTarget(value);\n};\n/* EXPORT */\nexport default store;\n","/* IMPORT */\nimport { OBSERVABLE_FALSE } from '../constants.js';\nimport { OWNER } from '../context.js';\nimport { readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\n/* MAIN */\nconst suspended = () => {\n    const suspense = OWNER.get(SYMBOL_SUSPENSE);\n    if (!suspense)\n        return OBSERVABLE_FALSE;\n    const observable = (suspense.observable || (suspense.observable = new Observable(!!suspense.suspended)));\n    return readable(observable);\n};\n/* EXPORT */\nexport default suspended;\n","/* IMPORT */\nimport Scheduler from '../objects/scheduler.async.js';\n/* MAIN */\nconst tick = () => {\n    Scheduler.N();\n};\n/* EXPORT */\nexport default tick;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport memo from './memo.js';\nimport $ from './observable.js';\nimport resolve from './resolve.js';\n/* MAIN */\nconst tryCatch = (value, fn) => {\n    const observable = $();\n    return memo(() => {\n        const error = observable();\n        if (error) {\n            const reset = () => observable(undefined);\n            const options = { error, reset };\n            return resolve(fn(options));\n        }\n        else {\n            OWNER.S = observable;\n            return resolve(value);\n        }\n    });\n};\n/* EXPORT */\nexport default tryCatch;\n","/* IMPORT */\nimport untrack from './untrack.js';\nimport { SYMBOL_UNTRACKED } from '../symbols.js';\nimport { isFunction } from '../utils.js';\nfunction untracked(fn) {\n    const untracked = isFunction(fn) ? (...args) => untrack(() => fn(...args)) : () => fn;\n    untracked[SYMBOL_UNTRACKED] = true;\n    return untracked;\n}\n/* EXPORT */\nexport default untracked;\n","/* IMPORT */\nimport { OBSERVER, OWNER } from '../context.js';\n/* MAIN */\nconst _with = () => {\n    const owner = OWNER;\n    const observer = OBSERVER;\n    return (fn) => {\n        return owner.E(() => fn(), owner, observer);\n    };\n};\n/* EXPORT */\nexport default _with;\n","/* IMPORT */\nimport batch from './batch.js';\nimport boolean from './boolean.js';\nimport cleanup from './cleanup.js';\nimport context from './context.js';\nimport disposed from './disposed.js';\nimport effect from './effect.js';\nimport _for from './for.js';\nimport get from './get.js';\nimport _if from './if.js';\nimport isBatching from './is_batching.js';\nimport isObservable from './is_observable.js';\nimport isStore from './is_store.js';\nimport memo from './memo.js';\nimport observable from './observable.js';\nimport owner from './owner.js';\nimport readonly from './readonly.js';\nimport resolve from './resolve.js';\nimport root from './root.js';\nimport selector from './selector.js';\nimport store from './store.js';\nimport suspended from './suspended.js';\nimport suspense from './suspense.js';\nimport _switch from './switch.js';\nimport ternary from './ternary.js';\nimport tick from './tick.js';\nimport tryCatch from './try_catch.js';\nimport untrack from './untrack.js';\nimport untracked from './untracked.js';\nimport _with from './with.js';\nimport { writable } from '../objects/callable.js';\nimport ObservableClass from '../objects/observable.js';\nfunction $(value, options) {\n    return writable(new ObservableClass(value, options));\n}\n/* UTILITIES */\n$.batch = batch;\n$.boolean = boolean;\n$.cleanup = cleanup;\n$.context = context;\n$.disposed = disposed;\n$.effect = effect;\n$.for = _for;\n$.get = get;\n$.if = _if;\n$.isBatching = isBatching;\n$.isObservable = isObservable;\n$.isStore = isStore;\n$.memo = memo;\n$.observable = observable;\n$.owner = owner;\n$.readonly = readonly;\n$.resolve = resolve;\n$.root = root;\n$.selector = selector;\n$.store = store;\n$.suspended = suspended;\n$.suspense = suspense;\n$.switch = _switch;\n$.ternary = ternary;\n$.tick = tick;\n$.tryCatch = tryCatch;\n$.untrack = untrack;\n$.untracked = untracked;\n$.with = _with;\n/* EXPORT */\nexport default $;\n","import $oby, { untrack, cleanup, owner, } from 'oby';\nimport { createReactivityAdapter } from 'signaldb';\nconst obyReactivityAdapter = createReactivityAdapter({\n    create: () => {\n        const dep = $oby(0);\n        return {\n            depend: () => {\n                dep();\n            },\n            notify: () => {\n                dep(untrack(() => dep() + 1));\n            },\n        };\n    },\n    isInScope: () => !!owner(),\n    onDispose: (callback) => {\n        cleanup(callback);\n    },\n});\nexport default obyReactivityAdapter;\n"],"names":["SYMBOL_CACHED","SYMBOL_OBSERVABLE","SYMBOL_OBSERVABLE_BOOLEAN","SYMBOL_OBSERVABLE_FROZEN","SYMBOL_OBSERVABLE_READABLE","SYMBOL_OBSERVABLE_WRITABLE","SYMBOL_STORE","SYMBOL_STORE_KEYS","SYMBOL_STORE_OBSERVABLE","SYMBOL_STORE_TARGET","SYMBOL_STORE_VALUES","SYMBOL_STORE_UNTRACKED","SYMBOL_SUSPENSE","SYMBOL_UNCACHED","SYMBOL_UNTRACKED","SYMBOL_UNTRACKED_UNWRAPPED","castArray","value","isArray","castError","error","is","isEqual","a","b","i","l","valueA","valueB","isFunction","isObject","isSymbol","noop","nope","frozenFunction","readableFunction","writableFunction","fn","frozen","readable","writable","DIRTY_NO","DIRTY_MAYBE_NO","DIRTY_MAYBE_YES","DIRTY_YES","OBSERVABLE_FALSE","OBSERVABLE_TRUE","UNAVAILABLE","UNINITIALIZED","lazyArrayEach","arr","lazyArrayEachRight","lazyArrayPush","obj","key","lazySetAdd","set","s","lazySetDelete","lazySetEach","onCleanup","cleanup","onDispose","owner","Owner","silent","S","_a","deep","symbol","observer","ownerPrev","OWNER","observerPrev","OBSERVER","setOwner","setObserver","SuperRoot","BATCH","SUPER_OWNER","setBatch","M","resolve","batch","r","isObservableBoolean","isObservableFrozen","_b","isUntracked","Scheduler$2","queue","SchedulerSync","Scheduler","Observable","options","parent","equals","J","ObservablesArray","A","P","observablesLength","observable","index","ObservablesSet","sizePrev","sizeNext","Observer","Memo","G","statusPrev","memo","boolean","Context","context","symbolOrContext","disposed","effect","Scheduler$1","Effect","suspense","resolved","Root","V","Q","fnWithDispose","DUMMY_INDEX","CacheKeyed","A5","A6","mapped","values","AB","results","resultsCached","resultsUncached","A8","cached","MappedRoot","isObservable","get","getFunction","Suspense","force","suspendedPrev","suspendedNext","notifyOwner","notifyObserver","notifySuspense","notifyRoot","root","when","condition","CacheUnkeyed","pooled","poolable","cacheNext","AC","leftovers","outer","isDuplicate","_c","_d","_e","_f","$index","suspended","$value","isStore","untrack","_for","fallback","isUnkeyed","map","next","prev","array","warmup","match","_switch","ternary","valueTrue","valueFalse","_if","isBatching","SchedulerAsync","ObservableClass","isSuperRoot","isRoot","isSuspense","isComputation","isObservableWritable","target","readonly","DisposableMap","SelectedObservable","selector","AG","sourceValue","AF","selectedValue","valuePrev","valueNext","selected","StoreMap","StoreCleanable","StoreKeys","StoreValues","StoreHas","StoreProperty","AI","StoreListenersRegular","AL","AM","traversed","traverse","listener","StoreScheduler","StoreListenersRoots","rootsSet","store","T","current","flushRegular","flushRoots","NODES","SPECIAL_SYMBOLS","UNREACTIVE_KEYS","STORE_TRAPS","isListenable","getNodeExisting","getNodeKeys","getNodeValues","getter","property","getNodeProperty","getNodeObservable","listenable","proxiable","isProxiable","getTarget","setter","targetIsArray","hadProperty","lengthPrev","lengthNext","_h","_g","_i","_j","getNode","_force","hasProperty","descriptor","descriptorPrev","isEqualDescriptor","has","getNodeHas","keys","STORE_UNTRACK_TRAPS","isFrozenLike","gettersAndSetters","getGettersAndSetters","AT","AU","getNodeFromStore","propertyNode","throwNoSetterError","getStore","getUntracked","prototype","targets","selectors","disposers","inited","disposer","getType","reconcileOuter","uprev","unext","reconcileInner","prevType","nextType","prevKeys","nextKeys","prevValue","nextValue","tick","tryCatch","$","untracked","args","_with","obyReactivityAdapter","createReactivityAdapter","dep","$oby","callback"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]}