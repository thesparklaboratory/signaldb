{"version":3,"file":"index.umd.js","sources":["../../../node_modules/oby/dist/symbols.js","../../../node_modules/oby/dist/utils.js","../../../node_modules/oby/dist/objects/callable.js","../../../node_modules/oby/dist/constants.js","../../../node_modules/oby/dist/lazy.js","../../../node_modules/oby/dist/objects/owner.js","../../../node_modules/oby/dist/objects/superroot.js","../../../node_modules/oby/dist/context.js","../../../node_modules/oby/dist/methods/batch.js","../../../node_modules/oby/dist/methods/is_observable_boolean.js","../../../node_modules/oby/dist/methods/is_observable_frozen.js","../../../node_modules/oby/dist/methods/is_untracked.js","../../../node_modules/oby/dist/objects/scheduler.sync.js","../../../node_modules/oby/dist/objects/observable.js","../../../node_modules/oby/dist/objects/observables.js","../../../node_modules/oby/dist/objects/observer.js","../../../node_modules/oby/dist/objects/memo.js","../../../node_modules/oby/dist/methods/memo.js","../../../node_modules/oby/dist/methods/boolean.js","../../../node_modules/oby/dist/methods/cleanup.js","../../../node_modules/oby/dist/objects/context.js","../../../node_modules/oby/dist/methods/context.js","../../../node_modules/oby/dist/methods/disposed.js","../../../node_modules/oby/dist/objects/scheduler.async.js","../../../node_modules/oby/dist/objects/effect.js","../../../node_modules/oby/dist/methods/effect.js","../../../node_modules/oby/dist/methods/resolve.js","../../../node_modules/oby/dist/objects/root.js","../../../node_modules/oby/dist/methods/for.cache.keyed.js","../../../node_modules/oby/dist/methods/is_observable.js","../../../node_modules/oby/dist/methods/get.js","../../../node_modules/oby/dist/objects/suspense.js","../../../node_modules/oby/dist/methods/suspense.js","../../../node_modules/oby/dist/methods/for.cache.unkeyed.js","../../../node_modules/oby/dist/methods/is_store.js","../../../node_modules/oby/dist/methods/untrack.js","../../../node_modules/oby/dist/methods/for.js","../../../node_modules/oby/dist/methods/warmup.js","../../../node_modules/oby/dist/methods/switch.js","../../../node_modules/oby/dist/methods/ternary.js","../../../node_modules/oby/dist/methods/if.js","../../../node_modules/oby/dist/methods/is_batching.js","../../../node_modules/oby/dist/methods/observable.js","../../../node_modules/oby/dist/methods/owner.js","../../../node_modules/oby/dist/methods/is_observable_writable.js","../../../node_modules/oby/dist/methods/target.js","../../../node_modules/oby/dist/methods/readonly.js","../../../node_modules/oby/dist/methods/root.js","../../../node_modules/oby/dist/methods/selector.js","../../../node_modules/oby/dist/methods/store.js","../../../node_modules/oby/dist/methods/suspended.js","../../../node_modules/oby/dist/methods/tick.js","../../../node_modules/oby/dist/methods/try_catch.js","../../../node_modules/oby/dist/methods/untracked.js","../../../node_modules/oby/dist/methods/with.js","../../../node_modules/oby/dist/methods/$.js","../src/index.ts"],"sourcesContent":["/* MAIN */\nconst SYMBOL_CACHED = Symbol('Cached');\nconst SYMBOL_OBSERVABLE = Symbol('Observable');\nconst SYMBOL_OBSERVABLE_BOOLEAN = Symbol('Observable.Boolean');\nconst SYMBOL_OBSERVABLE_FROZEN = Symbol('Observable.Frozen');\nconst SYMBOL_OBSERVABLE_READABLE = Symbol('Observable.Readable');\nconst SYMBOL_OBSERVABLE_WRITABLE = Symbol('Observable.Writable');\nconst SYMBOL_STORE = Symbol('Store');\nconst SYMBOL_STORE_KEYS = Symbol('Store.Keys');\nconst SYMBOL_STORE_OBSERVABLE = Symbol('Store.Observable');\nconst SYMBOL_STORE_TARGET = Symbol('Store.Target');\nconst SYMBOL_STORE_VALUES = Symbol('Store.Values');\nconst SYMBOL_STORE_UNTRACKED = Symbol('Store.Untracked');\nconst SYMBOL_SUSPENSE = Symbol('Suspense');\nconst SYMBOL_UNCACHED = Symbol('Uncached');\nconst SYMBOL_UNTRACKED = Symbol('Untracked');\nconst SYMBOL_UNTRACKED_UNWRAPPED = Symbol('Untracked.Unwrapped');\n/* EXPORT */\nexport { SYMBOL_CACHED, SYMBOL_OBSERVABLE, SYMBOL_OBSERVABLE_BOOLEAN, SYMBOL_OBSERVABLE_FROZEN, SYMBOL_OBSERVABLE_READABLE, SYMBOL_OBSERVABLE_WRITABLE, SYMBOL_STORE, SYMBOL_STORE_KEYS, SYMBOL_STORE_OBSERVABLE, SYMBOL_STORE_TARGET, SYMBOL_STORE_VALUES, SYMBOL_STORE_UNTRACKED, SYMBOL_SUSPENSE, SYMBOL_UNCACHED, SYMBOL_UNTRACKED, SYMBOL_UNTRACKED_UNWRAPPED };\n","/* MAIN */\nconst castArray = (value) => {\n    return isArray(value) ? value : [value];\n};\nconst castError = (error) => {\n    if (error instanceof Error)\n        return error;\n    if (typeof error === 'string')\n        return new Error(error);\n    return new Error('Unknown error');\n};\nconst { is } = Object;\nconst { isArray } = Array;\nconst isEqual = (a, b) => {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n        const valueA = a[i];\n        const valueB = b[i];\n        if (!is(valueA, valueB))\n            return false;\n    }\n    return true;\n};\nconst isFunction = (value) => {\n    return typeof value === 'function';\n};\nconst isObject = (value) => {\n    return (value !== null) && (typeof value === 'object');\n};\nconst isSymbol = (value) => {\n    return typeof value === 'symbol';\n};\nconst noop = () => {\n    return;\n};\nconst nope = () => {\n    return false;\n};\n/* EXPORT */\nexport { castArray, castError, is, isArray, isEqual, isFunction, isObject, isSymbol, noop, nope };\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE, SYMBOL_OBSERVABLE_FROZEN, SYMBOL_OBSERVABLE_READABLE, SYMBOL_OBSERVABLE_WRITABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN - FUNCTIONS */\nfunction frozenFunction() {\n    if (arguments.length) {\n        throw new Error('A readonly Observable can not be updated');\n    }\n    else {\n        return this;\n    }\n}\nfunction readableFunction() {\n    if (arguments.length) {\n        throw new Error('A readonly Observable can not be updated');\n    }\n    else {\n        return this.get();\n    }\n}\nfunction writableFunction(fn) {\n    if (arguments.length) {\n        if (isFunction(fn)) {\n            return this.C(fn);\n        }\n        else {\n            return this.set(fn); //TSC\n        }\n    }\n    else {\n        return this.get();\n    }\n}\n/* MAIN - GENERATORS */\nconst frozen = (value) => {\n    const fn = frozenFunction.bind(value); //TSC\n    fn[SYMBOL_OBSERVABLE] = true;\n    fn[SYMBOL_OBSERVABLE_FROZEN] = true;\n    return fn;\n};\nconst readable = (value) => {\n    //TODO: Make a frozen one instead if disposed\n    const fn = readableFunction.bind(value); //TSC\n    fn[SYMBOL_OBSERVABLE] = true;\n    fn[SYMBOL_OBSERVABLE_READABLE] = value;\n    return fn;\n};\nconst writable = (value) => {\n    const fn = writableFunction.bind(value); //TSC\n    fn[SYMBOL_OBSERVABLE] = true;\n    fn[SYMBOL_OBSERVABLE_WRITABLE] = value;\n    return fn;\n};\n/* EXPORT */\nexport { frozen, readable, writable };\n","/* IMPORT */\nimport { frozen } from './objects/callable.js';\n/* MAIN */\nconst DIRTY_NO = 0; // The observer is not dirty, for sure\nconst DIRTY_MAYBE_NO = 1; // The observer is not dirty, possibly\nconst DIRTY_MAYBE_YES = 2; // The observer is dirty, possibly\nconst DIRTY_YES = 3; // The observer is dirty, for sure\nconst OBSERVABLE_FALSE = frozen(false);\nconst OBSERVABLE_TRUE = frozen(true);\nconst UNAVAILABLE = new Proxy({}, new Proxy({}, { get() { throw new Error('Unavailable value'); } })); //TSC\nconst UNINITIALIZED = function () { }; //TSC\n/* EXPORT */\nexport { DIRTY_NO, DIRTY_MAYBE_NO, DIRTY_MAYBE_YES, DIRTY_YES };\nexport { OBSERVABLE_FALSE, OBSERVABLE_TRUE };\nexport { UNAVAILABLE, UNINITIALIZED };\n","/* IMPORT */\n/* MAIN */\nconst lazyArrayEach = (arr, fn) => {\n    if (arr instanceof Array) {\n        for (let i = 0, l = arr.length; i < l; i++) {\n            fn(arr[i]);\n        }\n    }\n    else if (arr) {\n        fn(arr);\n    }\n};\nconst lazyArrayEachRight = (arr, fn) => {\n    if (arr instanceof Array) {\n        for (let i = arr.length - 1; i >= 0; i--) {\n            fn(arr[i]);\n        }\n    }\n    else if (arr) {\n        fn(arr);\n    }\n};\nconst lazyArrayPush = (obj, key, value) => {\n    const arr = obj[key];\n    if (arr instanceof Array) {\n        arr.push(value);\n    }\n    else if (arr) {\n        obj[key] = [arr, value];\n    }\n    else {\n        obj[key] = value;\n    }\n};\nconst lazySetAdd = (obj, key, value) => {\n    const set = obj[key];\n    if (set instanceof Set) {\n        set.add(value);\n    }\n    else if (set) {\n        if (value !== set) {\n            const s = new Set();\n            s.add(set);\n            s.add(value);\n            obj[key] = s;\n        }\n    }\n    else {\n        obj[key] = value;\n    }\n};\nconst lazySetDelete = (obj, key, value) => {\n    const set = obj[key];\n    if (set instanceof Set) {\n        set.delete(value);\n    }\n    else if (set === value) {\n        obj[key] = undefined;\n    }\n};\nconst lazySetEach = (set, fn) => {\n    if (set instanceof Set) {\n        for (const value of set) {\n            fn(value);\n        }\n    }\n    else if (set) {\n        fn(set);\n    }\n};\n/* EXPORT */\nexport { lazyArrayEach, lazyArrayEachRight, lazyArrayPush };\nexport { lazySetAdd, lazySetDelete, lazySetEach };\n","/* IMPORT */\nimport { UNAVAILABLE } from '../constants.js';\nimport { OBSERVER, OWNER, setObserver, setOwner } from '../context.js';\nimport { lazyArrayEachRight } from '../lazy.js';\nimport { castError } from '../utils.js';\n/* HELPERS */\nconst onCleanup = (cleanup) => cleanup.call(cleanup);\nconst onDispose = (owner) => owner.Q(true);\n/* MAIN */\n//TODO: Throw when registering stuff O disposing, maybe\nclass Owner {\n    constructor() {\n        /* VARIABLES */\n        this.disposed = false;\n        this.B = undefined;\n        this.S = undefined;\n        this.D = undefined;\n        this.K = undefined;\n        this.T = undefined;\n        this.U = undefined;\n    }\n    /* API */\n    catch(error, silent) {\n        const { S } = this;\n        if (S) {\n            S(error); //TODO: This assumes that the error handler won't throw immediately, which we know, but Owner shouldn't know\n            return true;\n        }\n        else {\n            if (this.parent?.catch(error, true))\n                return true;\n            if (silent)\n                return false;\n            // console.error ( error.stack ); // <-- Log \"error.stack\" to better understand where the error happened\n            throw error;\n        }\n    }\n    Q(deep) {\n        lazyArrayEachRight(this.D, onDispose);\n        lazyArrayEachRight(this.K, onDispose);\n        lazyArrayEachRight(this.U, onDispose);\n        lazyArrayEachRight(this.B, onCleanup);\n        this.B = undefined;\n        this.disposed = deep;\n        this.S = undefined;\n        this.K = undefined;\n        this.U = undefined;\n    }\n    get(symbol) {\n        return this.context?.[symbol];\n    }\n    E(fn, owner, observer) {\n        const ownerPrev = OWNER;\n        const observerPrev = OBSERVER;\n        setOwner(owner);\n        setObserver(observer);\n        try {\n            return fn();\n        }\n        catch (error) {\n            this.catch(castError(error), false); // Bubbling the error up\n            return UNAVAILABLE; // Returning a value that is the least likely to cause bugs\n        }\n        finally {\n            setOwner(ownerPrev);\n            setObserver(observerPrev);\n        }\n    }\n}\n/* EXPORT */\nexport default Owner;\n","/* IMPORT */\nimport Owner from './owner.js';\n/* MAIN */\nclass SuperRoot extends Owner {\n    constructor() {\n        /* VARIABLES */\n        super(...arguments);\n        this.context = {};\n    }\n}\n/* EXPORT */\nexport default SuperRoot;\n","/* IMPORT */\nimport SuperRoot from './objects/superroot.js';\n/* MAIN - READ */\n// This module relies on live-binding of exported variables to avoid a bunch of property accesses\nlet BATCH;\nlet SUPER_OWNER = new SuperRoot();\nlet OBSERVER;\nlet OWNER = SUPER_OWNER;\n/* MAIN - WRITE */\n// Unfortunately live-bounded exports can't just be overridden, so we need these functions\nconst setBatch = (value) => BATCH = value;\nconst setObserver = (value) => OBSERVER = value;\nconst setOwner = (value) => OWNER = value;\n/* EXPORT */\nexport { BATCH, OBSERVER, OWNER, SUPER_OWNER };\nexport { setBatch, setObserver, setOwner };\n","/* IMPORT */\nimport { setBatch } from '../context.js';\nimport { noop } from '../utils.js';\n/* HELPERS */\nlet M = 0;\nlet resolve = noop;\n/* MAIN */\nconst batch = async (fn) => {\n    if (!M) {\n        setBatch(new Promise(r => resolve = r));\n    }\n    try {\n        M += 1;\n        return await fn();\n    }\n    finally {\n        M -= 1;\n        if (!M) {\n            setBatch(undefined);\n            resolve();\n        }\n    }\n};\n/* MAIN */\nexport default batch;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE_BOOLEAN } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservableBoolean = (value) => {\n    return isFunction(value) && (SYMBOL_OBSERVABLE_BOOLEAN in value);\n};\n/* EXPORT */\nexport default isObservableBoolean;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE_FROZEN, SYMBOL_OBSERVABLE_READABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservableFrozen = (value) => {\n    return isFunction(value) && ((SYMBOL_OBSERVABLE_FROZEN in value) || !!value[SYMBOL_OBSERVABLE_READABLE]?.parent?.disposed);\n};\n/* EXPORT */\nexport default isObservableFrozen;\n","/* IMPORT */\nimport { SYMBOL_UNTRACKED, SYMBOL_UNTRACKED_UNWRAPPED } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isUntracked = (value) => {\n    return isFunction(value) && ((SYMBOL_UNTRACKED in value) || (SYMBOL_UNTRACKED_UNWRAPPED in value));\n};\n/* EXPORT */\nexport default isUntracked;\n","/* IMPORT */\n/* MAIN */\n// This ensures that there's only one flushing of the queue happening at the same time\nclass Scheduler {\n    constructor() {\n        /* VARIABLES */\n        this.A1 = [];\n        this.M = 0;\n        this.A2 = false;\n        /* QUEING API */\n        this.N = () => {\n            if (this.A2)\n                return;\n            if (this.M)\n                return;\n            if (!this.A1.length)\n                return;\n            try {\n                this.A2 = true;\n                while (true) {\n                    const queue = this.A1;\n                    if (!queue.length)\n                        break;\n                    this.A1 = [];\n                    for (let i = 0, l = queue.length; i < l; i++) {\n                        queue[i].C();\n                    }\n                }\n            }\n            finally {\n                this.A2 = false;\n            }\n        };\n        this.E = (fn) => {\n            this.M += 1;\n            fn();\n            this.M -= 1;\n            this.N();\n        };\n        /* SCHEDULING API */\n        this.F = (observer) => {\n            this.A1.push(observer);\n        };\n    }\n}\n/* EXPORT */\nexport default new Scheduler();\n","/* IMPORT */\nimport { DIRTY_MAYBE_NO, DIRTY_YES, UNINITIALIZED } from '../constants.js';\nimport { OBSERVER } from '../context.js';\nimport Scheduler from './scheduler.sync.js';\nimport { is, nope } from '../utils.js';\n/* MAIN */\nclass Observable {\n    /* CONSTRUCTOR */\n    constructor(value, options, parent) {\n        this.K = new Set();\n        this.value = value;\n        if (parent) {\n            this.parent = parent;\n        }\n        if (options?.equals !== undefined) {\n            this.equals = options.equals || nope;\n        }\n    }\n    /* API */\n    get() {\n        if (!this.parent?.disposed) {\n            this.parent?.C();\n            OBSERVER?.A.L(this);\n        }\n        return this.value;\n    }\n    set(value) {\n        const equals = this.equals || is;\n        const fresh = (this.value === UNINITIALIZED) || !equals(value, this.value);\n        if (!fresh)\n            return value;\n        this.value = value;\n        Scheduler.M += 1;\n        this.I(DIRTY_YES);\n        Scheduler.M -= 1;\n        Scheduler.N();\n        return value;\n    }\n    I(J) {\n        for (const observer of this.K) {\n            if (observer.J !== DIRTY_MAYBE_NO || observer.A.has(this)) { // Maybe this is a potential future dependency we haven't re-read yet\n                if (observer.sync) {\n                    observer.J = Math.max(observer.J, J);\n                    Scheduler.F(observer);\n                }\n                else {\n                    observer.I(J);\n                }\n            }\n        }\n    }\n    C(fn) {\n        const value = fn(this.value);\n        return this.set(value);\n    }\n}\n/* EXPORT */\nexport default Observable;\n","/* IMPORT */\n/* MAIN */\n// Dedicated data structures for managing A efficiently\n// We use an array if the list is small enough, as that's faster than a Set, and only switch to Sets O that\nclass ObservablesArray {\n    /* CONSTRUCTOR */\n    constructor(observer) {\n        this.observer = observer;\n        this.A = [];\n        this.P = 0;\n    }\n    /* API */\n    Q(deep) {\n        if (deep) {\n            const { observer, A } = this;\n            for (let i = 0; i < A.length; i++) {\n                A[i].K.delete(observer);\n            }\n        }\n        this.P = 0;\n    }\n    R() {\n        const { observer, A, P } = this;\n        const observablesLength = A.length;\n        if (P < observablesLength) {\n            for (let i = P; i < observablesLength; i++) {\n                A[i].K.delete(observer);\n            }\n            A.length = P;\n        }\n    }\n    empty() {\n        return !this.A.length;\n    }\n    has(observable) {\n        const index = this.A.indexOf(observable);\n        return index >= 0 && index < this.P;\n    }\n    L(observable) {\n        const { observer, A, P } = this;\n        const observablesLength = A.length;\n        if (observablesLength > 0) {\n            if (A[P] === observable) {\n                this.P += 1;\n                return;\n            }\n            const index = A.indexOf(observable);\n            if (index >= 0 && index < P) {\n                return;\n            }\n            if (P < observablesLength - 1) {\n                this.R();\n            }\n            else if (P === observablesLength - 1) {\n                A[P].K.delete(observer);\n            }\n        }\n        observable.K.add(observer);\n        A[this.P++] = observable;\n        if (P === 128) { // Switching to a Set, as indexOf checks may get artbirarily expensive otherwise\n            observer.A = new ObservablesSet(observer, A);\n        }\n    }\n    C() {\n        const { A } = this;\n        for (let i = 0, l = A.length; i < l; i++) {\n            A[i].parent?.C();\n        }\n    }\n}\nclass ObservablesSet {\n    /* CONSTRUCTOR */\n    constructor(observer, A) {\n        this.observer = observer;\n        this.A = new Set(A);\n    }\n    /* API */\n    Q(deep) {\n        for (const observable of this.A) {\n            observable.K.delete(this.observer);\n        }\n    }\n    R() {\n        return;\n    }\n    empty() {\n        return !this.A.size;\n    }\n    has(observable) {\n        return this.A.has(observable);\n    }\n    L(observable) {\n        const { observer, A } = this;\n        const sizePrev = A.size;\n        observable.K.add(observer);\n        const sizeNext = A.size;\n        if (sizePrev === sizeNext)\n            return; // Cheaper than Set.has+Set.add\n        A.add(observable);\n    }\n    C() {\n        for (const observable of this.A) {\n            observable.parent?.C();\n        }\n    }\n}\n/* EXPORT */\nexport { ObservablesArray, ObservablesSet };\n","/* IMPORT */\nimport { DIRTY_NO, DIRTY_MAYBE_NO, DIRTY_MAYBE_YES, DIRTY_YES } from '../constants.js';\nimport { OWNER, SUPER_OWNER } from '../context.js';\nimport { lazyArrayPush } from '../lazy.js';\nimport { ObservablesArray, ObservablesSet } from './observables.js';\nimport Owner from './owner.js';\n/* MAIN */\nclass Observer extends Owner {\n    /* CONSTRUCTOR */\n    constructor() {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = OWNER.context;\n        this.J = DIRTY_YES;\n        this.A = new ObservablesArray(this);\n        if (OWNER !== SUPER_OWNER) {\n            lazyArrayPush(this.parent, 'K', this);\n        }\n    }\n    /* API */\n    Q(deep) {\n        this.A.Q(deep);\n        super.Q(deep);\n    }\n    H(fn) {\n        this.Q(false);\n        this.J = DIRTY_MAYBE_NO; // Resetting the trip flag, we didn't re-execute just yet\n        try {\n            return this.E(fn, this, this);\n        }\n        finally {\n            this.A.R();\n        }\n    }\n    run() {\n        throw new Error('Abstract method');\n    }\n    I(J) {\n        throw new Error('Abstract method');\n    }\n    C() {\n        if (this.disposed)\n            return; // Disposed, it shouldn't be updated again\n        if (this.J === DIRTY_MAYBE_YES) { // Maybe we are dirty, let's check with our A, to be sure\n            this.A.C();\n        }\n        if (this.J === DIRTY_YES) { // We are dirty, let's H\n            this.J = DIRTY_MAYBE_NO; // Trip flag, to be able to tell if we caused ourselves to be dirty again\n            this.run();\n            if (this.J === DIRTY_MAYBE_NO) { // Not dirty anymore\n                this.J = DIRTY_NO;\n            }\n            else { // Maybe we are still dirty, let's check again\n                this.C();\n            }\n        }\n        else { // Not dirty\n            this.J = DIRTY_NO;\n        }\n    }\n}\n/* EXPORT */\nexport default Observer;\n","/* IMPORT */\nimport { DIRTY_MAYBE_YES, UNAVAILABLE, UNINITIALIZED } from '../constants.js';\nimport Observable from './observable.js';\nimport Observer from './observer.js';\n/* MAIN */\nclass Memo extends Observer {\n    /* CONSTRUCTOR */\n    constructor(fn, options) {\n        super();\n        this.fn = fn;\n        this.observable = new Observable(UNINITIALIZED, options, this);\n        if (options?.sync === true) {\n            this.sync = true;\n            this.C();\n        }\n    }\n    /* API */\n    run() {\n        const G = super.H(this.fn);\n        if (!this.disposed && this.A.empty()) {\n            this.disposed = true;\n        }\n        if (G !== UNAVAILABLE) {\n            this.observable.set(G);\n        }\n    }\n    I(J) {\n        const statusPrev = this.J;\n        if (statusPrev >= J)\n            return;\n        this.J = J;\n        if (statusPrev === DIRTY_MAYBE_YES)\n            return;\n        this.observable.I(DIRTY_MAYBE_YES);\n    }\n}\n/* EXPORT */\nexport default Memo;\n","/* IMPORT */\nimport isObservableFrozen from './is_observable_frozen.js';\nimport isUntracked from './is_untracked.js';\nimport { frozen, readable } from '../objects/callable.js';\nimport Memo from '../objects/memo.js';\n/* MAIN */\nconst memo = (fn, options) => {\n    if (isObservableFrozen(fn)) {\n        return fn;\n    }\n    else if (isUntracked(fn)) {\n        return frozen(fn());\n    }\n    else {\n        const memo = new Memo(fn, options);\n        const observable = readable(memo.observable);\n        return observable;\n    }\n};\n/* EXPORT */\nexport default memo;\n","/* IMPORT */\nimport isObservableBoolean from './is_observable_boolean.js';\nimport isObservableFrozen from './is_observable_frozen.js';\nimport isUntracked from './is_untracked.js';\nimport memo from './memo.js';\nimport { SYMBOL_OBSERVABLE_BOOLEAN } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst boolean = (value) => {\n    if (isFunction(value)) {\n        if (isObservableFrozen(value) || isUntracked(value)) {\n            return !!value();\n        }\n        else if (isObservableBoolean(value)) {\n            return value;\n        }\n        else {\n            const boolean = memo(() => !!value());\n            boolean[SYMBOL_OBSERVABLE_BOOLEAN] = true;\n            return boolean;\n        }\n    }\n    else {\n        return !!value;\n    }\n};\n/* EXPORT */\nexport default boolean;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazyArrayPush } from '../lazy.js';\n/* MAIN */\nconst cleanup = (fn) => {\n    lazyArrayPush(OWNER, 'B', fn);\n};\n/* EXPORT */\nexport default cleanup;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazyArrayPush } from '../lazy.js';\nimport Owner from './owner.js';\n/* MAIN */\nclass Context extends Owner {\n    /* CONSTRUCTOR */\n    constructor(context) {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = { ...OWNER.context, ...context };\n        lazyArrayPush(this.parent, 'D', this);\n    }\n    /* API */\n    E(fn) {\n        return super.E(fn, this, undefined);\n    }\n}\n/* EXPORT */\nexport default Context;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport Context from '../objects/context.js';\nimport { isSymbol, noop } from '../utils.js';\nfunction context(symbolOrContext, fn) {\n    if (isSymbol(symbolOrContext)) {\n        return OWNER.context[symbolOrContext];\n    }\n    else {\n        return new Context(symbolOrContext).E(fn || noop);\n    }\n}\n/* EXPORT */\nexport default context;\n","/* IMPORT */\nimport cleanup from './cleanup.js';\nimport { readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\n/* MAIN */\nconst disposed = () => {\n    const observable = new Observable(false);\n    const A4 = () => observable.set(true);\n    cleanup(A4);\n    return readable(observable);\n};\n/* EXPORT */\nexport default disposed;\n","/* IMPORT */\nimport { BATCH } from '../context.js';\n/* MAIN */\n// Using 2 microtasks to give a chance to things using 1 microtask (like refs in Voby) to run first\nclass Scheduler {\n    constructor() {\n        /* VARIABLES */\n        this.A1 = [];\n        this.A2 = false;\n        this.A3 = false;\n        /* QUEUING API */\n        this.N = () => {\n            if (this.A2)\n                return;\n            if (!this.A1.length)\n                return;\n            try {\n                this.A2 = true;\n                while (true) {\n                    const queue = this.A1;\n                    if (!queue.length)\n                        break;\n                    this.A1 = [];\n                    for (let i = 0, l = queue.length; i < l; i++) {\n                        queue[i].C();\n                    }\n                }\n            }\n            finally {\n                this.A2 = false;\n            }\n        };\n        this.queue = () => {\n            if (this.A3)\n                return;\n            this.A3 = true;\n            this.resolve();\n        };\n        this.resolve = () => {\n            queueMicrotask(() => {\n                queueMicrotask(() => {\n                    if (BATCH) {\n                        BATCH.finally(this.resolve);\n                    }\n                    else {\n                        this.A3 = false;\n                        this.N();\n                    }\n                });\n            });\n        };\n        /* SCHEDULING API */\n        this.F = (effect) => {\n            this.A1.push(effect);\n            this.queue();\n        };\n    }\n}\n/* EXPORT */\nexport default new Scheduler();\n","/* IMPORT */\nimport { lazyArrayPush } from '../lazy.js';\nimport Observer from './observer.js';\nimport Scheduler from './scheduler.async.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nclass Effect extends Observer {\n    /* CONSTRUCTOR */\n    constructor(fn, options) {\n        super();\n        this.fn = fn;\n        if (options?.suspense !== false) {\n            const suspense = this.get(SYMBOL_SUSPENSE);\n            if (suspense) {\n                this.suspense = suspense;\n            }\n        }\n        if (options?.sync === true) {\n            this.sync = true;\n        }\n        if (options?.sync === 'init') {\n            this.init = true;\n            this.C();\n        }\n        else {\n            this.F();\n        }\n    }\n    /* API */\n    run() {\n        const G = super.H(this.fn);\n        if (isFunction(G)) {\n            lazyArrayPush(this, 'B', G);\n        }\n    }\n    F() {\n        if (this.suspense?.suspended)\n            return;\n        if (this.sync) {\n            this.C();\n        }\n        else {\n            Scheduler.F(this);\n        }\n    }\n    I(J) {\n        const statusPrev = this.J;\n        if (statusPrev >= J)\n            return;\n        this.J = J;\n        if (!this.sync || (statusPrev !== 2 && statusPrev !== 3)) { // It isn't currently executing, so let's F it\n            this.F();\n        }\n    }\n    C() {\n        if (this.suspense?.suspended)\n            return;\n        super.C();\n    }\n}\n/* EXPORT */\nexport default Effect;\n","/* IMPORT */\nimport Effect from '../objects/effect.js';\n/* MAIN */\nconst effect = (fn, options) => {\n    const effect = new Effect(fn, options);\n    const Q = () => effect.Q(true);\n    return Q;\n};\n/* EXPORT */\nexport default effect;\n","/* IMPORT */\nimport memo from './memo.js';\nimport { frozen } from '../objects/callable.js';\nimport { SYMBOL_OBSERVABLE, SYMBOL_UNTRACKED, SYMBOL_UNTRACKED_UNWRAPPED } from '../symbols.js';\nimport { isFunction } from '../utils.js';\nfunction resolve(value) {\n    if (isFunction(value)) {\n        if (SYMBOL_UNTRACKED_UNWRAPPED in value) {\n            return resolve(value());\n        }\n        else if (SYMBOL_UNTRACKED in value) {\n            return frozen(resolve(value()));\n        }\n        else if (SYMBOL_OBSERVABLE in value) {\n            return value;\n        }\n        else {\n            return memo(() => resolve(value()));\n        }\n    }\n    if (value instanceof Array) {\n        const resolved = new Array(value.length);\n        for (let i = 0, l = resolved.length; i < l; i++) {\n            resolved[i] = resolve(value[i]);\n        }\n        return resolved;\n    }\n    else {\n        return value;\n    }\n}\n/* EXPORT */\nexport default resolve;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazySetAdd, lazySetDelete } from '../lazy.js';\nimport Owner from './owner.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\n/* MAIN */\nclass Root extends Owner {\n    /* CONSTRUCTOR */\n    constructor(V) {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = OWNER.context;\n        if (V) {\n            const suspense = this.get(SYMBOL_SUSPENSE);\n            if (suspense) {\n                this.A0 = true;\n                lazySetAdd(this.parent, 'T', this);\n            }\n        }\n    }\n    /* API */\n    Q(deep) {\n        if (this.A0) {\n            lazySetDelete(this.parent, 'T', this);\n        }\n        super.Q(deep);\n    }\n    E(fn) {\n        const Q = () => this.Q(true);\n        const fnWithDispose = () => fn(Q);\n        return super.E(fnWithDispose, this, undefined);\n    }\n}\n/* EXPORT */\nexport default Root;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazySetAdd, lazySetDelete } from '../lazy.js';\nimport cleanup from './cleanup.js';\nimport resolve from './resolve.js';\nimport { frozen, readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport Root from '../objects/root.js';\nimport { SYMBOL_CACHED, SYMBOL_SUSPENSE, SYMBOL_UNCACHED } from '../symbols.js';\n/* HELPERS */\nconst DUMMY_INDEX = frozen(-1);\nclass MappedRoot extends Root {\n}\n/* MAIN */\nclass CacheKeyed {\n    /* CONSTRUCTOR */\n    constructor(fn) {\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.suspense = OWNER.get(SYMBOL_SUSPENSE);\n        this.A5 = new Map();\n        this.A6 = false; // The A6 is flipped with each iteration, the T that don't have the updated one are disposed, it's like a cheap M basically\n        this.A7 = 0; // Number of previous items\n        this.A8 = 0; // Number of previous items that got reused\n        this.A9 = 0; // Number of next items\n        /* API */\n        this.cleanup = () => {\n            if (!this.A7)\n                return; // There was nothing AA, no need to cleanup\n            if (this.A7 === this.A8)\n                return; // All the previous items were reused, no need to cleanup\n            const { A5, A6 } = this;\n            if (!A5.size)\n                return; // Nothing to Q of\n            if (this.A9) { // Regular cleanup\n                A5.forEach((mapped, value) => {\n                    if (mapped.A6 === A6)\n                        return;\n                    mapped.Q(true);\n                    A5.delete(value);\n                });\n            }\n            else { // There is nothing O, disposing quickly\n                this.A5.forEach(mapped => {\n                    mapped.Q(true);\n                });\n                this.A5 = new Map();\n            }\n        };\n        this.Q = () => {\n            if (this.suspense) {\n                lazySetDelete(this.parent, 'T', this.T);\n            }\n            this.A7 = this.A5.size;\n            this.A8 = 0;\n            this.A9 = 0;\n            this.cleanup();\n        };\n        this.AA = () => {\n            this.A6 = !this.A6;\n            this.A8 = 0;\n            this.A9 = 0;\n        };\n        this.O = (values) => {\n            this.A9 = values.length;\n            this.cleanup();\n            this.A7 = this.A9;\n            this.A8 = 0;\n        };\n        this.map = (values) => {\n            this.AA();\n            const { A5, A6, fn, AB } = this;\n            const results = new Array(values.length);\n            let resultsCached = true; // Whether all results are cached, if so this enables an optimization\n            let resultsUncached = true; // Whether all results are anew, if so this enables an optimization in Voby\n            let A8 = 0;\n            for (let i = 0, l = values.length; i < l; i++) {\n                const value = values[i];\n                const cached = A5.get(value);\n                if (cached && cached.A6 !== A6) {\n                    resultsUncached = false;\n                    A8 += 1;\n                    cached.A6 = A6;\n                    cached.index?.set(i);\n                    results[i] = cached.G; //TSC\n                }\n                else {\n                    resultsCached = false;\n                    const mapped = new MappedRoot(false);\n                    if (cached) {\n                        cleanup(() => mapped.Q(true));\n                    }\n                    mapped.E(() => {\n                        let index = DUMMY_INDEX;\n                        if (AB) {\n                            mapped.index = new Observable(i);\n                            index = readable(mapped.index);\n                        }\n                        const G = results[i] = resolve(fn(value, index));\n                        mapped.A6 = A6;\n                        mapped.G = G;\n                        if (!cached) {\n                            A5.set(value, mapped);\n                        }\n                    });\n                }\n            }\n            this.A8 = A8;\n            this.O(values);\n            if (resultsCached) {\n                results[SYMBOL_CACHED] = true;\n            }\n            if (resultsUncached) {\n                results[SYMBOL_UNCACHED] = true;\n            }\n            return results;\n        };\n        this.T = () => {\n            return Array.from(this.A5.values());\n        };\n        this.fn = fn;\n        this.AB = (fn.length > 1);\n        if (this.suspense) {\n            lazySetAdd(this.parent, 'T', this.T);\n        }\n    }\n}\n/* EXPORT */\nexport default CacheKeyed;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservable = (value) => {\n    return isFunction(value) && (SYMBOL_OBSERVABLE in value);\n};\n/* EXPORT */\nexport default isObservable;\n","/* IMPORT */\nimport isObservable from './is_observable.js';\nimport { isFunction } from '../utils.js';\nfunction get(value, getFunction = true) {\n    const is = getFunction ? isFunction : isObservable;\n    if (is(value)) {\n        return value();\n    }\n    else {\n        return value;\n    }\n}\n/* EXPORT */\nexport default get;\n","/* IMPORT */\nimport { DIRTY_MAYBE_YES, DIRTY_YES } from '../constants.js';\nimport { OWNER } from '../context.js';\nimport { lazyArrayEach, lazyArrayPush, lazySetEach } from '../lazy.js';\nimport Effect from './effect.js';\nimport Owner from './owner.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nclass Suspense extends Owner {\n    /* CONSTRUCTOR */\n    constructor() {\n        super();\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.context = { ...OWNER.context, [SYMBOL_SUSPENSE]: this };\n        lazyArrayPush(this.parent, 'U', this);\n        this.suspended = (OWNER.get(SYMBOL_SUSPENSE)?.suspended || 0);\n    }\n    /* API */\n    A4(force) {\n        if (!this.suspended && !force)\n            return; // Already suspended, this can happen at instantion time\n        const suspendedPrev = this.suspended;\n        const suspendedNext = suspendedPrev + (force ? 1 : -1);\n        this.suspended = suspendedNext;\n        if (!!suspendedPrev === !!suspendedNext)\n            return; // Same state, nothing to pause or resume\n        /* NOTIFYING OBSERVERS, ROOTS AND SUSPENSES */\n        this.observable?.set(!!suspendedNext);\n        const notifyOwner = (owner) => {\n            lazyArrayEach(owner.D, notifyOwner);\n            lazyArrayEach(owner.K, notifyObserver);\n            lazyArrayEach(owner.U, notifySuspense);\n            lazySetEach(owner.T, notifyRoot);\n        };\n        const notifyObserver = (observer) => {\n            if (observer instanceof Effect) {\n                if (observer.J === DIRTY_MAYBE_YES || observer.J === DIRTY_YES) {\n                    if (observer.init) {\n                        observer.C();\n                    }\n                    else {\n                        observer.F();\n                    }\n                }\n            }\n            notifyOwner(observer);\n        };\n        const notifyRoot = (root) => {\n            if (isFunction(root)) {\n                root().forEach(notifyOwner);\n            }\n            else {\n                notifyOwner(root);\n            }\n        };\n        const notifySuspense = (suspense) => {\n            suspense.A4(force);\n        };\n        notifyOwner(this);\n    }\n    E(fn) {\n        return super.E(fn, this, undefined);\n    }\n}\n/* EXPORT */\nexport default Suspense;\n","/* IMPORT */\nimport boolean from './boolean.js';\nimport effect from './effect.js';\nimport get from './get.js';\nimport Suspense from '../objects/suspense.js';\n/* MAIN */\nconst suspense = (when, fn) => {\n    const suspense = new Suspense();\n    const condition = boolean(when);\n    const A4 = () => suspense.A4(get(condition));\n    effect(A4, { sync: true });\n    return suspense.E(fn);\n};\n/* EXPORT */\nexport default suspense;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport { lazySetAdd, lazySetDelete } from '../lazy.js';\nimport cleanup from './cleanup.js';\nimport get from './get.js';\nimport memo from './memo.js';\nimport resolve from './resolve.js';\nimport suspense from './suspense.js';\nimport { frozen, readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport Root from '../objects/root.js';\nimport { SYMBOL_CACHED, SYMBOL_SUSPENSE, SYMBOL_UNCACHED } from '../symbols.js';\n/* HELPERS */\nconst DUMMY_INDEX = frozen(-1);\nclass MappedRoot extends Root {\n}\n/* MAIN */\n//TODO: Optimize this more\nclass CacheUnkeyed {\n    /* CONSTRUCTOR */\n    constructor(fn, pooled) {\n        /* VARIABLES */\n        this.parent = OWNER;\n        this.suspense = OWNER.get(SYMBOL_SUSPENSE);\n        this.A5 = new Map();\n        this.AC = [];\n        this.AD = 0;\n        /* API */\n        this.cleanup = () => {\n            let pooled = 0;\n            let poolable = Math.max(0, this.pooled ? this.AD - this.AC.length : 0);\n            this.A5.forEach(mapped => {\n                if (poolable > 0 && pooled++ < poolable) {\n                    mapped.suspended?.set(true);\n                    this.AC.push(mapped);\n                }\n                else {\n                    mapped.Q(true);\n                }\n            });\n        };\n        this.Q = () => {\n            if (this.suspense) {\n                lazySetDelete(this.parent, 'T', this.T);\n            }\n            this.A5.forEach(mapped => {\n                mapped.Q(true);\n            });\n            this.AC.forEach(mapped => {\n                mapped.Q(true);\n            });\n        };\n        this.map = (values) => {\n            const { A5, fn, AB } = this;\n            const cacheNext = new Map();\n            const results = new Array(values.length);\n            const AC = this.AC;\n            const pooled = this.pooled;\n            let resultsCached = true; // Whether all results are cached, if so this enables an optimization\n            let resultsUncached = true; // Whether all results are anew, if so this enables an optimization in Voby\n            let leftovers = [];\n            if (A5.size) {\n                for (let i = 0, l = values.length; i < l; i++) {\n                    const value = values[i];\n                    const cached = A5.get(value);\n                    if (cached) {\n                        resultsUncached = false;\n                        A5.delete(value);\n                        cacheNext.set(value, cached);\n                        cached.index?.set(i);\n                        results[i] = cached.G; //TSC\n                    }\n                    else {\n                        leftovers.push(i);\n                    }\n                }\n            }\n            else {\n                leftovers = new Array(results.length);\n            }\n            outer: for (let i = 0, l = leftovers.length; i < l; i++) {\n                const index = leftovers[i] || i;\n                const value = values[index];\n                const isDuplicate = cacheNext.has(value);\n                if (!isDuplicate) {\n                    for (const [key, mapped] of A5.entries()) {\n                        A5.delete(key);\n                        cacheNext.set(value, mapped);\n                        mapped.index?.set(index);\n                        mapped.value?.set(value);\n                        results[index] = mapped.G; //TSC\n                        continue outer;\n                    }\n                }\n                resultsCached = false;\n                let mapped;\n                if (pooled && AC.length) {\n                    mapped = AC.pop(); //TSC\n                    mapped.index?.set(index);\n                    mapped.value?.set(value);\n                    mapped.suspended?.set(false);\n                    results[index] = mapped.G; //TSC\n                }\n                else {\n                    mapped = new MappedRoot(false);\n                    mapped.E(() => {\n                        let $index = DUMMY_INDEX;\n                        if (AB) {\n                            mapped.index = new Observable(index);\n                            $index = readable(mapped.index);\n                        }\n                        const observable = mapped.value = new Observable(value);\n                        const suspended = pooled ? new Observable(false) : undefined;\n                        const $value = memo(() => get(observable.get())); //TSC\n                        const G = results[index] = suspended ? suspense(() => suspended.get(), () => resolve(fn($value, $index))) : resolve(fn($value, $index));\n                        mapped.value = observable;\n                        mapped.G = G;\n                        mapped.suspended = suspended;\n                    });\n                }\n                if (isDuplicate) { // Expensive, not reusable\n                    cleanup(() => mapped.Q(true));\n                }\n                else { // Cheap, reusable\n                    cacheNext.set(value, mapped);\n                }\n            }\n            this.AD = Math.max(this.AD, results.length);\n            this.cleanup();\n            this.A5 = cacheNext;\n            if (resultsCached) {\n                results[SYMBOL_CACHED] = true;\n            }\n            if (resultsUncached) {\n                results[SYMBOL_UNCACHED] = true;\n            }\n            return results;\n        };\n        this.T = () => {\n            return [...this.A5.values(), ...this.AC.values()];\n        };\n        this.fn = fn;\n        this.AB = (fn.length > 1);\n        this.pooled = pooled;\n        if (this.suspense) {\n            lazySetAdd(this.parent, 'T', this.T);\n        }\n    }\n}\n/* EXPORT */\nexport default CacheUnkeyed;\n","/* IMPORT */\nimport { SYMBOL_STORE } from '../symbols.js';\nimport { isObject } from '../utils.js';\n/* MAIN */\nconst isStore = (value) => {\n    return isObject(value) && (SYMBOL_STORE in value);\n};\n/* EXPORT */\nexport default isStore;\n","/* IMPORT */\nimport { OBSERVER, setObserver } from '../context.js';\nimport { isFunction } from '../utils.js';\nfunction untrack(fn) {\n    if (isFunction(fn)) {\n        const observerPrev = OBSERVER;\n        if (observerPrev) {\n            try {\n                setObserver(undefined);\n                return fn();\n            }\n            finally {\n                setObserver(observerPrev);\n            }\n        }\n        else {\n            return fn();\n        }\n    }\n    else {\n        return fn;\n    }\n}\n/* EXPORT */\nexport default untrack;\n","/* IMPORT */\nimport cleanup from './cleanup.js';\nimport CacheKeyed from './for.cache.keyed.js';\nimport CacheUnkeyed from './for.cache.unkeyed.js';\nimport get from './get.js';\nimport isObservable from './is_observable.js';\nimport isStore from './is_store.js';\nimport memo from './memo.js';\nimport resolve from './resolve.js';\nimport untrack from './untrack.js';\nimport { frozen } from '../objects/callable.js';\nimport { SYMBOL_CACHED, SYMBOL_STORE_VALUES } from '../symbols.js';\nimport { isArray, isEqual } from '../utils.js';\nfunction _for(values, fn, fallback = [], options) {\n    if (isArray(values) && !isStore(values)) { // Fast path for plain arrays\n        const isUnkeyed = !!options?.unkeyed;\n        return frozen(untrack(() => {\n            if (values.length) {\n                return values.map((value, index) => {\n                    return resolve(fn(isUnkeyed && !isObservable(value) ? frozen(value) : value, index));\n                });\n            }\n            else {\n                return resolve(fallback);\n            }\n        }));\n    }\n    else { // Regular path\n        const { Q, map } = options?.unkeyed ? new CacheUnkeyed(fn, !!options.pooled) : new CacheKeyed(fn); //TSC\n        cleanup(Q);\n        const value = memo(() => {\n            return get(values) ?? [];\n        }, {\n            equals: (next, prev) => {\n                return !!next && !!prev && !next.length && !prev.length && !isStore(next) && !isStore(prev);\n            }\n        });\n        return memo(() => {\n            const array = value();\n            if (isStore(array)) {\n                array[SYMBOL_STORE_VALUES];\n            }\n            return untrack(() => {\n                const results = map(array);\n                return results?.length ? results : resolve(fallback);\n            });\n        }, {\n            equals: (next, prev) => {\n                return isArray(next) && !!next[SYMBOL_CACHED] && isArray(prev) && isEqual(next, prev);\n            }\n        });\n    }\n}\n/* EXPORT */\nexport default _for;\n","/* IMPORT */\nimport untrack from './untrack.js';\n/* MAIN */\n// This function ensures an Observable contains a fresh value, mainly to try to push it into a frozen state, if possible\nconst warmup = (value) => {\n    untrack(value);\n    return value;\n};\n/* EXPORT */\nexport default warmup;\n","/* IMPORT */\nimport get from './get.js';\nimport isObservableBoolean from './is_observable_boolean.js';\nimport isObservableFrozen from './is_observable_frozen.js';\nimport isUntracked from './is_untracked.js';\nimport memo from './memo.js';\nimport resolve from './resolve.js';\nimport warmup from './warmup.js';\nimport { frozen } from '../objects/callable.js';\nimport { is, isFunction } from '../utils.js';\n/* HELPERS */\nconst match = (condition, values, fallback) => {\n    for (let i = 0, l = values.length; i < l; i++) {\n        const value = values[i];\n        if (value.length === 1)\n            return value[0];\n        if (is(value[0], condition))\n            return value[1];\n    }\n    return fallback;\n};\nfunction _switch(when, values, fallback) {\n    const isDynamic = isFunction(when) && !isObservableFrozen(when) && !isUntracked(when);\n    if (isDynamic) {\n        if (isObservableBoolean(when)) {\n            return memo(() => resolve(match(when(), values, fallback)));\n        }\n        const value = warmup(memo(() => match(when(), values, fallback)));\n        if (isObservableFrozen(value)) {\n            return frozen(resolve(value()));\n        }\n        else {\n            return memo(() => resolve(get(value)));\n        }\n    }\n    else {\n        const value = match(get(when), values, fallback);\n        return frozen(resolve(value));\n    }\n}\n/* EXPORT */\nexport default _switch;\n","/* IMPORT */\nimport boolean from './boolean.js';\nimport _switch from './switch.js';\n/* MAIN */\nconst ternary = (when, valueTrue, valueFalse) => {\n    const condition = boolean(when);\n    return _switch(condition, [[true, valueTrue], [valueFalse]]);\n};\n/* EXPORT */\nexport default ternary;\n","/* IMPORT */\nimport ternary from './ternary.js';\nfunction _if(when, valueTrue, valueFalse) {\n    return ternary(when, valueTrue, valueFalse);\n}\n/* EXPORT */\nexport default _if;\n","/* IMPORT */\nimport { BATCH } from '../context.js';\nimport SchedulerAsync from '../objects/scheduler.async.js';\nimport SchedulerSync from '../objects/scheduler.sync.js';\n/* MAIN */\nconst isBatching = () => {\n    return !!BATCH || SchedulerAsync.A3 || SchedulerAsync.A2 || SchedulerSync.A2;\n};\n/* EXPORT */\nexport default isBatching;\n","/* IMPORT */\nimport { writable } from '../objects/callable.js';\nimport ObservableClass from '../objects/observable.js';\nfunction observable(value, options) {\n    return writable(new ObservableClass(value, options));\n}\n/* EXPORT */\nexport default observable;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport Observer from '../objects/observer.js';\nimport Root from '../objects/root.js';\nimport SuperRoot from '../objects/superroot.js';\nimport Suspense from '../objects/suspense.js';\n/* MAIN */\nconst owner = () => {\n    const isSuperRoot = (OWNER instanceof SuperRoot);\n    const isRoot = (OWNER instanceof Root);\n    const isSuspense = (OWNER instanceof Suspense);\n    const isComputation = (OWNER instanceof Observer);\n    return { isSuperRoot, isRoot, isSuspense, isComputation };\n};\n/* EXPORT */\nexport default owner;\n","/* IMPORT */\nimport { SYMBOL_OBSERVABLE_WRITABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst isObservableWritable = (value) => {\n    return isFunction(value) && (SYMBOL_OBSERVABLE_WRITABLE in value);\n};\n/* EXPORT */\nexport default isObservableWritable;\n","/* IMPORT */\nimport { UNAVAILABLE } from '../constants.js';\nimport { SYMBOL_OBSERVABLE_READABLE, SYMBOL_OBSERVABLE_WRITABLE } from '../symbols.js';\nimport { isFunction } from '../utils.js';\n/* MAIN */\nconst target = (observable) => {\n    if (isFunction(observable)) {\n        return observable[SYMBOL_OBSERVABLE_READABLE] || observable[SYMBOL_OBSERVABLE_WRITABLE] || UNAVAILABLE;\n    }\n    else {\n        return observable;\n    }\n};\n/* EXPORT */\nexport default target;\n","/* IMPORT */\nimport isObservableWritable from './is_observable_writable.js';\nimport target from './target.js';\nimport { readable } from '../objects/callable.js';\n/* MAIN */\nconst readonly = (observable) => {\n    if (isObservableWritable(observable)) {\n        return readable(target(observable));\n    }\n    else {\n        return observable;\n    }\n};\n/* EXPORT */\nexport default readonly;\n","/* IMPORT */\nimport Root from '../objects/root.js';\n/* MAIN */\nconst root = (fn) => {\n    return new Root(true).E(fn);\n};\n/* EXPORT */\nexport default root;\n","/* IMPORT */\nimport { OBSERVABLE_FALSE, OBSERVABLE_TRUE } from '../constants.js';\nimport cleanup from './cleanup.js';\nimport effect from './effect.js';\nimport isObservableFrozen from './is_observable_frozen.js';\nimport memo from './memo.js';\nimport untrack from './untrack.js';\nimport warmup from './warmup.js';\nimport { readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport { is } from '../utils.js';\n/* HELPERS */\nclass DisposableMap extends Map {\n    constructor() {\n        super(...arguments);\n        this.disposed = false;\n    }\n}\nclass SelectedObservable extends Observable {\n    constructor() {\n        super(...arguments);\n        this.AE = 1;\n    }\n    /* API */\n    call() {\n        if (this.AF.disposed)\n            return;\n        this.AE -= 1;\n        if (this.AE)\n            return;\n        this.AF.delete(this.AG);\n    }\n}\n/* MAIN */\nconst selector = (AG) => {\n    /* NORMALIZING SOURCE */\n    AG = warmup(memo(AG));\n    /* FROZEN SOURCE */\n    if (isObservableFrozen(AG)) {\n        const sourceValue = untrack(AG);\n        return (value) => {\n            return (value === sourceValue) ? OBSERVABLE_TRUE : OBSERVABLE_FALSE;\n        };\n    }\n    /* SELECTEDS */\n    let AF = new DisposableMap();\n    let selectedValue = untrack(AG);\n    effect(() => {\n        const valuePrev = selectedValue;\n        const valueNext = AG();\n        if (is(valuePrev, valueNext))\n            return;\n        selectedValue = valueNext;\n        AF.get(valuePrev)?.set(false);\n        AF.get(valueNext)?.set(true);\n    }, { suspense: false, sync: true });\n    /* CLEANUP ALL */\n    const cleanupAll = () => {\n        AF.disposed = true;\n    };\n    cleanup(cleanupAll);\n    /* SELECTOR */\n    return (value) => {\n        /* INIT */\n        let selected = AF.get(value);\n        if (selected) {\n            selected.AE += 1;\n        }\n        else {\n            selected = new SelectedObservable(value === selectedValue);\n            selected.AF = AF;\n            selected.AG = value;\n            AF.set(value, selected);\n        }\n        /* CLEANUP */\n        cleanup(selected);\n        /* RETURN */\n        return readable(selected);\n    };\n};\n/* EXPORT */\nexport default selector;\n","/* IMPORT */\nimport { BATCH, OBSERVER } from '../context.js';\nimport { lazySetAdd, lazySetDelete, lazySetEach } from '../lazy.js';\nimport cleanup from './cleanup.js';\nimport effect from './effect.js';\nimport isBatching from './is_batching.js';\nimport isStore from './is_store.js';\nimport untrack from './untrack.js';\nimport { readable } from '../objects/callable.js';\nimport ObservableClass from '../objects/observable.js';\nimport { SYMBOL_STORE, SYMBOL_STORE_KEYS, SYMBOL_STORE_OBSERVABLE, SYMBOL_STORE_TARGET, SYMBOL_STORE_VALUES, SYMBOL_STORE_UNTRACKED } from '../symbols.js';\nimport { castArray, is, isArray, isFunction, isObject, noop, nope } from '../utils.js';\n/* CLASSES */\nclass StoreMap extends Map {\n    AH(key, value) {\n        super.set(key, value);\n        return value;\n    }\n}\nclass StoreCleanable {\n    constructor() {\n        this.AE = 0;\n    }\n    listen() {\n        this.AE += 1;\n        cleanup(this);\n    }\n    call() {\n        this.AE -= 1;\n        if (this.AE)\n            return;\n        this.Q();\n    }\n    Q() { }\n}\nclass StoreKeys extends StoreCleanable {\n    constructor(parent, observable) {\n        super();\n        this.parent = parent;\n        this.observable = observable;\n    }\n    Q() {\n        this.parent.keys = undefined;\n    }\n}\nclass StoreValues extends StoreCleanable {\n    constructor(parent, observable) {\n        super();\n        this.parent = parent;\n        this.observable = observable;\n    }\n    Q() {\n        this.parent.values = undefined;\n    }\n}\nclass StoreHas extends StoreCleanable {\n    constructor(parent, key, observable) {\n        super();\n        this.parent = parent;\n        this.key = key;\n        this.observable = observable;\n    }\n    Q() {\n        this.parent.has?.delete(this.key);\n    }\n}\nclass StoreProperty extends StoreCleanable {\n    constructor(parent, key, observable, AI) {\n        super();\n        this.parent = parent;\n        this.key = key;\n        this.observable = observable;\n        this.AI = AI;\n    }\n    Q() {\n        this.parent.AJ?.delete(this.key);\n    }\n}\nconst StoreListenersRegular = {\n    /* VARIABLES */\n    AK: 0,\n    AL: new Set(),\n    AM: new Set(),\n    /* API */\n    AN: () => {\n        const { AL, AM } = StoreListenersRegular;\n        const traversed = new Set();\n        const traverse = (AI) => {\n            if (traversed.has(AI))\n                return;\n            traversed.add(AI);\n            lazySetEach(AI.AO, traverse);\n            lazySetEach(AI.AP, listener => {\n                AL.add(listener);\n            });\n        };\n        AM.forEach(traverse);\n        return () => {\n            AL.forEach(listener => {\n                listener();\n            });\n        };\n    },\n    V: (AI) => {\n        StoreListenersRegular.AM.add(AI);\n        StoreScheduler.F();\n    },\n    reset: () => {\n        StoreListenersRegular.AL = new Set();\n        StoreListenersRegular.AM = new Set();\n    }\n};\nconst StoreListenersRoots = {\n    /* VARIABLES */\n    AK: 0,\n    AM: new Map(),\n    /* API */\n    AN: () => {\n        const { AM } = StoreListenersRoots;\n        return () => {\n            AM.forEach((rootsSet, store) => {\n                const T = Array.from(rootsSet);\n                lazySetEach(store.AQ, listener => {\n                    listener(T);\n                });\n            });\n        };\n    },\n    V: (store, root) => {\n        const T = StoreListenersRoots.AM.get(store) || new Set();\n        T.add(root);\n        StoreListenersRoots.AM.set(store, T);\n        StoreScheduler.F();\n    },\n    AR: (current, parent, key) => {\n        if (!parent.AO) {\n            const root = current?.store || untrack(() => parent.store[key]);\n            StoreListenersRoots.V(parent, root);\n        }\n        else {\n            const traversed = new Set();\n            const traverse = (AI) => {\n                if (traversed.has(AI))\n                    return;\n                traversed.add(AI);\n                lazySetEach(AI.AO, parent => {\n                    if (!parent.AO) {\n                        StoreListenersRoots.V(parent, AI.store);\n                    }\n                    traverse(parent);\n                });\n            };\n            traverse(current || parent);\n        }\n    },\n    reset: () => {\n        StoreListenersRoots.AM = new Map();\n    }\n};\nconst StoreScheduler = {\n    /* VARIABLES */\n    AK: false,\n    /* API */\n    N: () => {\n        const flushRegular = StoreListenersRegular.AN();\n        const flushRoots = StoreListenersRoots.AN();\n        StoreScheduler.reset();\n        flushRegular();\n        flushRoots();\n    },\n    AS: () => {\n        if (isBatching()) {\n            if (BATCH) {\n                BATCH.finally(StoreScheduler.AS);\n            }\n            else {\n                setTimeout(StoreScheduler.AS, 0);\n            }\n        }\n        else {\n            StoreScheduler.N();\n        }\n    },\n    reset: () => {\n        StoreScheduler.AK = false;\n        StoreListenersRegular.reset();\n        StoreListenersRoots.reset();\n    },\n    F: () => {\n        if (StoreScheduler.AK)\n            return;\n        StoreScheduler.AK = true;\n        queueMicrotask(StoreScheduler.AS);\n    }\n};\n/* CONSTANTS */\nconst NODES = new WeakMap();\nconst SPECIAL_SYMBOLS = new Set([SYMBOL_STORE, SYMBOL_STORE_KEYS, SYMBOL_STORE_OBSERVABLE, SYMBOL_STORE_TARGET, SYMBOL_STORE_VALUES]);\nconst UNREACTIVE_KEYS = new Set(['__proto__', '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'prototype', 'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toSource', 'toString', 'valueOf']);\nconst STORE_TRAPS = {\n    /* API */\n    get: (target, key) => {\n        if (SPECIAL_SYMBOLS.has(key)) {\n            if (key === SYMBOL_STORE)\n                return true;\n            if (key === SYMBOL_STORE_TARGET)\n                return target;\n            if (key === SYMBOL_STORE_KEYS) {\n                if (isListenable()) {\n                    const AI = getNodeExisting(target);\n                    AI.keys || (AI.keys = getNodeKeys(AI));\n                    AI.keys.listen();\n                    AI.keys.observable.get();\n                }\n                return;\n            }\n            if (key === SYMBOL_STORE_VALUES) {\n                if (isListenable()) {\n                    const AI = getNodeExisting(target);\n                    AI.values || (AI.values = getNodeValues(AI));\n                    AI.values.listen();\n                    AI.values.observable.get();\n                }\n                return;\n            }\n            if (key === SYMBOL_STORE_OBSERVABLE) {\n                return (key) => {\n                    key = (typeof key === 'number') ? String(key) : key;\n                    const AI = getNodeExisting(target);\n                    const getter = AI.AT?.get(key);\n                    if (getter)\n                        return getter.bind(AI.store);\n                    AI.AJ || (AI.AJ = new StoreMap());\n                    const value = target[key];\n                    const property = AI.AJ.get(key) || AI.AJ.AH(key, getNodeProperty(AI, key, value));\n                    const options = AI.equals ? { equals: AI.equals } : undefined;\n                    property.observable || (property.observable = getNodeObservable(AI, value, options));\n                    const observable = readable(property.observable);\n                    return observable;\n                };\n            }\n        }\n        if (UNREACTIVE_KEYS.has(key))\n            return target[key];\n        const AI = getNodeExisting(target);\n        const getter = AI.AT?.get(key);\n        const value = getter || target[key];\n        AI.AJ || (AI.AJ = new StoreMap());\n        const listenable = isListenable();\n        const proxiable = isProxiable(value);\n        const property = listenable || proxiable ? AI.AJ.get(key) || AI.AJ.AH(key, getNodeProperty(AI, key, value)) : undefined;\n        if (property?.AI) {\n            lazySetAdd(property.AI, 'AO', AI);\n        }\n        if (property && listenable) {\n            const options = AI.equals ? { equals: AI.equals } : undefined;\n            property.listen();\n            property.observable || (property.observable = getNodeObservable(AI, value, options));\n            property.observable.get();\n        }\n        if (getter) {\n            return getter.call(AI.store);\n        }\n        else {\n            if (typeof value === 'function' && value === Array.prototype[key]) {\n                return function () {\n                    return value.apply(AI.store, arguments);\n                };\n            }\n            return property?.AI?.store || value;\n        }\n    },\n    set: (target, key, value) => {\n        value = getTarget(value);\n        const AI = getNodeExisting(target);\n        const setter = AI.AU?.get(key);\n        if (setter) {\n            setter.call(AI.store, value);\n        }\n        else {\n            const targetIsArray = isArray(target);\n            const valuePrev = target[key];\n            const hadProperty = !!valuePrev || (key in target);\n            const equals = AI.equals || is;\n            if (hadProperty && equals(value, valuePrev) && (key !== 'length' || !targetIsArray))\n                return true; // Array.prototype.length is special, it gets updated AA this trap is called, we need to special-case it...\n            const lengthPrev = targetIsArray && target['length'];\n            target[key] = value;\n            const lengthNext = targetIsArray && target['length'];\n            if (targetIsArray && key !== 'length' && lengthPrev !== lengthNext) { // Inferring updating the length property, since it happens implicitly\n                AI.AJ?.get('length')?.observable?.set(lengthNext);\n            }\n            AI.values?.observable.set(0);\n            if (!hadProperty) {\n                AI.keys?.observable.set(0);\n                AI.has?.get(key)?.observable.set(true);\n            }\n            const property = AI.AJ?.get(key);\n            if (property?.AI) {\n                lazySetDelete(property.AI, 'AO', AI);\n            }\n            if (property) {\n                property.observable?.set(value);\n                property.AI = isProxiable(value) ? NODES.get(value) || getNode(value, key, AI) : undefined;\n            }\n            if (property?.AI) {\n                lazySetAdd(property.AI, 'AO', AI);\n            }\n            if (StoreListenersRoots.AK) {\n                StoreListenersRoots.AR(property?.AI, AI, key);\n            }\n            if (StoreListenersRegular.AK) {\n                StoreListenersRegular.V(AI);\n            }\n            if (targetIsArray && key === 'length') { // Inferring deleting keys, since it happens implicitly\n                const lengthPrev = Number(valuePrev);\n                const lengthNext = Number(value);\n                for (let i = lengthNext; i < lengthPrev; i++) {\n                    if (i in target)\n                        continue;\n                    STORE_TRAPS.deleteProperty(target, `${i}`, true);\n                }\n            }\n        }\n        return true;\n    },\n    deleteProperty: (target, key, _force) => {\n        const hasProperty = (key in target);\n        if (!_force && !hasProperty)\n            return true;\n        const deleted = Reflect.deleteProperty(target, key);\n        if (!deleted)\n            return false;\n        const AI = getNodeExisting(target);\n        AI.AT?.delete(key);\n        AI.AU?.delete(key);\n        AI.keys?.observable.set(0);\n        AI.values?.observable.set(0);\n        AI.has?.get(key)?.observable.set(false);\n        const property = AI.AJ?.get(key);\n        if (StoreListenersRoots.AK) {\n            StoreListenersRoots.AR(property?.AI, AI, key);\n        }\n        if (property?.AI) {\n            lazySetDelete(property.AI, 'AO', AI);\n        }\n        if (property) {\n            property.observable?.set(undefined);\n            property.AI = undefined;\n        }\n        if (StoreListenersRegular.AK) {\n            StoreListenersRegular.V(AI);\n        }\n        return true;\n    },\n    defineProperty: (target, key, descriptor) => {\n        const AI = getNodeExisting(target);\n        const equals = AI.equals || is;\n        const hadProperty = (key in target);\n        const descriptorPrev = Reflect.getOwnPropertyDescriptor(target, key);\n        if ('value' in descriptor && isStore(descriptor.value)) {\n            descriptor = { ...descriptor, value: getTarget(descriptor.value) };\n        }\n        if (descriptorPrev && isEqualDescriptor(descriptorPrev, descriptor, equals))\n            return true;\n        const defined = Reflect.defineProperty(target, key, descriptor);\n        if (!defined)\n            return false;\n        if (!descriptor.get) {\n            AI.AT?.delete(key);\n        }\n        else if (descriptor.get) {\n            AI.AT || (AI.AT = new StoreMap());\n            AI.AT.set(key, descriptor.get);\n        }\n        if (!descriptor.set) {\n            AI.AU?.delete(key);\n        }\n        else if (descriptor.set) {\n            AI.AU || (AI.AU = new StoreMap());\n            AI.AU.set(key, descriptor.set);\n        }\n        if (hadProperty !== !!descriptor.enumerable) {\n            AI.keys?.observable.set(0);\n        }\n        AI.has?.get(key)?.observable.set(true);\n        const property = AI.AJ?.get(key);\n        if (StoreListenersRoots.AK) {\n            StoreListenersRoots.AR(property?.AI, AI, key);\n        }\n        if (property?.AI) {\n            lazySetDelete(property.AI, 'AO', AI);\n        }\n        if (property) {\n            if ('get' in descriptor) {\n                property.observable?.set(descriptor.get);\n                property.AI = undefined;\n            }\n            else {\n                const value = descriptor.value;\n                property.observable?.set(value);\n                property.AI = isProxiable(value) ? NODES.get(value) || getNode(value, key, AI) : undefined;\n            }\n        }\n        if (property?.AI) {\n            lazySetAdd(property.AI, 'AO', AI);\n        }\n        if (StoreListenersRoots.AK) {\n            StoreListenersRoots.AR(property?.AI, AI, key);\n        }\n        if (StoreListenersRegular.AK) {\n            StoreListenersRegular.V(AI);\n        }\n        return true;\n    },\n    has: (target, key) => {\n        if (key === SYMBOL_STORE)\n            return true;\n        if (key === SYMBOL_STORE_TARGET)\n            return true;\n        const value = (key in target);\n        if (isListenable()) {\n            const AI = getNodeExisting(target);\n            AI.has || (AI.has = new StoreMap());\n            const has = AI.has.get(key) || AI.has.AH(key, getNodeHas(AI, key, value));\n            has.listen();\n            has.observable.get();\n        }\n        return value;\n    },\n    ownKeys: (target) => {\n        const keys = Reflect.ownKeys(target);\n        if (isListenable()) {\n            const AI = getNodeExisting(target);\n            AI.keys || (AI.keys = getNodeKeys(AI));\n            AI.keys.listen();\n            AI.keys.observable.get();\n        }\n        return keys;\n    }\n};\nconst STORE_UNTRACK_TRAPS = {\n    /* API */\n    has: (target, key) => {\n        if (key === SYMBOL_STORE_UNTRACKED)\n            return true;\n        return (key in target);\n    }\n};\n/* HELPERS */\nconst getNode = (value, key, parent, equals) => {\n    if (isStore(value))\n        return getNodeExisting(getTarget(value));\n    const store = isFrozenLike(value, key, parent) ? value : new Proxy(value, STORE_TRAPS);\n    const gettersAndSetters = getGettersAndSetters(value);\n    const AI = { AO: parent, store };\n    if (gettersAndSetters) {\n        const { AT, AU } = gettersAndSetters;\n        if (AT)\n            AI.AT = AT;\n        if (AU)\n            AI.AU = AU;\n    }\n    if (equals === false) {\n        AI.equals = nope;\n    }\n    else if (equals) {\n        AI.equals = equals;\n    }\n    else if (parent?.equals) {\n        AI.equals = parent.equals;\n    }\n    NODES.set(value, AI);\n    return AI;\n};\nconst getNodeExisting = (value) => {\n    const AI = NODES.get(value);\n    if (!AI)\n        throw new Error('Impossible');\n    return AI;\n};\nconst getNodeFromStore = (store) => {\n    return getNodeExisting(getTarget(store));\n};\nconst getNodeKeys = (AI) => {\n    const observable = getNodeObservable(AI, 0, { equals: false });\n    const keys = new StoreKeys(AI, observable);\n    return keys;\n};\nconst getNodeValues = (AI) => {\n    const observable = getNodeObservable(AI, 0, { equals: false });\n    const values = new StoreValues(AI, observable);\n    return values;\n};\nconst getNodeHas = (AI, key, value) => {\n    const observable = getNodeObservable(AI, value);\n    const has = new StoreHas(AI, key, observable);\n    return has;\n};\nconst getNodeObservable = (AI, value, options) => {\n    return new ObservableClass(value, options);\n};\nconst getNodeProperty = (AI, key, value) => {\n    const observable = undefined;\n    const propertyNode = isProxiable(value) ? NODES.get(value) || getNode(value, key, AI) : undefined;\n    const property = new StoreProperty(AI, key, observable, propertyNode);\n    AI.AJ || (AI.AJ = new StoreMap());\n    AI.AJ.set(key, property);\n    return property;\n};\nconst getGettersAndSetters = (value) => {\n    if (isArray(value))\n        return;\n    let AT;\n    let AU;\n    const keys = Object.keys(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(value, key);\n        if (!descriptor)\n            continue;\n        const { get, set } = descriptor;\n        if (get) {\n            AT || (AT = new StoreMap());\n            AT.set(key, get);\n        }\n        if (set) {\n            AU || (AU = new StoreMap());\n            AU.set(key, set);\n        }\n        if (get && !set) { // This ensures that settings throws without first reading the getter, very cheaply\n            AU || (AU = new StoreMap());\n            AU.set(key, throwNoSetterError);\n        }\n    }\n    if (!AT && !AU)\n        return;\n    return { AT, AU };\n};\nconst getStore = (value, options) => {\n    if (isStore(value))\n        return value;\n    const AI = NODES.get(value) || getNode(value, undefined, undefined, options?.equals);\n    return AI.store;\n};\nconst getTarget = (value) => {\n    if (isStore(value))\n        return value[SYMBOL_STORE_TARGET];\n    return value;\n};\nconst getUntracked = (value) => {\n    if (!isObject(value))\n        return value;\n    if (isUntracked(value))\n        return value;\n    return new Proxy(value, STORE_UNTRACK_TRAPS);\n};\nconst isEqualDescriptor = (a, b, equals) => {\n    return (!!a.configurable === !!b.configurable && !!a.enumerable === !!b.enumerable && !!a.writable === !!b.writable && equals(a.value, b.value) && a.get === b.get && a.set === b.set);\n};\nconst isFrozenLike = (value, key, parent) => {\n    if (Object.isFrozen(value))\n        return true;\n    if (!parent || key === undefined)\n        return false;\n    const target = store.unwrap(parent.store);\n    const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n    if (descriptor?.configurable || descriptor?.writable)\n        return false;\n    return true;\n};\nconst isListenable = () => {\n    return !!OBSERVER;\n};\nconst isProxiable = (value) => {\n    if (value === null || typeof value !== 'object')\n        return false;\n    if (SYMBOL_STORE in value)\n        return true;\n    if (SYMBOL_STORE_UNTRACKED in value)\n        return false;\n    if (isArray(value))\n        return true;\n    const prototype = Object.getPrototypeOf(value);\n    if (prototype === null)\n        return true;\n    return (Object.getPrototypeOf(prototype) === null);\n};\nconst isUntracked = (value) => {\n    if (value === null || typeof value !== 'object')\n        return false;\n    return (SYMBOL_STORE_UNTRACKED in value);\n};\nconst throwNoSetterError = () => {\n    throw new TypeError('Cannot set property value of #<Object> which has only a getter');\n};\n/* MAIN */\n//TODO: Maybe have the \"on\" method trigger immediately too like \"$.on\", or maybe the other way around, which seems more flexible\n//TODO: Explore converting target values back to numbers (the Proxy always receives strings) whenever possible, to save memory\n//TODO: Implement \"_onRoots\" better, perhaps provding string paths instead, which should be more powerful\nconst store = (value, options) => {\n    if (!isObject(value))\n        return value;\n    if (isUntracked(value))\n        return value;\n    return getStore(value, options);\n};\n/* UTILITIES */\nstore.on = (target, listener) => {\n    /* VARIABLES */\n    const targets = isStore(target) ? [target] : castArray(target);\n    const selectors = targets.filter(isFunction);\n    const AM = targets.filter(isStore).map(getNodeFromStore);\n    /* ON */\n    StoreListenersRegular.AK += 1;\n    const disposers = selectors.map(selector => {\n        let inited = false;\n        return effect(() => {\n            if (inited) {\n                StoreListenersRegular.AL.add(listener);\n                StoreScheduler.F();\n            }\n            inited = true;\n            selector();\n        }, { suspense: false, sync: true });\n    });\n    AM.forEach(AI => {\n        lazySetAdd(AI, 'AP', listener);\n    });\n    /* OFF */\n    return () => {\n        StoreListenersRegular.AK -= 1;\n        disposers.forEach(disposer => {\n            disposer();\n        });\n        AM.forEach(AI => {\n            lazySetDelete(AI, 'AP', listener);\n        });\n    };\n};\nstore._onRoots = (target, listener) => {\n    if (!isStore(target))\n        return noop;\n    const AI = getNodeFromStore(target);\n    if (AI.AO)\n        throw new Error('Only top-level stores are supported');\n    /* ON */\n    StoreListenersRoots.AK += 1;\n    lazySetAdd(AI, 'AQ', listener);\n    /* OFF */\n    return () => {\n        StoreListenersRoots.AK -= 1;\n        lazySetDelete(AI, 'AQ', listener);\n    };\n};\nstore.reconcile = (() => {\n    //TODO: Support AT, AU and symbols (symbols could be supported with Reflect.ownKeys, but that's like 2x slower)\n    const getType = (value) => {\n        if (isArray(value))\n            return 1;\n        if (isProxiable(value))\n            return 2;\n        return 0;\n    };\n    const reconcileOuter = (prev, next) => {\n        const uprev = getTarget(prev);\n        const unext = getTarget(next);\n        reconcileInner(prev, next);\n        const prevType = getType(uprev);\n        const nextType = getType(unext);\n        if (prevType === 1 || nextType === 1) {\n            prev.length = next.length;\n        }\n        return prev;\n    };\n    const reconcileInner = (prev, next) => {\n        const uprev = getTarget(prev);\n        const unext = getTarget(next);\n        const prevKeys = Object.keys(uprev);\n        const nextKeys = Object.keys(unext);\n        for (let i = 0, l = nextKeys.length; i < l; i++) {\n            const key = nextKeys[i];\n            const prevValue = uprev[key];\n            const nextValue = unext[key];\n            if (!is(prevValue, nextValue)) {\n                const prevType = getType(prevValue);\n                const nextType = getType(nextValue);\n                if (prevType && prevType === nextType) {\n                    reconcileInner(prev[key], nextValue);\n                    if (prevType === 1) {\n                        prev[key].length = nextValue.length;\n                    }\n                }\n                else {\n                    prev[key] = nextValue;\n                }\n            }\n            else if (prevValue === undefined && !(key in uprev)) {\n                prev[key] = undefined;\n            }\n        }\n        for (let i = 0, l = prevKeys.length; i < l; i++) {\n            const key = prevKeys[i];\n            if (!(key in unext)) {\n                delete prev[key];\n            }\n        }\n        return prev;\n    };\n    const reconcile = (prev, next) => {\n        return untrack(() => {\n            return reconcileOuter(prev, next);\n        });\n    };\n    return reconcile;\n})();\nstore.untrack = (value) => {\n    return getUntracked(value);\n};\nstore.unwrap = (value) => {\n    return getTarget(value);\n};\n/* EXPORT */\nexport default store;\n","/* IMPORT */\nimport { OBSERVABLE_FALSE } from '../constants.js';\nimport { OWNER } from '../context.js';\nimport { readable } from '../objects/callable.js';\nimport Observable from '../objects/observable.js';\nimport { SYMBOL_SUSPENSE } from '../symbols.js';\n/* MAIN */\nconst suspended = () => {\n    const suspense = OWNER.get(SYMBOL_SUSPENSE);\n    if (!suspense)\n        return OBSERVABLE_FALSE;\n    const observable = (suspense.observable || (suspense.observable = new Observable(!!suspense.suspended)));\n    return readable(observable);\n};\n/* EXPORT */\nexport default suspended;\n","/* IMPORT */\nimport Scheduler from '../objects/scheduler.async.js';\n/* MAIN */\nconst tick = () => {\n    Scheduler.N();\n};\n/* EXPORT */\nexport default tick;\n","/* IMPORT */\nimport { OWNER } from '../context.js';\nimport memo from './memo.js';\nimport $ from './observable.js';\nimport resolve from './resolve.js';\n/* MAIN */\nconst tryCatch = (value, fn) => {\n    const observable = $();\n    return memo(() => {\n        const error = observable();\n        if (error) {\n            const reset = () => observable(undefined);\n            const options = { error, reset };\n            return resolve(fn(options));\n        }\n        else {\n            OWNER.S = observable;\n            return resolve(value);\n        }\n    });\n};\n/* EXPORT */\nexport default tryCatch;\n","/* IMPORT */\nimport untrack from './untrack.js';\nimport { SYMBOL_UNTRACKED } from '../symbols.js';\nimport { isFunction } from '../utils.js';\nfunction untracked(fn) {\n    const untracked = isFunction(fn) ? (...args) => untrack(() => fn(...args)) : () => fn;\n    untracked[SYMBOL_UNTRACKED] = true;\n    return untracked;\n}\n/* EXPORT */\nexport default untracked;\n","/* IMPORT */\nimport { OBSERVER, OWNER } from '../context.js';\n/* MAIN */\nconst _with = () => {\n    const owner = OWNER;\n    const observer = OBSERVER;\n    return (fn) => {\n        return owner.E(() => fn(), owner, observer);\n    };\n};\n/* EXPORT */\nexport default _with;\n","/* IMPORT */\nimport batch from './batch.js';\nimport boolean from './boolean.js';\nimport cleanup from './cleanup.js';\nimport context from './context.js';\nimport disposed from './disposed.js';\nimport effect from './effect.js';\nimport _for from './for.js';\nimport get from './get.js';\nimport _if from './if.js';\nimport isBatching from './is_batching.js';\nimport isObservable from './is_observable.js';\nimport isStore from './is_store.js';\nimport memo from './memo.js';\nimport observable from './observable.js';\nimport owner from './owner.js';\nimport readonly from './readonly.js';\nimport resolve from './resolve.js';\nimport root from './root.js';\nimport selector from './selector.js';\nimport store from './store.js';\nimport suspended from './suspended.js';\nimport suspense from './suspense.js';\nimport _switch from './switch.js';\nimport ternary from './ternary.js';\nimport tick from './tick.js';\nimport tryCatch from './try_catch.js';\nimport untrack from './untrack.js';\nimport untracked from './untracked.js';\nimport _with from './with.js';\nimport { writable } from '../objects/callable.js';\nimport ObservableClass from '../objects/observable.js';\nfunction $(value, options) {\n    return writable(new ObservableClass(value, options));\n}\n/* UTILITIES */\n$.batch = batch;\n$.boolean = boolean;\n$.cleanup = cleanup;\n$.context = context;\n$.disposed = disposed;\n$.effect = effect;\n$.for = _for;\n$.get = get;\n$.if = _if;\n$.isBatching = isBatching;\n$.isObservable = isObservable;\n$.isStore = isStore;\n$.memo = memo;\n$.observable = observable;\n$.owner = owner;\n$.readonly = readonly;\n$.resolve = resolve;\n$.root = root;\n$.selector = selector;\n$.store = store;\n$.suspended = suspended;\n$.suspense = suspense;\n$.switch = _switch;\n$.ternary = ternary;\n$.tick = tick;\n$.tryCatch = tryCatch;\n$.untrack = untrack;\n$.untracked = untracked;\n$.with = _with;\n/* EXPORT */\nexport default $;\n","import $oby, { untrack, cleanup, owner, } from 'oby';\nimport { createReactivityAdapter } from 'signaldb';\nconst obyReactivityAdapter = createReactivityAdapter({\n    create: () => {\n        const dep = $oby(0);\n        return {\n            depend: () => {\n                dep();\n            },\n            notify: () => {\n                dep(untrack(() => dep() + 1));\n            },\n        };\n    },\n    isInScope: () => !!owner(),\n    onDispose: (callback) => {\n        cleanup(callback);\n    },\n});\nexport default obyReactivityAdapter;\n"],"names":["SYMBOL_CACHED","SYMBOL_OBSERVABLE","SYMBOL_OBSERVABLE_BOOLEAN","SYMBOL_OBSERVABLE_FROZEN","SYMBOL_OBSERVABLE_READABLE","SYMBOL_OBSERVABLE_WRITABLE","SYMBOL_STORE","SYMBOL_STORE_KEYS","SYMBOL_STORE_OBSERVABLE","SYMBOL_STORE_TARGET","SYMBOL_STORE_VALUES","SYMBOL_STORE_UNTRACKED","SYMBOL_SUSPENSE","SYMBOL_UNCACHED","SYMBOL_UNTRACKED","SYMBOL_UNTRACKED_UNWRAPPED","castArray","value","isArray","castError","error","is","isEqual","a","b","i","l","valueA","valueB","isFunction","isObject","isSymbol","noop","nope","frozenFunction","readableFunction","writableFunction","fn","frozen","readable","writable","DIRTY_NO","DIRTY_MAYBE_NO","DIRTY_MAYBE_YES","DIRTY_YES","OBSERVABLE_FALSE","OBSERVABLE_TRUE","UNAVAILABLE","UNINITIALIZED","lazyArrayEach","arr","lazyArrayEachRight","lazyArrayPush","obj","key","lazySetAdd","set","s","lazySetDelete","lazySetEach","onCleanup","cleanup","onDispose","owner","Owner","silent","S","_a","deep","symbol","observer","ownerPrev","OWNER","observerPrev","OBSERVER","setOwner","setObserver","SuperRoot","BATCH","SUPER_OWNER","setBatch","M","resolve","batch","r","isObservableBoolean","isObservableFrozen","_b","isUntracked","Scheduler$2","queue","SchedulerSync","Scheduler","Observable","options","parent","equals","J","ObservablesArray","A","P","observablesLength","observable","index","ObservablesSet","sizePrev","sizeNext","Observer","Memo","G","statusPrev","memo","boolean","Context","context","symbolOrContext","disposed","effect","Scheduler$1","Effect","suspense","resolved","Root","V","Q","fnWithDispose","DUMMY_INDEX","CacheKeyed","A5","A6","mapped","values","AB","results","resultsCached","resultsUncached","A8","cached","MappedRoot","isObservable","get","getFunction","Suspense","force","suspendedPrev","suspendedNext","notifyOwner","notifyObserver","notifySuspense","notifyRoot","root","when","condition","CacheUnkeyed","pooled","poolable","cacheNext","AC","leftovers","outer","isDuplicate","_c","_d","_e","_f","$index","suspended","$value","isStore","untrack","_for","fallback","isUnkeyed","map","next","prev","array","warmup","match","_switch","ternary","valueTrue","valueFalse","_if","isBatching","SchedulerAsync","ObservableClass","isSuperRoot","isRoot","isSuspense","isComputation","isObservableWritable","target","readonly","DisposableMap","SelectedObservable","selector","AG","sourceValue","AF","selectedValue","valuePrev","valueNext","selected","StoreMap","StoreCleanable","StoreKeys","StoreValues","StoreHas","StoreProperty","AI","StoreListenersRegular","AL","AM","traversed","traverse","listener","StoreScheduler","StoreListenersRoots","rootsSet","store","T","current","flushRegular","flushRoots","NODES","SPECIAL_SYMBOLS","UNREACTIVE_KEYS","STORE_TRAPS","isListenable","getNodeExisting","getNodeKeys","getNodeValues","getter","property","getNodeProperty","getNodeObservable","listenable","proxiable","isProxiable","getTarget","setter","targetIsArray","hadProperty","lengthPrev","lengthNext","_h","_g","_i","_j","getNode","_force","hasProperty","descriptor","descriptorPrev","isEqualDescriptor","has","getNodeHas","keys","STORE_UNTRACK_TRAPS","isFrozenLike","gettersAndSetters","getGettersAndSetters","AT","AU","getNodeFromStore","propertyNode","throwNoSetterError","getStore","getUntracked","prototype","targets","selectors","disposers","inited","disposer","getType","reconcileOuter","uprev","unext","reconcileInner","prevType","nextType","prevKeys","nextKeys","prevValue","nextValue","tick","tryCatch","$","untracked","args","_with","createReactivityAdapter","dep","$oby","callback"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]}