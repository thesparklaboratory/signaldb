{"version":3,"file":"index.mjs","sources":["../src/types/EventEmitter.ts","../src/utils/match.ts","../src/utils/modify.ts","../src/utils/isEqual.ts","../src/utils/randomId.ts","../src/utils/deepClone.ts","../src/utils/serializeValue.ts","../src/utils/createSignal.ts","../src/utils/get.ts","../src/utils/sortItems.ts","../src/utils/set.ts","../src/utils/project.ts","../src/utils/uniqueBy.ts","../src/Collection/Observer.ts","../src/Collection/Cursor.ts","../../../node_modules/tslib/tslib.es6.mjs","../src/utils/intersection.ts","../src/Collection/getIndexInfo.ts","../src/createIndexProvider.ts","../src/utils/isFieldExpression.ts","../src/utils/getMatchingKeys.ts","../src/Collection/createIndex.ts","../src/Collection/index.ts","../src/persistence/createPersistenceAdapter.ts","../src/persistence/createLocalStorageAdapter.ts","../src/persistence/createFilesystemAdapter.ts","../src/PersistentCollection.ts","../src/persistence/combinePersistenceAdapters.ts","../src/ReplicatedCollection.ts","../src/AutoFetchCollection.ts","../src/persistence/createOPFSAdapter.ts","../src/createMemoryAdapter.ts","../src/createReactivityAdapter.ts","../src/utils/debounce.ts","../src/utils/PromiseQueue.ts","../src/SyncManager/computeChanges.ts","../src/SyncManager/getSnapshot.ts","../src/SyncManager/applyChanges.ts","../src/SyncManager/sync.ts","../src/SyncManager/index.ts"],"sourcesContent":["import { EventEmitter as BaseEventEmitter } from 'events';\nexport default class EventEmitter extends BaseEventEmitter {\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n}\n","import { Query } from 'mingo';\nexport default function match(item, selector) {\n    const query = new Query(selector);\n    return query.test(item);\n}\n","import { updateObject } from 'mingo/updater';\nexport default function modify(item, modifier) {\n    const clonedItem = Object.assign({}, item);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    updateObject(clonedItem, modifier);\n    return clonedItem;\n}\n","export default function isEqual(a, b) {\n    if (Object.is(a, b))\n        return true;\n    if (a instanceof RegExp && b instanceof RegExp)\n        return a.toString() === b.toString();\n    if (a instanceof Date && b instanceof Date)\n        return a.getTime() === b.getTime();\n    if (typeof a !== 'object')\n        return false;\n    if (typeof b !== 'object')\n        return false;\n    if (a === null)\n        return false;\n    if (b === null)\n        return false;\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length)\n        return false;\n    for (let i = 0; i < aKeys.length; i += 1) {\n        const key = aKeys[i];\n        if (!bKeys.includes(key))\n            return false;\n        if (!isEqual(a[key], b[key]))\n            return false;\n    }\n    return true;\n}\n","export default function randomId() {\n    return Math.floor(Math.random() * 1e17).toString(16);\n}\n","export function clone(value) {\n    // Functions\n    if (typeof value === 'function')\n        throw new Error('Cloning functions is not supported');\n    // Check for null or primitive types (string, number, boolean, etc.)\n    if (value === null || typeof value !== 'object')\n        return value;\n    // Dates\n    if (value instanceof Date)\n        return new Date(value.getTime());\n    // Arrays\n    if (Array.isArray(value))\n        return value.map(item => clone(item));\n    // Maps\n    if (value instanceof Map) {\n        const result = new Map();\n        value.forEach((val, key) => {\n            result.set(key, clone(val));\n        });\n        return result;\n    }\n    // Sets\n    if (value instanceof Set) {\n        const result = new Set();\n        value.forEach((val) => {\n            result.add(clone(val));\n        });\n        return result;\n    }\n    // RegExp\n    if (value instanceof RegExp)\n        return new RegExp(value);\n    // plain objects\n    const result = {};\n    for (const key in value) {\n        if (Object.hasOwnProperty.call(value, key)) {\n            result[key] = clone(value[key]);\n        }\n    }\n    return result;\n}\nexport default function deepClone(obj) {\n    // If structuredClone is available, use it\n    if (typeof structuredClone === 'function')\n        return structuredClone(obj);\n    // Otherwise, perform a manual deep clone\n    /* istanbul ignore next -- @preserve */\n    return clone(obj);\n}\n","export default function serializeValue(value) {\n    if (typeof value === 'string')\n        return value;\n    if (typeof value === 'number')\n        return value.toString();\n    if (typeof value === 'boolean')\n        return value.toString();\n    if (value instanceof Date)\n        return value.toISOString();\n    return JSON.stringify(value);\n}\n","export default function createSignal(dependency, initialValue, isEqual = Object.is) {\n    let value = initialValue;\n    const signal = {\n        get() {\n            if (dependency)\n                dependency.depend();\n            return value;\n        },\n        set(newValue) {\n            if (isEqual(value, newValue))\n                return;\n            value = newValue;\n            if (dependency)\n                dependency.notify();\n        },\n    };\n    return signal;\n}\n","export default function get(value, path) {\n    const segments = path.split(/[.[\\]]/g);\n    if (segments[0] === '')\n        segments.shift();\n    if (segments[segments.length - 1] === '')\n        segments.pop();\n    let current = value;\n    for (let i = 0; i < segments.length; i += 1) {\n        const key = segments[i];\n        if (current == null || key.trim() === '')\n            return undefined;\n        current = current[key];\n    }\n    if (current === undefined)\n        return undefined;\n    return current;\n}\n","import { sort } from 'fast-sort';\nimport get from './get';\nexport default function sortItems(items, sortFields) {\n    return sort(items).by(Object.entries(sortFields).map(([key, value]) => {\n        const order = value === 1 ? 'asc' : 'desc';\n        return { [order]: (i) => get(i, key) };\n    }));\n}\n","/* eslint-disable no-param-reassign */\nexport default function set(obj, path, value, deleteIfUndefined = false) {\n    if (obj == null)\n        return obj;\n    const segments = path.split(/[.[\\]]/g);\n    if (segments[0] === '')\n        segments.shift();\n    if (segments[segments.length - 1] === '')\n        segments.pop();\n    const apply = (node) => {\n        if (segments.length > 1) {\n            const key = segments.shift();\n            const nextIsNum = !Number.isNaN(parseInt(segments[0], 10));\n            if (node[key] === undefined) {\n                node[key] = nextIsNum ? [] : {};\n            }\n            apply(node[key]);\n        }\n        else {\n            if (deleteIfUndefined && value === undefined) {\n                delete node[segments[0]];\n                return;\n            }\n            node[segments[0]] = value;\n        }\n    };\n    apply(obj);\n    return obj;\n}\n","import get from './get';\nimport set from './set';\nexport default function project(item, fields) {\n    const allFieldsDeactivated = Object.values(fields).every(value => value === 0);\n    if (allFieldsDeactivated) {\n        const result = Object.assign({}, item);\n        Object.keys(fields).forEach((key) => {\n            const fieldValue = get(item, key);\n            if (fieldValue === undefined)\n                return;\n            set(result, key, undefined, true);\n        });\n        return result;\n    }\n    const result = {};\n    Object.entries(fields).forEach(([key, value]) => {\n        const fieldValue = get(item, key);\n        if (fieldValue === undefined)\n            return;\n        if (fieldValue == null && value !== 1)\n            return;\n        set(result, key, value === 1 ? fieldValue : undefined);\n    });\n    return result;\n}\n","export default function uniqueBy(arr, fn) {\n    const set = new Set();\n    return arr.filter((el) => {\n        const value = typeof fn === 'function' ? fn(el) : el[fn];\n        return !set.has(value) && set.add(value);\n    });\n}\n","import isEqual from '../utils/isEqual';\nimport uniqueBy from '../utils/uniqueBy';\nexport default class Observer {\n    constructor(bindEvents) {\n        this.previousItems = [];\n        this.callbacks = {\n            added: [],\n            addedBefore: [],\n            changed: [],\n            changedField: [],\n            movedBefore: [],\n            removed: [],\n        };\n        this.unbindEvents = bindEvents();\n    }\n    call(event, ...args) {\n        this.callbacks[event].forEach(({ callback, options }) => {\n            // execute only if it's not initial call or if initial call should not be skipped\n            if (!options.skipInitial || !options.isInitial) {\n                callback(...args);\n            }\n        });\n    }\n    hasCallbacks(events) {\n        return events.some(event => this.callbacks[event].length > 0);\n    }\n    isEmpty() {\n        return !this.hasCallbacks([\n            'added',\n            'addedBefore',\n            'changed',\n            'changedField',\n            'movedBefore',\n            'removed',\n        ]);\n    }\n    runChecks(newItems) {\n        const oldItemsMap = new Map(this.previousItems.map((item, index) => [\n            item.id,\n            { item, index, beforeItem: this.previousItems[index + 1] || null },\n        ]));\n        const newItemsMap = new Map(newItems.map((item, index) => [\n            item.id,\n            { item, index, beforeItem: newItems[index + 1] || null },\n        ]));\n        if (this.hasCallbacks(['changed', 'changedField', 'movedBefore', 'removed'])) {\n            // Check for removed or changed items\n            oldItemsMap.forEach(({ item: oldItem, index, beforeItem: oldBeforeItem }) => {\n                var _a;\n                const newItem = newItemsMap.get(oldItem.id);\n                if (newItem) {\n                    if (this.hasCallbacks(['changed', 'changedField'])) {\n                        // If the item exists but has changed, call 'changed' callback\n                        if (!isEqual(newItem.item, oldItem)) {\n                            this.call('changed', newItem.item);\n                            if (this.hasCallbacks(['changedField'])) {\n                                // check for changed fields and call 'changedField' callback\n                                const keys = uniqueBy([\n                                    ...Object.keys(newItem.item),\n                                    ...Object.keys(oldItem),\n                                ], value => value);\n                                keys.forEach((key) => {\n                                    if (isEqual(newItem.item[key], oldItem[key]))\n                                        return;\n                                    this.call('changedField', newItem.item, key, oldItem[key], newItem.item[key]);\n                                });\n                            }\n                        }\n                    }\n                    // If the item's beforeItem has changed, call 'movedBefore' callback\n                    if (newItem.index !== index && ((_a = newItem.beforeItem) === null || _a === void 0 ? void 0 : _a.id) !== (oldBeforeItem === null || oldBeforeItem === void 0 ? void 0 : oldBeforeItem.id)) {\n                        this.call('movedBefore', newItem.item, newItem.beforeItem);\n                    }\n                }\n                else {\n                    // If the item no longer exists, call 'removed' callback\n                    this.call('removed', oldItem);\n                }\n            });\n        }\n        if (this.hasCallbacks(['added', 'addedBefore'])) {\n            // Check for added items\n            newItems.forEach((newItem, index) => {\n                const oldItem = oldItemsMap.get(newItem.id);\n                if (oldItem)\n                    return;\n                // If the item is newly added, call 'added' and 'addedBefore' callbacks\n                this.call('added', newItem);\n                this.call('addedBefore', newItem, newItems[index + 1] || null);\n            });\n        }\n        // Store new items as previous items for next check\n        this.previousItems = newItems;\n        Object.keys(this.callbacks).forEach((key) => {\n            const event = key;\n            const callbacks = this.callbacks[event];\n            this.callbacks[event] = callbacks.map(callback => (Object.assign(Object.assign({}, callback), { options: Object.assign(Object.assign({}, callback.options), { isInitial: false }) })));\n        });\n    }\n    stop() {\n        this.unbindEvents();\n    }\n    addCallbacks(callbacks, skipInitial = false) {\n        Object.keys(callbacks).forEach((key) => {\n            const typedKey = key;\n            this.callbacks[typedKey].push({\n                callback: callbacks[typedKey],\n                options: { skipInitial, isInitial: true },\n            });\n        });\n    }\n    removeCallbacks(callbacks) {\n        Object.keys(callbacks).forEach((key) => {\n            const typedKey = key;\n            const index = this.callbacks[typedKey]\n                .findIndex(({ callback }) => callback === callbacks[typedKey]);\n            this.callbacks[typedKey].splice(index, 1);\n        });\n    }\n}\n","import sortItems from '../utils/sortItems';\nimport project from '../utils/project';\nimport Observer from './Observer';\nexport function isInReactiveScope(reactivity) {\n    if (!reactivity)\n        return false; // if reactivity is disabled we don't need to check\n    if (!reactivity.isInScope)\n        return true; // if reactivity is enabled and no isInScope method is provided we assume it is in scope\n    return reactivity.isInScope(); // if reactivity is enabled and isInScope method is provided we check if it is in scope\n}\nexport default class Cursor {\n    constructor(getItems, options) {\n        this.onCleanupCallbacks = [];\n        this.getFilteredItems = getItems;\n        this.options = options || {};\n    }\n    addGetters(item) {\n        if (!isInReactiveScope(this.options.reactive))\n            return item;\n        const depend = this.depend.bind(this);\n        return Object.entries(item).reduce((memo, [key, value]) => {\n            Object.defineProperty(memo, key, {\n                get() {\n                    depend({\n                        changedField: notify => (changedItem, changedFieldName) => {\n                            if (changedFieldName !== key || changedItem.id !== item.id)\n                                return;\n                            notify();\n                        },\n                    });\n                    return value;\n                },\n                enumerable: true,\n                configurable: true,\n            });\n            return memo;\n        }, {});\n    }\n    transform(rawItem) {\n        const item = this.options.fieldTracking\n            ? this.addGetters(rawItem)\n            : rawItem;\n        if (!this.options.transform)\n            return item;\n        return this.options.transform(item);\n    }\n    getItems() {\n        const items = this.getFilteredItems();\n        const { sort, skip, limit } = this.options;\n        const sorted = sort ? sortItems(items, sort) : items;\n        const skipped = skip ? sorted.slice(skip) : sorted;\n        const limited = limit ? skipped.slice(0, limit) : skipped;\n        const idExcluded = this.options.fields && this.options.fields.id === 0;\n        return limited.map((item) => {\n            if (!this.options.fields)\n                return item;\n            return Object.assign(Object.assign({}, idExcluded ? {} : { id: item.id }), project(item, this.options.fields));\n        });\n    }\n    depend(changeEvents) {\n        if (!this.options.reactive)\n            return;\n        if (!isInReactiveScope(this.options.reactive))\n            return;\n        const signal = this.options.reactive.create();\n        signal.depend();\n        const notify = () => signal.notify();\n        function buildNotifier(event) {\n            const eventHandler = changeEvents[event];\n            return (...args) => {\n                // if the event is just turned on with true, we can notify directly\n                if (eventHandler === true) {\n                    notify();\n                    return;\n                }\n                // if the event is something else than true or a function, we don't care about it\n                if (typeof eventHandler !== 'function')\n                    return;\n                // if the event is a function, we call it with the notify function\n                eventHandler(notify)(...args);\n            };\n        }\n        const stop = this.observeRawChanges({\n            added: buildNotifier('added'),\n            addedBefore: buildNotifier('addedBefore'),\n            changed: buildNotifier('changed'),\n            changedField: buildNotifier('changedField'),\n            movedBefore: buildNotifier('movedBefore'),\n            removed: buildNotifier('removed'),\n        }, true);\n        if (this.options.reactive.onDispose) {\n            this.options.reactive.onDispose(() => stop(), signal);\n        }\n        this.onCleanup(stop);\n    }\n    ensureObserver() {\n        if (!this.observer) {\n            const observer = new Observer(() => {\n                const requery = () => {\n                    observer.runChecks(this.getItems());\n                };\n                const cleanup = this.options.bindEvents && this.options.bindEvents(requery);\n                return () => {\n                    if (cleanup)\n                        cleanup();\n                };\n            });\n            this.onCleanup(() => observer.stop());\n            this.observer = observer;\n        }\n        return this.observer;\n    }\n    observeRawChanges(callbacks, skipInitial = false) {\n        const observer = this.ensureObserver();\n        observer.addCallbacks(callbacks, skipInitial);\n        observer.runChecks(this.getItems());\n        return () => {\n            observer.removeCallbacks(callbacks);\n            if (!observer.isEmpty())\n                return;\n            // remove observer if it's empty\n            observer.stop();\n            this.observer = undefined;\n        };\n    }\n    cleanup() {\n        this.onCleanupCallbacks.forEach((callback) => {\n            callback();\n        });\n        this.onCleanupCallbacks = [];\n    }\n    onCleanup(callback) {\n        this.onCleanupCallbacks.push(callback);\n    }\n    forEach(callback) {\n        const items = this.getItems();\n        this.depend(Object.assign({ addedBefore: true, removed: true, movedBefore: true }, this.options.fieldTracking ? {} : { changed: true }));\n        items.forEach((item) => {\n            callback(this.transform(item));\n        });\n    }\n    map(callback) {\n        const results = [];\n        this.forEach((item) => {\n            results.push(callback(item));\n        });\n        return results;\n    }\n    fetch() {\n        return this.map(item => item);\n    }\n    count() {\n        const items = this.getItems();\n        this.depend({\n            added: true,\n            removed: true,\n        });\n        return items.length;\n    }\n    observeChanges(callbacks, skipInitial = false) {\n        return this.observeRawChanges(Object\n            .entries(callbacks)\n            .reduce((memo, [callbackName, callback]) => {\n            if (!callback)\n                return memo;\n            return Object.assign(Object.assign({}, memo), { [callbackName]: (item, before) => {\n                    const transformedValue = this.transform(item);\n                    const hasBeforeParam = before !== undefined;\n                    const transformedBeforeValue = hasBeforeParam && before\n                        ? this.transform(before)\n                        : null;\n                    return callback(transformedValue, ...hasBeforeParam ? [transformedBeforeValue] : []);\n                } });\n        }, {}), skipInitial);\n    }\n    requery() {\n        if (!this.observer)\n            return;\n        this.observer.runChecks(this.getItems());\n    }\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","export default function intersection(...arrays) {\n    if (arrays.length === 0)\n        return [];\n    return [...new Set(arrays.reduce((a, b) => a.filter(c => b.includes(c))))];\n}\n","import { __rest } from \"tslib\";\nimport intersection from '../utils/intersection';\nexport function getMergedIndexInfo(indexProviders, selector) {\n    return indexProviders.reduce((memo, indexProvider) => {\n        /* istanbul ignore if -- @preserve */ // ignored because it's deprecated\n        if (indexProvider.getItemPositions) {\n            const result = indexProvider.getItemPositions(selector);\n            if (result == null)\n                return memo;\n            return {\n                matched: true,\n                positions: memo.matched\n                    ? intersection(memo.positions, result)\n                    : result,\n                optimizedSelector: memo.optimizedSelector,\n            };\n        }\n        const info = indexProvider.query(selector);\n        if (!info.matched)\n            return memo;\n        const optimizedSelector = Object.fromEntries(Object.entries(memo.optimizedSelector)\n            .filter(([key]) => !info.fields.includes(key)));\n        return {\n            matched: true,\n            positions: [...new Set(memo.matched\n                    ? intersection(memo.positions, info.positions)\n                    : info.positions)],\n            optimizedSelector,\n        };\n    }, {\n        matched: false,\n        positions: [],\n        optimizedSelector: Object.assign({}, selector),\n    });\n}\nexport default function getIndexInfo(indexProviders, selector) {\n    if (selector == null || Object.keys(selector).length <= 0) {\n        return { matched: false, positions: [], optimizedSelector: selector };\n    }\n    const { $and, $or } = selector, rest = __rest(selector, [\"$and\", \"$or\"]);\n    const flatInfo = getMergedIndexInfo(indexProviders, rest);\n    let { matched, positions } = flatInfo;\n    const newSelector = flatInfo.optimizedSelector;\n    if (Array.isArray($and)) {\n        const $andNew = [];\n        for (const sel of $and) {\n            const { matched: selMatched, positions: selPositions, optimizedSelector, } = getIndexInfo(indexProviders, sel);\n            if (selMatched) {\n                positions = matched ? intersection(positions, selPositions) : selPositions;\n                matched = true;\n                if (Object.keys(optimizedSelector).length > 0) {\n                    $andNew.push(optimizedSelector);\n                }\n            }\n            else {\n                $andNew.push(sel);\n            }\n        }\n        if ($andNew.length > 0)\n            newSelector.$and = $andNew;\n    }\n    if (Array.isArray($or)) {\n        const $orNew = [];\n        for (const sel of $or) {\n            const { matched: selMatched, positions: selPositions, optimizedSelector, } = getIndexInfo(indexProviders, sel);\n            if (selMatched) {\n                positions = [...new Set([...positions, ...selPositions])];\n                matched = true;\n                if (Object.keys(optimizedSelector).length > 0) {\n                    $orNew.push(optimizedSelector);\n                }\n            }\n            else {\n                $orNew.push(sel);\n            }\n        }\n        if ($orNew.length > 0)\n            newSelector.$or = $orNew;\n    }\n    return {\n        matched,\n        positions: positions || [],\n        optimizedSelector: newSelector,\n    };\n}\n","export default function createIndexProvider(definition) {\n    return definition;\n}\n","const expressionKeys = [\n    '$eq',\n    '$gt',\n    '$gte',\n    '$lt',\n    '$lte',\n    '$in',\n    '$nin',\n    '$ne',\n    '$exists',\n    '$not',\n    '$expr',\n    '$jsonSchema',\n    '$mod',\n    '$regex',\n    '$options',\n    '$text',\n    '$where',\n    '$all',\n    '$elemMatch',\n    '$size',\n    '$bitsAllClear',\n    '$bitsAllSet',\n    '$bitsAnyClear',\n    '$bitsAnySet',\n];\nexport default function isFieldExpression(expression) {\n    if (typeof expression !== 'object' || expression == null) {\n        return false;\n    }\n    const keys = Object.keys(expression);\n    if (keys.length === 0) {\n        return false;\n    }\n    const hasInvalidKeys = keys.some(key => !expressionKeys.includes(key));\n    if (hasInvalidKeys)\n        return false;\n    const hasValidKeys = keys.every(key => expressionKeys.includes(key));\n    return hasValidKeys;\n}\n","import isFieldExpression from './isFieldExpression';\nimport serializeValue from './serializeValue';\nexport default function getMatchingKeys(field, selector) {\n    if (selector[field] instanceof RegExp)\n        return null;\n    if (selector[field] != null) {\n        if (isFieldExpression(selector[field])) {\n            const is$in = isFieldExpression(selector[field])\n                && Array.isArray(selector[field].$in)\n                && selector[field].$in.length;\n            if (is$in) {\n                const optimizedSelector = Object.assign(Object.assign({}, selector), { [field]: Object.assign({}, selector[field]) });\n                delete optimizedSelector[field].$in;\n                if (Object.keys(optimizedSelector[field]).length === 0) {\n                    delete optimizedSelector[field];\n                }\n                return selector[field].$in.map(serializeValue);\n            }\n            return null;\n        }\n        return [serializeValue(selector[field])];\n    }\n    return null;\n}\n","import createIndexProvider from '../createIndexProvider';\nimport get from '../utils/get';\nimport getMatchingKeys from '../utils/getMatchingKeys';\nimport serializeValue from '../utils/serializeValue';\nexport function createExternalIndex(field, index) {\n    return createIndexProvider({\n        query(selector) {\n            const keys = getMatchingKeys(field, selector);\n            if (keys == null)\n                return { matched: false };\n            const itemPositions = keys\n                .reduce((memo, key) => [...memo, ...index.get(key) || []], []);\n            return {\n                matched: true,\n                positions: itemPositions,\n                fields: [field],\n            };\n        },\n        rebuild() {\n            // rebuilding is done externally\n        },\n    });\n}\nexport default function createIndex(field) {\n    const index = new Map();\n    return Object.assign(Object.assign({}, createExternalIndex(field, index)), { rebuild(items) {\n            index.clear();\n            items.forEach((item, i) => {\n                const value = serializeValue(get(item, field));\n                const current = index.get(value) || new Set();\n                current.add(i);\n                index.set(value, current);\n            });\n        } });\n}\n","import EventEmitter from '../types/EventEmitter';\nimport match from '../utils/match';\nimport modify from '../utils/modify';\nimport isEqual from '../utils/isEqual';\nimport randomId from '../utils/randomId';\nimport deepClone from '../utils/deepClone';\nimport serializeValue from '../utils/serializeValue';\nimport createSignal from '../utils/createSignal';\nimport Cursor from './Cursor';\nimport getIndexInfo from './getIndexInfo';\nimport { createExternalIndex } from './createIndex';\nexport { default as createIndex } from './createIndex';\nfunction hasPendingUpdates(pendingUpdates) {\n    return pendingUpdates.added.length > 0\n        || pendingUpdates.modified.length > 0\n        || pendingUpdates.removed.length > 0;\n}\nfunction applyUpdates(currentItems, { added, modified, removed }) {\n    const items = currentItems.slice();\n    added.forEach((item) => {\n        items.push(item);\n    });\n    modified.forEach((item) => {\n        const index = items.findIndex(({ id }) => id === item.id);\n        if (index === -1)\n            return;\n        items[index] = item;\n    });\n    removed.forEach((item) => {\n        const index = items.findIndex(({ id }) => id === item.id);\n        if (index === -1)\n            return;\n        items.splice(index, 1);\n    });\n    return items;\n}\n// eslint-disable-next-line max-len\nclass Collection extends EventEmitter {\n    static batch(callback) {\n        Collection.batchOperationInProgress = true;\n        Collection.collections.reduce((memo, collection) => () => collection.batch(() => memo()), callback)();\n        Collection.batchOperationInProgress = false;\n    }\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this.persistenceAdapter = null;\n        this.indexProviders = [];\n        this.indicesOutdated = false;\n        this.idIndex = new Map();\n        this.batchOperationInProgress = false;\n        this.isDisposed = false;\n        this.postBatchCallbacks = new Set();\n        Collection.collections.push(this);\n        this.options = Object.assign({ memory: [] }, options);\n        this.debugMode = (_a = this.options.enableDebugMode) !== null && _a !== void 0 ? _a : Collection.debugMode;\n        this.indexProviders = [\n            createExternalIndex('id', this.idIndex),\n            ...(this.options.indices || []),\n        ];\n        this.rebuildIndices();\n        this.isPullingSignal = createSignal((_b = this.options.reactivity) === null || _b === void 0 ? void 0 : _b.create(), !!(options === null || options === void 0 ? void 0 : options.persistence));\n        this.isPushingSignal = createSignal((_c = this.options.reactivity) === null || _c === void 0 ? void 0 : _c.create(), false);\n        this.on('persistence.pullStarted', () => {\n            this.isPullingSignal.set(true);\n        });\n        this.on('persistence.pullCompleted', () => {\n            this.isPullingSignal.set(false);\n        });\n        this.on('persistence.pushStarted', () => {\n            this.isPushingSignal.set(true);\n        });\n        this.on('persistence.pushCompleted', () => {\n            this.isPushingSignal.set(false);\n        });\n        this.persistenceAdapter = (_d = this.options.persistence) !== null && _d !== void 0 ? _d : null;\n        if (this.persistenceAdapter) {\n            let ongoingSaves = 0;\n            let isInitialized = false;\n            const pendingUpdates = { added: [], modified: [], removed: [] };\n            const loadPersistentData = async (data) => {\n                if (!this.persistenceAdapter)\n                    throw new Error('Persistence adapter not found');\n                this.emit('persistence.pullStarted');\n                // load items from persistence adapter and push them into memory\n                const { items, changes } = data !== null && data !== void 0 ? data : await this.persistenceAdapter.load();\n                if (items) {\n                    // as we overwrite all items, we need to discard if there are ongoing saves\n                    if (ongoingSaves > 0)\n                        return;\n                    // push new items to this.memory() and delete old ones\n                    this.memory().splice(0, this.memoryArray().length, ...items);\n                    this.idIndex.clear();\n                    // eslint-disable-next-line array-callback-return\n                    this.memory().map((item, index) => {\n                        this.idIndex.set(serializeValue(item.id), new Set([index]));\n                    });\n                }\n                else if (changes) {\n                    changes.added.forEach((item) => {\n                        const index = this.memory().findIndex(doc => doc.id === item.id);\n                        if (index >= 0) { // item already exists; doing upsert\n                            this.memory().splice(index, 1, item);\n                            return;\n                        }\n                        // item does not exists yet; normal insert\n                        this.memory().push(item);\n                        const itemIndex = this.memory().findIndex(doc => doc === item);\n                        this.idIndex.set(serializeValue(item.id), new Set([itemIndex]));\n                    });\n                    changes.modified.forEach((item) => {\n                        const index = this.memory().findIndex(doc => doc.id === item.id);\n                        if (index === -1)\n                            throw new Error('Cannot resolve index for item');\n                        this.memory().splice(index, 1, item);\n                    });\n                    changes.removed.forEach((item) => {\n                        const index = this.memory().findIndex(doc => doc.id === item.id);\n                        if (index === -1)\n                            throw new Error('Cannot resolve index for item');\n                        this.memory().splice(index, 1);\n                    });\n                }\n                this.rebuildIndices();\n                this.emit('persistence.received');\n                // emit persistence.pullCompleted in next tick to let cursor observers\n                // do the requery before the loading state updates\n                setTimeout(() => this.emit('persistence.pullCompleted'), 0);\n            };\n            const saveQueue = {\n                added: [],\n                modified: [],\n                removed: [],\n            };\n            let isFlushing = false;\n            const flushQueue = () => {\n                if (!this.persistenceAdapter)\n                    throw new Error('Persistence adapter not found');\n                if (ongoingSaves <= 0)\n                    this.emit('persistence.pushStarted');\n                if (isFlushing)\n                    return;\n                if (!hasPendingUpdates(saveQueue))\n                    return;\n                isFlushing = true;\n                ongoingSaves += 1;\n                const currentItems = this.memoryArray();\n                const changes = Object.assign({}, saveQueue);\n                saveQueue.added = [];\n                saveQueue.modified = [];\n                saveQueue.removed = [];\n                this.persistenceAdapter.save(currentItems, changes)\n                    .then(() => {\n                    this.emit('persistence.transmitted');\n                }).catch((error) => {\n                    this.emit('persistence.error', error instanceof Error ? error : new Error(error));\n                }).finally(() => {\n                    ongoingSaves -= 1;\n                    isFlushing = false;\n                    flushQueue();\n                    if (ongoingSaves <= 0)\n                        this.emit('persistence.pushCompleted');\n                });\n            };\n            this.on('added', (item) => {\n                if (!isInitialized) {\n                    pendingUpdates.added.push(item);\n                    return;\n                }\n                saveQueue.added.push(item);\n                flushQueue();\n            });\n            this.on('changed', (item) => {\n                if (!isInitialized) {\n                    pendingUpdates.modified.push(item);\n                    return;\n                }\n                saveQueue.modified.push(item);\n                flushQueue();\n            });\n            this.on('removed', (item) => {\n                if (!isInitialized) {\n                    pendingUpdates.removed.push(item);\n                    return;\n                }\n                saveQueue.removed.push(item);\n                flushQueue();\n            });\n            this.persistenceAdapter.register(data => loadPersistentData(data))\n                .then(async () => {\n                if (!this.persistenceAdapter)\n                    throw new Error('Persistence adapter not found');\n                let currentItems = this.memoryArray();\n                await loadPersistentData();\n                while (hasPendingUpdates(pendingUpdates)) {\n                    const added = pendingUpdates.added.splice(0);\n                    const modified = pendingUpdates.modified.splice(0);\n                    const removed = pendingUpdates.removed.splice(0);\n                    currentItems = applyUpdates(this.memoryArray(), { added, modified, removed });\n                    // eslint-disable-next-line no-await-in-loop\n                    await this.persistenceAdapter.save(currentItems, { added, modified, removed })\n                        .then(() => {\n                        this.emit('persistence.transmitted');\n                    });\n                }\n                await loadPersistentData();\n                isInitialized = true;\n                // emit persistence.init in next tick to make\n                // data available before the loading state updates\n                setTimeout(() => this.emit('persistence.init'), 0);\n            })\n                .catch((error) => {\n                this.emit('persistence.error', error instanceof Error ? error : new Error(error));\n            });\n        }\n    }\n    isPulling() {\n        var _a;\n        return (_a = this.isPullingSignal.get()) !== null && _a !== void 0 ? _a : false;\n    }\n    isPushing() {\n        var _a;\n        return (_a = this.isPushingSignal.get()) !== null && _a !== void 0 ? _a : false;\n    }\n    isLoading() {\n        const isPulling = this.isPulling();\n        const isPushing = this.isPushing();\n        return isPulling || isPushing;\n    }\n    getDebugMode() {\n        return this.debugMode;\n    }\n    setDebugMode(enable) {\n        this.debugMode = enable;\n    }\n    profile(fn, measureFunction) {\n        if (!this.debugMode)\n            return fn();\n        const startTime = performance.now();\n        const result = fn();\n        const endTime = performance.now();\n        measureFunction(endTime - startTime);\n        return result;\n    }\n    executeInDebugMode(fn) {\n        if (!this.debugMode)\n            return;\n        const callstack = new Error().stack || '';\n        fn(callstack);\n    }\n    rebuildIndices() {\n        this.indicesOutdated = true;\n        if (this.batchOperationInProgress)\n            return;\n        this.rebuildAllIndices();\n    }\n    rebuildAllIndices() {\n        this.idIndex.clear();\n        // eslint-disable-next-line array-callback-return\n        this.memory().map((item, index) => {\n            this.idIndex.set(serializeValue(item.id), new Set([index]));\n        });\n        this.indexProviders.forEach(index => index.rebuild(this.memoryArray()));\n        this.indicesOutdated = false;\n    }\n    getIndexInfo(selector) {\n        if (selector != null\n            && Object.keys(selector).length === 1\n            && 'id' in selector\n            && typeof selector.id !== 'object') {\n            return {\n                matched: true,\n                positions: Array.from(this.idIndex.get(serializeValue(selector.id)) || []),\n                optimizedSelector: {},\n            };\n        }\n        if (selector == null || this.indicesOutdated) {\n            return {\n                matched: false,\n                positions: [],\n                optimizedSelector: {},\n            };\n        }\n        return getIndexInfo(this.indexProviders, selector);\n    }\n    getItemAndIndex(selector) {\n        const memory = this.memoryArray();\n        const indexInfo = this.getIndexInfo(selector);\n        const items = indexInfo.matched\n            ? indexInfo.positions.map(index => memory[index])\n            : memory;\n        const item = items.find(doc => match(doc, selector));\n        const index = (indexInfo.matched\n            && indexInfo.positions.find(itemIndex => memory[itemIndex] === item))\n            || memory.findIndex(doc => doc === item);\n        if (item == null)\n            return { item: null, index: -1 };\n        if (index === -1)\n            throw new Error('Cannot resolve index for item');\n        return { item, index };\n    }\n    deleteFromIdIndex(id, index) {\n        this.idIndex.delete(serializeValue(id));\n        // offset all indices after the deleted item -1, but only during batch operations\n        if (!this.batchOperationInProgress)\n            return;\n        this.idIndex.forEach(([currenIndex], key) => {\n            if (currenIndex > index) {\n                this.idIndex.set(key, new Set([currenIndex - 1]));\n            }\n        });\n    }\n    memory() {\n        return this.options.memory;\n    }\n    memoryArray() {\n        return this.memory().map(item => item);\n    }\n    transform(item) {\n        if (!this.options.transform)\n            return item;\n        return this.options.transform(item);\n    }\n    getItems(selector) {\n        return this.profile(() => {\n            const indexInfo = this.getIndexInfo(selector);\n            const matchItems = (item) => {\n                if (indexInfo.optimizedSelector == null)\n                    return true; // if no selector is given, return all items\n                if (Object.keys(indexInfo.optimizedSelector).length <= 0)\n                    return true; // if selector is empty, return all items\n                const matches = match(item, indexInfo.optimizedSelector);\n                return matches;\n            };\n            // no index available, use complete memory\n            if (!indexInfo.matched)\n                return this.memory().filter(matchItems);\n            const memory = this.memoryArray();\n            const items = indexInfo.positions.map(index => memory[index]);\n            this.emit('getItems', selector);\n            return items.filter(matchItems);\n        }, measuredTime => this.executeInDebugMode(callstack => this.emit('_debug.getItems', callstack, selector, measuredTime)));\n    }\n    /**\n     * Disposes the collection, runs the dispose method of the persistence adapter\n     * and clears all internal data structures.\n     */\n    async dispose() {\n        var _a;\n        if ((_a = this.persistenceAdapter) === null || _a === void 0 ? void 0 : _a.unregister)\n            await this.persistenceAdapter.unregister();\n        this.persistenceAdapter = null;\n        this.memory().map(() => this.memory().pop());\n        this.idIndex.clear();\n        this.indexProviders = [];\n        this.isDisposed = true;\n    }\n    find(selector, options) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        if (selector !== undefined && (!selector || typeof selector !== 'object'))\n            throw new Error('Invalid selector');\n        const cursor = new Cursor(() => this.getItems(selector), Object.assign(Object.assign({ reactive: this.options.reactivity }, options), { transform: this.transform.bind(this), bindEvents: (requery) => {\n                const handleRequery = () => {\n                    if (this.batchOperationInProgress) {\n                        this.postBatchCallbacks.add(requery);\n                        return;\n                    }\n                    requery();\n                };\n                this.addListener('persistence.received', handleRequery);\n                this.addListener('added', handleRequery);\n                this.addListener('changed', handleRequery);\n                this.addListener('removed', handleRequery);\n                this.emit('observer.created', selector, options);\n                return () => {\n                    this.removeListener('persistence.received', handleRequery);\n                    this.removeListener('added', handleRequery);\n                    this.removeListener('changed', handleRequery);\n                    this.removeListener('removed', handleRequery);\n                    this.emit('observer.disposed', selector, options);\n                };\n            } }));\n        this.emit('find', selector, options, cursor);\n        this.executeInDebugMode(callstack => this.emit('_debug.find', callstack, selector, options, cursor));\n        return cursor;\n    }\n    findOne(selector, options) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        const cursor = this.find(selector, Object.assign({ limit: 1 }, options));\n        const returnValue = cursor.fetch()[0] || undefined;\n        this.emit('findOne', selector, options, returnValue);\n        this.executeInDebugMode(callstack => this.emit('_debug.findOne', callstack, selector, options, returnValue));\n        return returnValue;\n    }\n    batch(callback) {\n        this.batchOperationInProgress = true;\n        callback();\n        this.batchOperationInProgress = false;\n        // rebuild indiices as they are not rebuilt during batch operations\n        this.rebuildAllIndices();\n        // execute all post batch callbacks\n        this.postBatchCallbacks.forEach(cb => cb());\n        this.postBatchCallbacks.clear();\n    }\n    insert(item) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        if (!item)\n            throw new Error('Invalid item');\n        const newItem = Object.assign({ id: randomId() }, item);\n        if (this.idIndex.has(serializeValue(newItem.id)))\n            throw new Error('Item with same id already exists');\n        this.memory().push(newItem);\n        const itemIndex = this.memory().findIndex(doc => doc === newItem);\n        this.idIndex.set(serializeValue(newItem.id), new Set([itemIndex]));\n        this.rebuildIndices();\n        this.emit('added', newItem);\n        this.emit('insert', newItem);\n        this.executeInDebugMode(callstack => this.emit('_debug.insert', callstack, newItem));\n        return newItem.id;\n    }\n    insertMany(items) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        if (!items)\n            throw new Error('Invalid items');\n        if (items.length === 0) {\n            return [];\n        }\n        const ids = [];\n        this.batch(() => {\n            items.forEach((item) => {\n                ids.push(this.insert(item));\n            });\n        });\n        return ids;\n    }\n    updateOne(selector, modifier) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        if (!selector)\n            throw new Error('Invalid selector');\n        if (!modifier)\n            throw new Error('Invalid modifier');\n        const { item, index } = this.getItemAndIndex(selector);\n        if (item == null)\n            return 0;\n        const modifiedItem = modify(deepClone(item), modifier);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        const existingItem = this.findOne({ id: modifiedItem.id }, { reactive: false });\n        if (!isEqual(existingItem, Object.assign(Object.assign({}, existingItem), { id: modifiedItem.id })))\n            throw new Error('Item with same id already exists');\n        this.memory().splice(index, 1, modifiedItem);\n        this.rebuildIndices();\n        this.emit('changed', modifiedItem, modifier);\n        this.emit('updateOne', selector, modifier);\n        this.executeInDebugMode(callstack => this.emit('_debug.updateOne', callstack, selector, modifier));\n        return 1;\n    }\n    updateMany(selector, modifier) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        if (!selector)\n            throw new Error('Invalid selector');\n        if (!modifier)\n            throw new Error('Invalid modifier');\n        const items = this.getItems(selector);\n        const modifiedItems = [];\n        items.forEach((item) => {\n            const { index } = this.getItemAndIndex({ id: item.id });\n            if (index === -1)\n                throw new Error('Cannot resolve index for item');\n            const modifiedItem = modify(deepClone(item), modifier);\n            this.memory().splice(index, 1, modifiedItem);\n            modifiedItems.push(modifiedItem);\n        });\n        this.rebuildIndices();\n        modifiedItems.forEach((modifiedItem) => {\n            this.emit('changed', modifiedItem, modifier);\n        });\n        this.emit('updateMany', selector, modifier);\n        this.executeInDebugMode(callstack => this.emit('_debug.updateMany', callstack, selector, modifier));\n        return modifiedItems.length;\n    }\n    removeOne(selector) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        if (!selector)\n            throw new Error('Invalid selector');\n        const { item, index } = this.getItemAndIndex(selector);\n        if (item != null) {\n            this.memory().splice(index, 1);\n            this.deleteFromIdIndex(item.id, index);\n            this.rebuildIndices();\n            this.emit('removed', item);\n        }\n        this.emit('removeOne', selector);\n        this.executeInDebugMode(callstack => this.emit('_debug.removeOne', callstack, selector));\n        return item == null ? 0 : 1;\n    }\n    removeMany(selector) {\n        if (this.isDisposed)\n            throw new Error('Collection is disposed');\n        if (!selector)\n            throw new Error('Invalid selector');\n        const items = this.getItems(selector);\n        items.forEach((item) => {\n            const index = this.memory().findIndex(doc => doc === item);\n            if (index === -1)\n                throw new Error('Cannot resolve index for item');\n            this.memory().splice(index, 1);\n            this.deleteFromIdIndex(item.id, index);\n            this.rebuildIndices();\n        });\n        items.forEach((item) => {\n            this.emit('removed', item);\n        });\n        this.emit('removeMany', selector);\n        this.executeInDebugMode(callstack => this.emit('_debug.removeMany', callstack, selector));\n        return items.length;\n    }\n}\nCollection.collections = [];\nCollection.debugMode = false;\nCollection.batchOperationInProgress = false;\nCollection.enableDebugMode = () => {\n    Collection.debugMode = true;\n    Collection.collections.forEach((collection) => {\n        collection.setDebugMode(true);\n    });\n};\nexport default Collection;\n","export default function createPersistenceAdapter(definition) {\n    return definition;\n}\n","import createPersistenceAdapter from './createPersistenceAdapter';\nexport default function createLocalStorageAdapter(name, options) {\n    const { serialize = JSON.stringify, deserialize = JSON.parse } = options || {};\n    const collectionId = `signaldb-collection-${name}`;\n    function getItems() {\n        return deserialize(localStorage.getItem(collectionId) || '[]');\n    }\n    return createPersistenceAdapter({\n        async load() {\n            const items = getItems();\n            return Promise.resolve({ items });\n        },\n        async save(items, { added, modified, removed }) {\n            const currentItems = getItems();\n            added.forEach((item) => {\n                currentItems.push(item);\n            });\n            modified.forEach((item) => {\n                const index = currentItems.findIndex(({ id }) => id === item.id);\n                /* istanbul ignore if -- @preserve */\n                if (index === -1)\n                    throw new Error(`Item with ID ${item.id} not found`);\n                currentItems[index] = item;\n            });\n            removed.forEach((item) => {\n                const index = currentItems.findIndex(({ id }) => id === item.id);\n                /* istanbul ignore if -- @preserve */\n                if (index === -1)\n                    throw new Error(`Item with ID ${item.id} not found`);\n                currentItems.splice(index, 1);\n            });\n            localStorage.setItem(collectionId, serialize(currentItems));\n            return Promise.resolve();\n        },\n        async register() {\n            return Promise.resolve();\n        },\n    });\n}\n","import createPersistenceAdapter from './createPersistenceAdapter';\nexport default function createFilesystemAdapter(filename, options) {\n    const { serialize = JSON.stringify, deserialize = JSON.parse } = options || {};\n    let savePromise = null;\n    async function getItems() {\n        const fs = await import('fs');\n        const exists = await fs.promises.access(filename).then(() => true).catch(() => false);\n        if (!exists)\n            return [];\n        const contents = await fs.promises.readFile(filename, 'utf8').catch((err) => {\n            /* istanbul ignore next -- @preserve */\n            if (err.code === 'ENOENT')\n                return '[]';\n            /* istanbul ignore next -- @preserve */\n            throw err;\n        });\n        return deserialize(contents);\n    }\n    return createPersistenceAdapter({\n        async register(onChange) {\n            if (typeof window !== 'undefined')\n                throw new Error('Filesystem adapter is not supported in the browser');\n            const fs = await import('fs');\n            const exists = await fs.promises.access(filename).then(() => true).catch(() => false);\n            if (!exists)\n                await fs.promises.writeFile(filename, '[]');\n            fs.watch(filename, { encoding: 'utf8' }, () => {\n                void onChange();\n            });\n        },\n        async load() {\n            if (typeof window !== 'undefined')\n                throw new Error('Filesystem adapter is not supported in the browser');\n            if (savePromise)\n                await savePromise;\n            const items = await getItems();\n            return { items };\n        },\n        async save(_items, { added, modified, removed }) {\n            if (typeof window !== 'undefined')\n                throw new Error('Filesystem adapter is not supported in the browser');\n            if (savePromise)\n                await savePromise;\n            savePromise = getItems()\n                .then((currentItems) => {\n                const items = currentItems.slice();\n                added.forEach((item) => {\n                    items.push(item);\n                });\n                modified.forEach((item) => {\n                    const index = items.findIndex(({ id }) => id === item.id);\n                    /* istanbul ignore if -- @preserve */\n                    if (index === -1)\n                        throw new Error(`Item with ID ${item.id} not found`);\n                    items[index] = item;\n                });\n                removed.forEach((item) => {\n                    const index = items.findIndex(({ id }) => id === item.id);\n                    /* istanbul ignore if -- @preserve */\n                    if (index === -1)\n                        throw new Error(`Item with ID ${item.id} not found`);\n                    items.splice(index, 1);\n                });\n                return items;\n            })\n                .then(async (items) => {\n                const fs = await import('fs');\n                await fs.promises.writeFile(filename, serialize(items));\n            })\n                .then(() => {\n                savePromise = null;\n            });\n            await savePromise;\n        },\n    });\n}\n","import Collection from './Collection';\nimport createLocalStorageAdapter from './persistence/createLocalStorageAdapter';\nimport createFilesystemAdapter from './persistence/createFilesystemAdapter';\nfunction createAdapter(name) {\n    if (typeof window === 'undefined') { // server side\n        return createFilesystemAdapter(`persistent-collection-${name}.json`);\n    }\n    return createLocalStorageAdapter(name);\n}\n// eslint-disable-next-line max-len\nexport default class PersistentCollection extends Collection {\n    constructor(name, options) {\n        super(Object.assign({ persistence: createAdapter(name) }, options));\n    }\n}\n","import createPersistenceAdapter from './createPersistenceAdapter';\nexport function createTemporaryFallbackExecutor(firstResolvingPromiseFn, secondResolvingPromiseFn, options) {\n    var _a;\n    const cacheTimeout = (_a = options === null || options === void 0 ? void 0 : options.cacheTimeout) !== null && _a !== void 0 ? _a : 0;\n    let isResolved = false;\n    let resolvedValue = null;\n    let timeout = null;\n    let secondaryPromise = null;\n    return (...args) => {\n        if (secondaryPromise == null) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            secondaryPromise = secondResolvingPromiseFn(...args).then((result) => {\n                if (cacheTimeout > 0) {\n                    timeout = setTimeout(() => {\n                        isResolved = false;\n                        resolvedValue = null;\n                        secondaryPromise = null;\n                    }, cacheTimeout);\n                }\n                isResolved = true;\n                resolvedValue = result;\n                if (options === null || options === void 0 ? void 0 : options.onResolve)\n                    options.onResolve(resolvedValue);\n                return result;\n            });\n        }\n        else if (isResolved) {\n            return secondaryPromise;\n        }\n        return firstResolvingPromiseFn(...args);\n    };\n}\nexport default function combinePersistenceAdapters(primary, secondary, options) {\n    var _a;\n    const readPreference = (_a = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _a !== void 0 ? _a : 'secondary';\n    const primaryAdapter = readPreference === 'primary' ? primary : secondary;\n    const secondaryAdapter = readPreference === 'primary' ? secondary : primary;\n    let handleChange = null;\n    const readExecutor = createTemporaryFallbackExecutor(() => primaryAdapter.load(), () => secondaryAdapter.load(), {\n        cacheTimeout: 100,\n        onResolve: (result) => {\n            var _a, _b, _c;\n            if (handleChange)\n                void handleChange();\n            void primaryAdapter.save(result.items || [], {\n                added: ((_a = result.changes) === null || _a === void 0 ? void 0 : _a.added) || [],\n                modified: ((_b = result.changes) === null || _b === void 0 ? void 0 : _b.modified) || [],\n                removed: ((_c = result.changes) === null || _c === void 0 ? void 0 : _c.removed) || [],\n            });\n        },\n    });\n    return createPersistenceAdapter({\n        async register(onChange) {\n            handleChange = onChange;\n            await Promise.all([primary.register(onChange), secondary.register(onChange)]);\n        },\n        async load() {\n            const promise = readExecutor();\n            return promise;\n        },\n        async save(items, changes) {\n            await Promise.all([\n                primaryAdapter.save(items, changes),\n                secondaryAdapter.save(items, changes),\n            ]);\n        },\n    });\n}\n","import Collection from './Collection';\nimport combinePersistenceAdapters from './persistence/combinePersistenceAdapters';\nimport createPersistenceAdapter from './persistence/createPersistenceAdapter';\nimport createSignal from './utils/createSignal';\nexport function createReplicationAdapter(options) {\n    return createPersistenceAdapter({\n        async register(onChange) {\n            if (!options.registerRemoteChange)\n                return;\n            await options.registerRemoteChange(onChange);\n        },\n        load: () => options.pull(),\n        save: (items, changes) => {\n            if (!options.push)\n                throw new Error('Pushing is not configured for this collection. Try to pass a `push` function to the collection options.');\n            return options.push(changes, items);\n        },\n    });\n}\nexport default class ReplicatedCollection extends Collection {\n    constructor(options) {\n        var _a, _b;\n        const replicationAdapter = createReplicationAdapter({\n            registerRemoteChange: options.registerRemoteChange,\n            pull: async () => {\n                this.isPullingRemoteSignal.set(true);\n                try {\n                    return await options.pull();\n                }\n                finally {\n                    this.isPullingRemoteSignal.set(false);\n                }\n            },\n            push: options.push ? (async (changes, items) => {\n                if (!options.push)\n                    throw new Error('Pushing is not configured for this collection. Try to pass a `push` function to the collection options.');\n                this.isPushingRemoteSignal.set(true);\n                try {\n                    await options.push(changes, items);\n                }\n                finally {\n                    this.isPushingRemoteSignal.set(false);\n                }\n            }) : undefined,\n        });\n        const persistenceAdapter = (options === null || options === void 0 ? void 0 : options.persistence)\n            ? combinePersistenceAdapters(replicationAdapter, options.persistence)\n            : replicationAdapter;\n        super(Object.assign(Object.assign({}, options), { persistence: persistenceAdapter }));\n        this.isPullingRemoteSignal = createSignal((_a = options.reactivity) === null || _a === void 0 ? void 0 : _a.create(), false);\n        this.isPushingRemoteSignal = createSignal((_b = options.reactivity) === null || _b === void 0 ? void 0 : _b.create(), false);\n    }\n    isLoading() {\n        const isPullingRemote = this.isPullingRemoteSignal.get();\n        const isPushingRemote = this.isPushingRemoteSignal.get();\n        const isLoading = super.isLoading();\n        return isPullingRemote || isPushingRemote || isLoading;\n    }\n}\n","import ReplicatedCollection from './ReplicatedCollection';\nimport createSignal from './utils/createSignal';\n/**\n * @summary A special collection that automatically fetches items when they are needed.\n */\nexport default class AutoFetchCollection extends ReplicatedCollection {\n    /**\n     * @param options {Object} - Options for the collection.\n     * @param options.fetchQueryItems {Function} - A function that fetches items from the server. It takes the selector as an argument and returns a promise that resolves to an object with an `items` property.\n     * @param options.purgeDelay {Number} - The delay in milliseconds before purging an item from the cache.\n     */\n    constructor(options) {\n        var _a, _b, _c, _d;\n        let triggerRemoteChange;\n        super(Object.assign(Object.assign({}, options), { pull: () => Promise.resolve({\n                items: [...this.itemsCache.values()].reduce((memo, items) => {\n                    const newItems = [...memo];\n                    items.forEach((item) => {\n                        const index = newItems.findIndex(i => i.id === item.id);\n                        if (index === -1) {\n                            newItems.push(item);\n                            return;\n                        }\n                        newItems[index] = this.mergeItems(newItems[index], item);\n                    });\n                    return newItems;\n                }, []),\n            }), registerRemoteChange: async (onChange) => {\n                triggerRemoteChange = onChange;\n                return Promise.resolve();\n            } }));\n        this.activeObservers = new Map();\n        this.observerTimeouts = new Map();\n        this.idQueryCache = new Map();\n        this.itemsCache = new Map();\n        this.triggerReload = null;\n        this.reactivityAdapter = null;\n        this.loadingSignals = new Map();\n        this.mergeItems = (_a = options.mergeItems) !== null && _a !== void 0 ? _a : ((itemA, itemB) => (Object.assign(Object.assign({}, itemA), itemB)));\n        this.purgeDelay = (_b = options.purgeDelay) !== null && _b !== void 0 ? _b : 10000; // 10 seconds\n        this.isFetchingSignal = createSignal((_c = options.reactivity) === null || _c === void 0 ? void 0 : _c.create(), false);\n        if (!triggerRemoteChange)\n            throw new Error('No triggerRemoteChange method found. Looks like your persistence adapter was not registered');\n        this.triggerReload = triggerRemoteChange;\n        this.reactivityAdapter = (_d = options.reactivity) !== null && _d !== void 0 ? _d : null;\n        this.fetchQueryItems = options.fetchQueryItems;\n        this.on('observer.created', selector => this.handleObserverCreation(selector !== null && selector !== void 0 ? selector : {}));\n        this.on('observer.disposed', selector => setTimeout(() => this.handleObserverDisposal(selector !== null && selector !== void 0 ? selector : {}), 100));\n        if (options.registerRemoteChange) {\n            void options.registerRemoteChange(() => this.forceRefetch());\n        }\n    }\n    /**\n     * @summary Registers a query manually that items should be fetched for it\n     * @param selector {Object} Selector of the query\n     */\n    registerQuery(selector) {\n        this.handleObserverCreation(selector);\n    }\n    /**\n     * @summary Unregisters a query manually that items are not fetched anymore for it\n     * @param selector {Object} Selector of the query\n     */\n    unregisterQuery(selector) {\n        this.handleObserverDisposal(selector);\n    }\n    // eslint-disable-next-line class-methods-use-this\n    getKeyForSelector(selector) {\n        return JSON.stringify(selector);\n    }\n    async forceRefetch() {\n        return Promise.all([...this.activeObservers.values()].map(({ selector }) => this.fetchSelector(selector))).then(() => { });\n    }\n    fetchSelector(selector) {\n        this.isFetchingSignal.set(true);\n        return this.fetchQueryItems(selector)\n            .then((response) => {\n            if (!response.items)\n                throw new Error('AutoFetchCollection currently only works with a full item response');\n            // merge the response into the cache\n            this.itemsCache.set(this.getKeyForSelector(selector), response.items);\n            response.items.forEach((item) => {\n                var _a;\n                const queries = (_a = this.idQueryCache.get(item.id)) !== null && _a !== void 0 ? _a : [];\n                queries.push(selector);\n                this.idQueryCache.set(item.id, queries);\n            });\n            this.setLoading(selector, true);\n            this.once('persistence.received', () => {\n                this.setLoading(selector, false);\n            });\n            if (!this.triggerReload)\n                throw new Error('No triggerReload method found. Looks like your persistence adapter was not registered');\n            void this.triggerReload();\n        })\n            .catch((error) => {\n            this.emit('persistence.error', error);\n        })\n            .finally(() => {\n            this.isFetchingSignal.set(false);\n        });\n    }\n    handleObserverCreation(selector) {\n        var _a, _b;\n        const activeObservers = (_b = (_a = this.activeObservers.get(this.getKeyForSelector(selector))) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0;\n        // increment the count of observers for this query\n        this.activeObservers.set(this.getKeyForSelector(selector), {\n            selector,\n            count: activeObservers + 1,\n        });\n        const timeout = this.observerTimeouts.get(this.getKeyForSelector(selector));\n        if (timeout)\n            clearTimeout(timeout);\n        // if this is the first observer for this query, fetch the data\n        if (activeObservers === 0)\n            void this.fetchSelector(selector);\n    }\n    handleObserverDisposal(selector) {\n        var _a, _b;\n        // decrement the count of observers for this query\n        const currentObservers = (_b = (_a = this.activeObservers.get(this.getKeyForSelector(selector))) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0;\n        const activeObservers = currentObservers - 1;\n        if (activeObservers > 0) {\n            this.activeObservers.set(this.getKeyForSelector(selector), {\n                selector,\n                count: activeObservers,\n            });\n            return;\n        }\n        const timeout = this.observerTimeouts.get(this.getKeyForSelector(selector));\n        if (timeout)\n            clearTimeout(timeout);\n        const removeObserver = () => {\n            // if this is the last observer for this query and the purge delay was passed, remove the query from the cache\n            this.activeObservers.delete(this.getKeyForSelector(selector));\n            // remove items for query from the cache\n            this.itemsCache.delete(this.getKeyForSelector(selector));\n            if (!this.triggerReload)\n                throw new Error('No triggerReload method found. Looks like your persistence adapter was not registered');\n            void this.triggerReload();\n        };\n        if (this.purgeDelay === 0) {\n            // remove the query from the cache immediately\n            removeObserver();\n            return;\n        }\n        this.observerTimeouts.set(this.getKeyForSelector(selector), setTimeout(removeObserver, this.purgeDelay));\n    }\n    ensureSignal(selector) {\n        if (!this.reactivityAdapter)\n            throw new Error('No reactivity adapter found');\n        if (!this.loadingSignals.has(this.getKeyForSelector(selector))) {\n            this.loadingSignals.set(this.getKeyForSelector(selector), createSignal(this.reactivityAdapter.create(), false));\n        }\n        return this.loadingSignals.get(this.getKeyForSelector(selector));\n    }\n    setLoading(selector, value) {\n        const signal = this.ensureSignal(selector);\n        signal.set(value);\n    }\n    /**\n     * @summary Indicates wether a query is currently been loaded\n     * @param selector {Object} Selector of the query\n     * @returns The loading state\n     */\n    isLoading(selector) {\n        const isPushing = this.isPushing();\n        if (!selector) {\n            return this.isFetchingSignal.get() || isPushing;\n        }\n        const signal = this.ensureSignal(selector);\n        return signal.get() || isPushing;\n    }\n}\n","import createPersistenceAdapter from './createPersistenceAdapter';\nexport default function createOPFSAdapter(filename, options) {\n    const { serialize = JSON.stringify, deserialize = JSON.parse } = options || {};\n    let savePromise = null;\n    async function getItems() {\n        const opfsRoot = await navigator.storage.getDirectory();\n        const existingFileHandle = await opfsRoot.getFileHandle(filename, { create: true });\n        const contents = await existingFileHandle.getFile().then(val => val.text());\n        return deserialize(contents || '[]');\n    }\n    return createPersistenceAdapter({\n        async register(onChange) {\n            const opfsRoot = await navigator.storage.getDirectory();\n            await opfsRoot.getFileHandle(filename, { create: true });\n            void onChange();\n        },\n        async load() {\n            if (savePromise)\n                await savePromise;\n            const items = await getItems();\n            return { items };\n        },\n        async save(_items, { added, modified, removed }) {\n            if (savePromise)\n                await savePromise;\n            const opfsRoot = await navigator.storage.getDirectory();\n            const existingFileHandle = await opfsRoot.getFileHandle(filename, { create: true });\n            if (added.length === 0 && modified.length === 0 && removed.length === 0) {\n                const writeStream = await existingFileHandle.createWritable();\n                await writeStream.write(serialize(_items));\n                await writeStream.close();\n                await savePromise;\n                return;\n            }\n            savePromise = getItems()\n                .then((currentItems) => {\n                const items = currentItems.slice();\n                added.forEach((item) => {\n                    items.push(item);\n                });\n                modified.forEach((item) => {\n                    const index = items.findIndex(({ id }) => id === item.id);\n                    /* istanbul ignore if -- @preserve */\n                    if (index === -1)\n                        throw new Error(`Item with ID ${item.id} not found`);\n                    items[index] = item;\n                });\n                removed.forEach((item) => {\n                    const index = items.findIndex(({ id }) => id === item.id);\n                    /* istanbul ignore if -- @preserve */\n                    if (index === -1)\n                        throw new Error(`Item with ID ${item.id} not found`);\n                    items.splice(index, 1);\n                });\n                return items;\n            })\n                .then(async (items) => {\n                const writeStream = await existingFileHandle.createWritable();\n                await writeStream.write(serialize(items));\n                await writeStream.close();\n            })\n                .then(() => {\n                savePromise = null;\n            });\n            await savePromise;\n        },\n    });\n}\n","export default function createMemoryAdapter(definition) {\n    return definition;\n}\n","export default function createReactivityAdapter(definition) {\n    return definition;\n}\n","/**\n * Debounces a function.\n * @param func Function to debounce\n * @param wait Time to wait before calling the function.\n * @param [options] Debounce options\n * @param [options.leading] Whether to call the function on the leading edge of the wait interval.\n * @param [options.trailing] Whether to call the function on the trailing edge of the wait interval.\n * @returns The debounced function.\n */\nexport default function debounce(func, wait, options = {}) {\n    let timeout;\n    let result;\n    const { leading = false, trailing = true } = options;\n    function debounced(...args) {\n        const shouldCallImmediately = leading && !timeout;\n        const shouldCallTrailing = trailing && !timeout;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n            timeout = null;\n            if (trailing && !shouldCallImmediately) {\n                result = func.apply(this, args);\n            }\n        }, wait);\n        if (shouldCallImmediately) {\n            result = func.apply(this, args);\n        }\n        else if (!shouldCallTrailing) {\n            result = null;\n        }\n        return result;\n    }\n    return debounced;\n}\n","/**\n * Class for queuing promises to be executed one after the other.\n * This is useful for tasks that should not be executed in parallel.\n * @example\n * const queue = new PromiseQueue();\n * queue.add(() => fetch('https://example.com/api/endpoint1'));\n * queue.add(() => fetch('https://example.com/api/endpoint2'));\n * // The second fetch will only be executed after the first one is done.\n */\nexport default class PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.pendingPromise = false;\n    }\n    /**\n     * Method to add a new promise to the queue and returns a promise that resolves when this task is done\n     * @param task Function that returns a promise that will be added to the queue\n     * @returns Promise that resolves when the task is done\n     */\n    add(task) {\n        return new Promise((resolve, reject) => {\n            // Wrap the task with the resolve and reject to control its completion from the outside\n            this.queue.push(() => task()\n                .then(resolve)\n                .catch((error) => {\n                reject(error);\n                throw error;\n            }));\n            this.dequeue();\n        });\n    }\n    /**\n     * Method to check if there is a pending promise in the queue\n     * @returns True if there is a pending promise, false otherwise\n     */\n    hasPendingPromise() {\n        return this.pendingPromise;\n    }\n    /**\n     * Method to process the queue\n     */\n    dequeue() {\n        if (this.pendingPromise || this.queue.length === 0) {\n            return;\n        }\n        const task = this.queue.shift();\n        if (!task)\n            return;\n        this.pendingPromise = true;\n        task()\n            .then(() => {\n            this.pendingPromise = false;\n            this.dequeue();\n        })\n            .catch(() => {\n            this.pendingPromise = false;\n            this.dequeue();\n        });\n    }\n}\n","import isEqual from '../utils/isEqual';\n/**\n * Compute changes between two arrays of items.\n * @param oldItems Array of the old items\n * @param newItems Array of the new items\n * @returns The changeset\n */\nexport default function computeChanges(oldItems, newItems) {\n    const added = [];\n    const modified = [];\n    const removed = [];\n    const oldItemsMap = new Map(oldItems.map(item => [item.id, item]));\n    const newItemsMap = new Map(newItems.map(item => [item.id, item]));\n    for (const [id, oldItem] of oldItemsMap) {\n        const newItem = newItemsMap.get(id);\n        if (!newItem) {\n            removed.push(oldItem);\n        }\n        else if (!isEqual(newItem, oldItem)) {\n            modified.push(newItem);\n        }\n    }\n    for (const [id, newItem] of newItemsMap) {\n        if (!oldItemsMap.has(id)) {\n            added.push(newItem);\n        }\n    }\n    return { added, modified, removed };\n}\n","/**\n * Gets the snapshot of items from the last snapshot and the changes.\n * @param lastSnapshot The last snapshot of items\n * @param data The changes to apply to the last snapshot\n * @returns The new snapshot of items\n */\nexport default function getSnapshot(lastSnapshot, data) {\n    if (data.items != null)\n        return data.items;\n    const items = lastSnapshot || [];\n    data.changes.added.forEach(item => items.push(item));\n    data.changes.modified.forEach((item) => {\n        const index = items.findIndex(i => i.id === item.id);\n        if (index !== -1)\n            items[index] = item;\n    });\n    data.changes.removed.forEach((item) => {\n        const index = items.findIndex(i => i.id === item.id);\n        if (index !== -1)\n            items.splice(index, 1);\n    });\n    return items;\n}\n","import Collection from '../Collection';\nimport modify from '../utils/modify';\n/**\n * applies changes to a collection of items\n * @param items The items to apply the changes to\n * @param changes The changes to apply to the items\n * @returns The new items after applying the changes\n */\nexport default function applyChanges(items, changes) {\n    const collection = new Collection();\n    collection.batch(() => {\n        items.forEach(item => collection.insert(item));\n        changes.forEach((change) => {\n            if (change.type === 'remove') {\n                collection.removeOne({ id: change.data });\n                return;\n            }\n            const selector = { id: change.data.id };\n            const itemExists = collection.findOne(selector);\n            if (change.type === 'insert') {\n                if (itemExists) { // update item if it alread exists\n                    collection.updateOne(selector, { $set: change.data });\n                }\n                else { // insert item if it does not exist\n                    collection.insert(change.data);\n                }\n                return;\n            }\n            // change.type === 'update'\n            if (itemExists) { // update item if it exists\n                collection.updateOne(selector, change.data.modifier);\n            }\n            else { // insert item if it does not exist\n                collection.insert(modify(selector, change.data.modifier));\n            }\n        });\n    });\n    return collection.find().fetch();\n}\n","import computeChanges from './computeChanges';\nimport getSnapshot from './getSnapshot';\nimport applyChanges from './applyChanges';\nfunction hasChanges(changes) {\n    return changes.added.length > 0\n        || changes.modified.length > 0\n        || changes.removed.length > 0;\n}\nfunction hasDifference(oldItems, newItems) {\n    return hasChanges(computeChanges(oldItems, newItems));\n}\n/**\n * Does a sync operation based on the provided options. If changes are supplied, these will be rebased on the new data.\n * Afterwards the push method will be called with the remaining changes. A new snapshot will be created and returned.\n * @param options Sync options\n * @param options.changes Changes to call the push method with\n * @param [options.lastSnapshot] The last snapshot\n * @param options.data The new data\n * @param options.pull Method to pull new data\n * @param options.push Method to push changes\n * @param options.insert Method to insert an item\n * @param options.update Method to update an item\n * @param options.remove Method to remove an item\n * @param options.batch Method to batch multiple operations\n * @returns The new snapshot\n */\nexport default async function sync({ changes, lastSnapshot, data, pull, push, insert, update, remove, batch, }) {\n    let newData = data;\n    let previousSnapshot = lastSnapshot || [];\n    let newSnapshot = getSnapshot(lastSnapshot, newData);\n    if (changes.length > 0) {\n        // apply changes on last snapshot and check if there is a difference\n        const lastSnapshotWithChanges = applyChanges(previousSnapshot, changes);\n        if (hasDifference(previousSnapshot, lastSnapshotWithChanges)) {\n            // if yes, apply the changes on the newSnapshot and check if there is a difference\n            const newSnapshotWithChanges = applyChanges(newSnapshot, changes);\n            const changesToPush = computeChanges(newSnapshot, newSnapshotWithChanges);\n            if (hasChanges(changesToPush)) {\n                // if yes, push the changes to the server\n                await push(changesToPush);\n                // pull new data afterwards to ensure that all server changes are applied\n                newData = await pull();\n                newSnapshot = getSnapshot(newSnapshot, newData);\n            }\n            previousSnapshot = lastSnapshotWithChanges;\n        }\n    }\n    // apply the new changes on the collection\n    const newChanges = newData.changes == null\n        ? computeChanges(previousSnapshot, newData.items)\n        : newData.changes;\n    batch(() => {\n        newChanges.added.forEach(item => insert(item));\n        newChanges.modified.forEach(item => update(item.id, { $set: item }));\n        newChanges.removed.forEach(item => remove(item.id));\n    });\n    return newSnapshot;\n}\n","import Collection from '../Collection';\nimport debounce from '../utils/debounce';\nimport PromiseQueue from '../utils/PromiseQueue';\nimport createLocalStorageAdapter from '../persistence/createLocalStorageAdapter';\nimport randomId from '../utils/randomId';\nimport isEqual from '../utils/isEqual';\nimport sync from './sync';\n/**\n * Class to manage syncing of collections.\n * @template CollectionOptions\n * @template ItemType\n * @template IdType\n * @example\n * const syncManager = new SyncManager({\n *    pull: async (collectionOptions) => {\n *      const response = await fetch(`/api/collections/${collectionOptions.name}`)\n *      return await response.json()\n *    },\n *    push: async (collectionOptions, { changes }) => {\n *      await fetch(`/api/collections/${collectionOptions.name}`, {\n *        method: 'POST',\n *        body: JSON.stringify(changes),\n *      })\n *    },\n *  })\n *\n *  const collection = new Collection()\n *  syncManager.addCollection(collection, {\n *    name: 'todos',\n *  })\n *\n *  syncManager.sync('todos')\n */\nexport default class SyncManager {\n    /**\n     * @param options Collection options\n     * @param options.pull Function to pull data from remote source.\n     * @param options.push Function to push data to remote source.\n     * @param [options.registerRemoteChange] Function to register a callback for remote changes.\n     * @param [options.id] Unique identifier for this sync manager. Only nessesary if you have multiple sync managers.\n     * @param [options.persistenceAdapter] Persistence adapter to use for storing changes, snapshots and sync operations.\n     * @param [options.reactivity] Reactivity adapter to use for reactivity.\n     * @param [options.onError] Function to handle errors that occur async during syncing.\n     */\n    constructor(options) {\n        var _a, _b;\n        this.collections = new Map();\n        this.remoteChanges = [];\n        this.syncQueues = new Map();\n        this.isDisposed = false;\n        this.instanceId = randomId();\n        this.deboucedPush = debounce((name) => {\n            this.pushChanges(name).catch(() => { });\n        }, 100);\n        this.options = options;\n        const id = (_a = this.options.id) !== null && _a !== void 0 ? _a : 'default-sync-manager';\n        const { reactivity } = this.options;\n        let changesErrorHandler = () => { };\n        let snapshotsErrorHandler = () => { };\n        let syncOperationsErrorHandler = () => { };\n        const persistenceAdapter = (_b = options.persistenceAdapter) !== null && _b !== void 0 ? _b : createLocalStorageAdapter;\n        const changesPersistenceAdapter = persistenceAdapter(`${id}-changes`, (handler) => {\n            changesErrorHandler = handler;\n        });\n        const snapshotsPersistenceAdapter = persistenceAdapter(`${id}-snapshots`, (handler) => {\n            snapshotsErrorHandler = handler;\n        });\n        const syncOperationsPersistenceAdapter = persistenceAdapter(`${id}-sync-operations`, (handler) => {\n            syncOperationsErrorHandler = handler;\n        });\n        this.changes = new Collection({\n            persistence: changesPersistenceAdapter,\n            reactivity,\n        });\n        this.snapshots = new Collection({\n            persistence: snapshotsPersistenceAdapter,\n            reactivity,\n        });\n        this.syncOperations = new Collection({\n            persistence: syncOperationsPersistenceAdapter,\n            reactivity,\n        });\n        this.changes.on('persistence.error', error => changesErrorHandler(error));\n        this.snapshots.on('persistence.error', error => snapshotsErrorHandler(error));\n        this.syncOperations.on('persistence.error', error => syncOperationsErrorHandler(error));\n        this.persistenceReady = Promise.all([\n            new Promise((resolve, reject) => {\n                this.syncOperations.once('persistence.error', reject);\n                this.syncOperations.once('persistence.init', resolve);\n            }),\n            new Promise((resolve, reject) => {\n                this.changes.once('persistence.error', reject);\n                this.changes.once('persistence.init', resolve);\n            }),\n            new Promise((resolve, reject) => {\n                this.snapshots.once('persistence.error', reject);\n                this.snapshots.once('persistence.init', resolve);\n            }),\n        ]).then(() => { });\n        this.changes.setMaxListeners(1000);\n        this.snapshots.setMaxListeners(1000);\n        this.syncOperations.setMaxListeners(1000);\n    }\n    getSyncQueue(name) {\n        if (this.syncQueues.get(name) == null) {\n            this.syncQueues.set(name, new PromiseQueue());\n        }\n        return this.syncQueues.get(name);\n    }\n    /**\n     * Clears all internal data structures\n     */\n    async dispose() {\n        this.collections.clear();\n        this.syncQueues.clear();\n        this.remoteChanges.splice(0, this.remoteChanges.length);\n        await Promise.all([\n            this.changes.dispose(),\n            this.snapshots.dispose(),\n            this.syncOperations.dispose(),\n        ]);\n        this.isDisposed = true;\n    }\n    /**\n     * Gets a collection with it's options by name\n     * @param name Name of the collection\n     * @throws Will throw an error if the name wasn't found\n     * @returns Tuple of collection and options\n     */\n    getCollection(name) {\n        const entry = this.collections.get(name);\n        if (entry == null)\n            throw new Error(`Collection with id '${name}' not found`);\n        return entry;\n    }\n    /**\n     * Adds a collection to the sync manager.\n     * @param collection Collection to add\n     * @param options Options for the collection. The object needs at least a `name` property.\n     * @param options.name Unique name of the collection\n     */\n    addCollection(collection, options) {\n        if (this.isDisposed)\n            throw new Error('SyncManager is disposed');\n        if (this.options.registerRemoteChange) {\n            this.options.registerRemoteChange(options, async (data) => {\n                if (data == null) {\n                    await this.sync(options.name);\n                }\n                else {\n                    const syncTime = Date.now();\n                    const syncId = this.syncOperations.insert({\n                        start: syncTime,\n                        collectionName: options.name,\n                        instanceId: this.instanceId,\n                        status: 'active',\n                    });\n                    await this.syncWithData(options.name, data)\n                        .then(() => {\n                        // clean up old sync operations\n                        this.syncOperations.removeMany({\n                            id: { $ne: syncId },\n                            collectionName: options.name,\n                            $or: [\n                                { end: { $lte: syncTime } },\n                                { status: 'active' },\n                            ],\n                        });\n                        // update sync operation status to done after everthing was finished\n                        this.syncOperations.updateOne({ id: syncId }, {\n                            $set: { status: 'done', end: Date.now() },\n                        });\n                    })\n                        .catch((error) => {\n                        if (this.options.onError)\n                            this.options.onError(options, error);\n                        this.syncOperations.updateOne({ id: syncId }, {\n                            $set: { status: 'error', end: Date.now(), error: error.stack || error.message },\n                        });\n                        throw error;\n                    });\n                }\n            });\n        }\n        this.collections.set(options.name, [collection, options]);\n        const hasRemoteChange = (change) => {\n            for (const remoteChange of this.remoteChanges) {\n                if (isEqual(remoteChange, change)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        const removeRemoteChange = (change) => {\n            for (let i = 0; i < this.remoteChanges.length; i += 1) {\n                if (isEqual(this.remoteChanges[i], change)) {\n                    this.remoteChanges.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        collection.on('added', (item) => {\n            // skip the change if it was a remote change\n            if (hasRemoteChange({ collectionName: options.name, type: 'insert', data: item })) {\n                removeRemoteChange({ collectionName: options.name, type: 'insert', data: item });\n                return;\n            }\n            this.changes.insert({\n                collectionName: options.name,\n                time: Date.now(),\n                type: 'insert',\n                data: item,\n            });\n            this.schedulePush(options.name);\n        });\n        collection.on('changed', ({ id }, modifier) => {\n            const data = { id, modifier };\n            // skip the change if it was a remote change\n            if (hasRemoteChange({ collectionName: options.name, type: 'update', data })) {\n                removeRemoteChange({ collectionName: options.name, type: 'update', data });\n                return;\n            }\n            this.changes.insert({\n                collectionName: options.name,\n                time: Date.now(),\n                type: 'update',\n                data,\n            });\n            this.schedulePush(options.name);\n        });\n        collection.on('removed', ({ id }) => {\n            // skip the change if it was a remote change\n            if (hasRemoteChange({ collectionName: options.name, type: 'remove', data: id })) {\n                removeRemoteChange({ collectionName: options.name, type: 'remove', data: id });\n                return;\n            }\n            this.changes.insert({\n                collectionName: options.name,\n                time: Date.now(),\n                type: 'remove',\n                data: id,\n            });\n            this.schedulePush(options.name);\n        });\n    }\n    schedulePush(name) {\n        this.deboucedPush(name);\n    }\n    /**\n     * Starts the sync process for all collections\n     */\n    async syncAll() {\n        if (this.isDisposed)\n            throw new Error('SyncManager is disposed');\n        const errors = [];\n        await Promise.all([...this.collections.keys()].map(id => this.sync(id).catch((error) => {\n            errors.push({ id, error });\n        })));\n        if (errors.length > 0)\n            throw new Error(`Error while syncing collections:\\n${errors.map(e => `${e.id}: ${e.error.message}`).join('\\n\\n')}`);\n    }\n    /**\n     * Checks if a collection is currently beeing synced\n     * @param [name] Name of the collection. If not provided, it will check if any collection is currently beeing synced.\n     * @returns True if the collection is currently beeing synced, false otherwise.\n     */\n    isSyncing(name) {\n        return this.syncOperations.findOne(Object.assign(Object.assign({}, name ? { collectionName: name } : {}), { status: 'active' }), { fields: { status: 1 } }) != null;\n    }\n    /**\n     * Checks if the sync manager is ready to sync.\n     * @returns A promise that resolves when the sync manager is ready to sync.\n     */\n    async isReady() {\n        await this.persistenceReady;\n    }\n    /**\n     * Starts the sync process for a collection\n     * @param name Name of the collection\n     * @param options Options for the sync process.\n     * @param options.force If true, the sync process will be started even if there are no changes and onlyWithChanges is true.\n     * @param options.onlyWithChanges If true, the sync process will only be started if there are changes.\n     */\n    async sync(name, options = {}) {\n        if (this.isDisposed)\n            throw new Error('SyncManager is disposed');\n        await this.isReady();\n        const entry = this.getCollection(name);\n        const collectionOptions = entry[1];\n        const hasActiveSyncs = this.syncOperations.find({\n            collectionName: name,\n            instanceId: this.instanceId,\n            status: 'active',\n        }).count() > 0;\n        const syncTime = Date.now();\n        let syncId = null;\n        // schedule for next tick to allow other tasks to run first\n        await new Promise((resolve) => { setTimeout(resolve, 0); });\n        const doSync = async () => {\n            const lastFinishedSync = this.syncOperations.findOne({ collectionName: name, status: 'done' }, { sort: { end: -1 } });\n            if (options === null || options === void 0 ? void 0 : options.onlyWithChanges) {\n                const currentChanges = this.changes.find({\n                    collectionName: name,\n                    $and: [\n                        { time: { $lte: syncTime } },\n                    ],\n                }, { sort: { time: 1 } }).count();\n                if (currentChanges === 0)\n                    return;\n            }\n            if (!hasActiveSyncs) {\n                syncId = this.syncOperations.insert({\n                    start: syncTime,\n                    collectionName: name,\n                    instanceId: this.instanceId,\n                    status: 'active',\n                });\n            }\n            const data = await this.options.pull(collectionOptions, {\n                lastFinishedSyncStart: lastFinishedSync === null || lastFinishedSync === void 0 ? void 0 : lastFinishedSync.start,\n                lastFinishedSyncEnd: lastFinishedSync === null || lastFinishedSync === void 0 ? void 0 : lastFinishedSync.end,\n            });\n            await this.syncWithData(name, data);\n        };\n        await ((options === null || options === void 0 ? void 0 : options.force) ? doSync() : this.getSyncQueue(name).add(doSync))\n            .catch((error) => {\n            if (syncId != null) {\n                if (this.options.onError)\n                    this.options.onError(collectionOptions, error);\n                this.syncOperations.updateOne({ id: syncId }, {\n                    $set: { status: 'error', end: Date.now(), error: error.stack || error.message },\n                });\n            }\n            throw error;\n        });\n        if (syncId != null) {\n            // clean up old sync operations\n            this.syncOperations.removeMany({\n                id: { $ne: syncId },\n                collectionName: name,\n                $or: [\n                    { end: { $lte: syncTime } },\n                    { status: 'active' },\n                ],\n            });\n            // update sync operation status to done after everthing was finished\n            this.syncOperations.updateOne({ id: syncId }, {\n                $set: { status: 'done', end: Date.now() },\n            });\n        }\n    }\n    /**\n     * Starts the push process for a collection (sync process but only if there are changes)\n     * @param name Name of the collection\n     */\n    async pushChanges(name) {\n        await this.sync(name, {\n            onlyWithChanges: true,\n        });\n    }\n    async syncWithData(name, data) {\n        const entry = this.getCollection(name);\n        const [collection, collectionOptions] = entry;\n        const syncTime = Date.now();\n        const lastFinishedSync = this.syncOperations.findOne({ collectionName: name, status: 'done' }, { sort: { end: -1 } });\n        const lastSnapshot = this.snapshots.findOne({ collectionName: name }, { sort: { time: -1 } });\n        const currentChanges = this.changes.find({\n            collectionName: name,\n            $and: [\n                { time: { $lte: syncTime } },\n            ],\n        }, { sort: { time: 1 } }).fetch();\n        await sync({\n            changes: currentChanges,\n            lastSnapshot: lastSnapshot === null || lastSnapshot === void 0 ? void 0 : lastSnapshot.items,\n            data,\n            pull: () => this.options.pull(collectionOptions, {\n                lastFinishedSyncStart: lastFinishedSync === null || lastFinishedSync === void 0 ? void 0 : lastFinishedSync.start,\n                lastFinishedSyncEnd: lastFinishedSync === null || lastFinishedSync === void 0 ? void 0 : lastFinishedSync.end,\n            }),\n            push: changes => this.options.push(collectionOptions, { changes }),\n            insert: (item) => {\n                if (item.id && !!collection.findOne({ id: item.id })) {\n                    this.remoteChanges.push({\n                        collectionName: name,\n                        type: 'update',\n                        data: { id: item.id, modifier: { $set: item } },\n                    });\n                    // update the item if it already exists\n                    collection.updateOne({ id: item.id }, { $set: item });\n                    return;\n                }\n                this.remoteChanges.push({\n                    collectionName: name,\n                    type: 'insert',\n                    data: item,\n                });\n                collection.insert(item);\n            },\n            update: (itemId, modifier) => {\n                if (itemId && !collection.findOne({ id: itemId })) {\n                    const item = Object.assign(Object.assign({}, modifier.$set), { id: itemId });\n                    this.remoteChanges.push({\n                        collectionName: name,\n                        type: 'insert',\n                        data: item,\n                    });\n                    // insert the item if it does not exist\n                    collection.insert(item);\n                    return;\n                }\n                this.remoteChanges.push({\n                    collectionName: name,\n                    type: 'update',\n                    data: { id: itemId, modifier },\n                });\n                collection.updateOne({ id: itemId }, modifier);\n            },\n            remove: (itemId) => {\n                this.remoteChanges.push({\n                    collectionName: name,\n                    type: 'remove',\n                    data: itemId,\n                });\n                collection.removeOne({ id: itemId });\n            },\n            batch: (fn) => {\n                collection.batch(() => {\n                    fn();\n                });\n            },\n        })\n            .then(async (snapshot) => {\n            // clean up old snapshots\n            this.snapshots.removeMany({ collectionName: name, time: { $lte: syncTime } });\n            // clean up processed changes\n            this.changes.removeMany({\n                collectionName: name,\n                id: { $in: currentChanges.map(c => c.id) },\n            });\n            // insert new snapshot\n            this.snapshots.insert({\n                time: syncTime,\n                collectionName: name,\n                items: snapshot,\n            });\n            // delay sync operation update to next tick to allow other tasks to run first\n            await new Promise((resolve) => { setTimeout(resolve, 0); });\n        })\n            // check if there are unsynced changes to push\n            // after the sync was finished successfully\n            .then(() => this.sync(name, {\n            force: true,\n            onlyWithChanges: true,\n        }));\n    }\n}\n"],"names":["EventEmitter","BaseEventEmitter","event","listener","args","match","item","selector","Query","modify","modifier","clonedItem","updateObject","isEqual","a","b","aKeys","bKeys","i","key","randomId","clone","value","result","val","deepClone","obj","serializeValue","createSignal","dependency","initialValue","newValue","get","path","segments","current","sortItems","items","sortFields","sort","set","deleteIfUndefined","apply","node","nextIsNum","project","fields","fieldValue","uniqueBy","arr","fn","el","Observer","bindEvents","callback","options","events","newItems","oldItemsMap","index","newItemsMap","oldItem","oldBeforeItem","_a","newItem","callbacks","skipInitial","typedKey","isInReactiveScope","reactivity","Cursor","getItems","depend","memo","notify","changedItem","changedFieldName","rawItem","skip","limit","sorted","skipped","limited","idExcluded","changeEvents","signal","buildNotifier","eventHandler","stop","observer","requery","cleanup","results","callbackName","before","transformedValue","hasBeforeParam","transformedBeforeValue","__rest","s","p","intersection","arrays","c","getMergedIndexInfo","indexProviders","indexProvider","info","optimizedSelector","getIndexInfo","$and","$or","rest","flatInfo","matched","positions","newSelector","$andNew","sel","selMatched","selPositions","$orNew","createIndexProvider","definition","expressionKeys","isFieldExpression","expression","keys","getMatchingKeys","field","createExternalIndex","createIndex","hasPendingUpdates","pendingUpdates","applyUpdates","currentItems","added","modified","removed","id","Collection","collection","_b","_c","_d","ongoingSaves","isInitialized","loadPersistentData","data","changes","doc","itemIndex","saveQueue","isFlushing","flushQueue","error","isPulling","isPushing","enable","measureFunction","startTime","endTime","callstack","memory","indexInfo","currenIndex","matchItems","measuredTime","cursor","handleRequery","returnValue","cb","ids","modifiedItem","existingItem","modifiedItems","createPersistenceAdapter","createLocalStorageAdapter","name","serialize","deserialize","collectionId","createFilesystemAdapter","filename","savePromise","fs","contents","err","onChange","_items","createAdapter","PersistentCollection","createTemporaryFallbackExecutor","firstResolvingPromiseFn","secondResolvingPromiseFn","cacheTimeout","isResolved","resolvedValue","timeout","secondaryPromise","combinePersistenceAdapters","primary","secondary","readPreference","primaryAdapter","secondaryAdapter","handleChange","readExecutor","createReplicationAdapter","ReplicatedCollection","replicationAdapter","persistenceAdapter","isPullingRemote","isPushingRemote","isLoading","AutoFetchCollection","triggerRemoteChange","itemA","itemB","response","queries","activeObservers","removeObserver","createOPFSAdapter","existingFileHandle","writeStream","createMemoryAdapter","createReactivityAdapter","debounce","func","wait","leading","trailing","debounced","shouldCallImmediately","shouldCallTrailing","PromiseQueue","task","resolve","reject","computeChanges","oldItems","getSnapshot","lastSnapshot","applyChanges","change","itemExists","hasChanges","hasDifference","sync","pull","push","insert","update","remove","batch","newData","previousSnapshot","newSnapshot","lastSnapshotWithChanges","newSnapshotWithChanges","changesToPush","newChanges","SyncManager","changesErrorHandler","snapshotsErrorHandler","syncOperationsErrorHandler","changesPersistenceAdapter","handler","snapshotsPersistenceAdapter","syncOperationsPersistenceAdapter","entry","syncTime","syncId","hasRemoteChange","remoteChange","removeRemoteChange","errors","e","collectionOptions","hasActiveSyncs","doSync","lastFinishedSync","currentChanges","itemId","snapshot"],"mappings":";;;;AACA,MAAqBA,UAAqBC,EAAiB;AAAA,EACvD,GAAGC,GAAOC,GAAU;AACV,iBAAA,GAAGD,GAAOC,CAAQ,GACjB;AAAA,EAAA;AAAA,EAEX,KAAKD,MAAUE,GAAM;AACjB,WAAO,MAAM,KAAKF,GAAO,GAAGE,CAAI;AAAA,EAAA;AAExC;ACRwB,SAAAC,EAAMC,GAAMC,GAAU;AAEnC,SADO,IAAIC,EAAMD,CAAQ,EACnB,KAAKD,CAAI;AAC1B;ACHwB,SAAAG,EAAOH,GAAMI,GAAU;AAC3C,QAAMC,IAAa,OAAO,OAAO,CAAA,GAAIL,CAAI;AAEzC,SAAAM,EAAaD,GAAYD,CAAQ,GAC1BC;AACX;ACNwB,SAAAE,EAAQC,GAAGC,GAAG;AAC9B,MAAA,OAAO,GAAGD,GAAGC,CAAC;AACP,WAAA;AACP,MAAAD,aAAa,UAAUC,aAAa;AACpC,WAAOD,EAAE,eAAeC,EAAE,SAAS;AACnC,MAAAD,aAAa,QAAQC,aAAa;AAClC,WAAOD,EAAE,cAAcC,EAAE,QAAQ;AAOrC,MANI,OAAOD,KAAM,YAEb,OAAOC,KAAM,YAEbD,MAAM,QAENC,MAAM;AACC,WAAA;AACL,QAAAC,IAAQ,OAAO,KAAKF,CAAC,GACrBG,IAAQ,OAAO,KAAKF,CAAC;AACvB,MAAAC,EAAM,WAAWC,EAAM;AAChB,WAAA;AACX,WAASC,IAAI,GAAGA,IAAIF,EAAM,QAAQE,KAAK,GAAG;AAChC,UAAAC,IAAMH,EAAME,CAAC;AAGnB,QAFI,CAACD,EAAM,SAASE,CAAG,KAEnB,CAACN,EAAQC,EAAEK,CAAG,GAAGJ,EAAEI,CAAG,CAAC;AAChB,aAAA;AAAA,EAAA;AAER,SAAA;AACX;AC3BA,SAAwBC,IAAW;AACxB,SAAA,KAAK,MAAM,KAAK,WAAW,IAAI,EAAE,SAAS,EAAE;AACvD;ACFO,SAASC,EAAMC,GAAO;AAEzB,MAAI,OAAOA,KAAU;AACX,UAAA,IAAI,MAAM,oCAAoC;AAEpD,MAAAA,MAAU,QAAQ,OAAOA,KAAU;AAC5B,WAAAA;AAEX,MAAIA,aAAiB;AACjB,WAAO,IAAI,KAAKA,EAAM,SAAS;AAE/B,MAAA,MAAM,QAAQA,CAAK;AACnB,WAAOA,EAAM,IAAI,CAAQhB,MAAAe,EAAMf,CAAI,CAAC;AAExC,MAAIgB,aAAiB,KAAK;AAChBC,UAAAA,wBAAa,IAAI;AACjB,WAAAD,EAAA,QAAQ,CAACE,GAAKL,MAAQ;AACxBI,MAAAA,EAAO,IAAIJ,GAAKE,EAAMG,CAAG,CAAC;AAAA,IAAA,CAC7B,GACMD;AAAAA,EAAA;AAGX,MAAID,aAAiB,KAAK;AAChBC,UAAAA,wBAAa,IAAI;AACjB,WAAAD,EAAA,QAAQ,CAACE,MAAQ;AACnBD,MAAAA,EAAO,IAAIF,EAAMG,CAAG,CAAC;AAAA,IAAA,CACxB,GACMD;AAAAA,EAAA;AAGX,MAAID,aAAiB;AACV,WAAA,IAAI,OAAOA,CAAK;AAE3B,QAAMC,IAAS,CAAC;AAChB,aAAWJ,KAAOG;AACd,IAAI,OAAO,eAAe,KAAKA,GAAOH,CAAG,MACrCI,EAAOJ,CAAG,IAAIE,EAAMC,EAAMH,CAAG,CAAC;AAG/B,SAAAI;AACX;AACA,SAAwBE,EAAUC,GAAK;AAEnC,MAAI,OAAO,mBAAoB;AAC3B,WAAO,gBAAgBA,CAAG;AAAA,EAAA;AAG9B,SAAOL,EAAMK,CAAG;AACpB;AChDA,SAAwBC,EAAeL,GAAO;AAC1C,SAAI,OAAOA,KAAU,WACVA,IACP,OAAOA,KAAU,YAEjB,OAAOA,KAAU,YACVA,EAAM,SAAS,IACtBA,aAAiB,OACVA,EAAM,YAAY,IACtB,KAAK,UAAUA,CAAK;AAC/B;ACVA,SAAwBM,EAAaC,GAAYC,GAAcjB,IAAU,OAAO,IAAI;AAChF,MAAIS,IAAQQ;AAeL,SAdQ;AAAA,IACX,MAAM;AACE,aAAAD,KACAA,EAAW,OAAO,GACfP;AAAA,IACX;AAAA,IACA,IAAIS,GAAU;AACN,MAAAlB,EAAQS,GAAOS,CAAQ,MAEnBT,IAAAS,GACJF,KACAA,EAAW,OAAO;AAAA,IAAA;AAAA,EAE9B;AAEJ;ACjBwB,SAAAG,EAAIV,GAAOW,GAAM;AAC/B,QAAAC,IAAWD,EAAK,MAAM,SAAS;AACjC,EAAAC,EAAS,CAAC,MAAM,MAChBA,EAAS,MAAM,GACfA,EAASA,EAAS,SAAS,CAAC,MAAM,MAClCA,EAAS,IAAI;AACjB,MAAIC,IAAUb;AACd,WAASJ,IAAI,GAAGA,IAAIgB,EAAS,QAAQhB,KAAK,GAAG;AACnC,UAAAC,IAAMe,EAAShB,CAAC;AACtB,QAAIiB,KAAW,QAAQhB,EAAI,KAAW,MAAA;AAC3B;AACX,IAAAgB,IAAUA,EAAQhB,CAAG;AAAA,EAAA;AAEzB,MAAIgB,MAAY;AAET,WAAAA;AACX;ACdwB,SAAAC,EAAUC,GAAOC,GAAY;AACjD,SAAOC,EAAKF,CAAK,EAAE,GAAG,OAAO,QAAQC,CAAU,EAAE,IAAI,CAAC,CAACnB,GAAKG,CAAK,OAEtD,EAAE,CADKA,MAAU,IAAI,QAAQ,MACrB,GAAG,CAACJ,MAAMc,EAAId,GAAGC,CAAG,EAAE,EACxC,CAAC;AACN;ACNA,SAAwBqB,EAAId,GAAKO,GAAMX,GAAOmB,IAAoB,IAAO;AACrE,MAAIf,KAAO;AACA,WAAAA;AACL,QAAAQ,IAAWD,EAAK,MAAM,SAAS;AACjC,EAAAC,EAAS,CAAC,MAAM,MAChBA,EAAS,MAAM,GACfA,EAASA,EAAS,SAAS,CAAC,MAAM,MAClCA,EAAS,IAAI;AACX,QAAAQ,IAAQ,CAACC,MAAS;AAChB,QAAAT,EAAS,SAAS,GAAG;AACf,YAAAf,IAAMe,EAAS,MAAM,GACrBU,IAAY,CAAC,OAAO,MAAM,SAASV,EAAS,CAAC,GAAG,EAAE,CAAC;AACrD,MAAAS,EAAKxB,CAAG,MAAM,WACdwB,EAAKxB,CAAG,IAAIyB,IAAY,KAAK,CAAC,IAE5BF,EAAAC,EAAKxB,CAAG,CAAC;AAAA,IAAA,OAEd;AACG,UAAAsB,KAAqBnB,MAAU,QAAW;AACnC,eAAAqB,EAAKT,EAAS,CAAC,CAAC;AACvB;AAAA,MAAA;AAEC,MAAAS,EAAAT,EAAS,CAAC,CAAC,IAAIZ;AAAA,IAAA;AAAA,EAE5B;AACA,SAAAoB,EAAMhB,CAAG,GACFA;AACX;AC1BwB,SAAAmB,EAAQvC,GAAMwC,GAAQ;AAE1C,MAD6B,OAAO,OAAOA,CAAM,EAAE,MAAM,CAAAxB,MAASA,MAAU,CAAC,GACnD;AACtB,UAAMC,IAAS,OAAO,OAAO,CAAA,GAAIjB,CAAI;AACrC,kBAAO,KAAKwC,CAAM,EAAE,QAAQ,CAAC3B,MAAQ;AAEjC,MADmBa,EAAI1B,GAAMa,CAAG,MACb,UAEfI,EAAAA,GAAQJ,GAAK,QAAW,EAAI;AAAA,IAAA,CACnC,GACMI;AAAAA,EAAA;AAEX,QAAMA,IAAS,CAAC;AACT,gBAAA,QAAQuB,CAAM,EAAE,QAAQ,CAAC,CAAC3B,GAAKG,CAAK,MAAM;AACvC,UAAAyB,IAAaf,EAAI1B,GAAMa,CAAG;AAChC,IAAI4B,MAAe,WAEfA,KAAc,QAAQzB,MAAU,KAEpCkB,EAAIjB,GAAQJ,GAAKG,MAAU,IAAIyB,IAAa,MAAS;AAAA,EAAA,CACxD,GACMxB;AACX;ACxBwB,SAAAyB,EAASC,GAAKC,GAAI;AAChC,QAAAV,wBAAU,IAAI;AACb,SAAAS,EAAI,OAAO,CAACE,MAAO;AAChB,UAAA7B,IAAQ,OAAO4B,KAAO,aAAaA,EAAGC,CAAE,IAAIA,EAAGD,CAAE;AACvD,WAAO,CAACV,EAAI,IAAIlB,CAAK,KAAKkB,EAAI,IAAIlB,CAAK;AAAA,EAAA,CAC1C;AACL;ACJA,MAAqB8B,EAAS;AAAA,EAC1B,YAAYC,GAAY;AACpB,SAAK,gBAAgB,CAAC,GACtB,KAAK,YAAY;AAAA,MACb,OAAO,CAAC;AAAA,MACR,aAAa,CAAC;AAAA,MACd,SAAS,CAAC;AAAA,MACV,cAAc,CAAC;AAAA,MACf,aAAa,CAAC;AAAA,MACd,SAAS,CAAA;AAAA,IACb,GACA,KAAK,eAAeA,EAAW;AAAA,EAAA;AAAA,EAEnC,KAAKnD,MAAUE,GAAM;AACZ,SAAA,UAAUF,CAAK,EAAE,QAAQ,CAAC,EAAE,UAAAoD,GAAU,SAAAC,QAAc;AAErD,OAAI,CAACA,EAAQ,eAAe,CAACA,EAAQ,cACjCD,EAAS,GAAGlD,CAAI;AAAA,IACpB,CACH;AAAA,EAAA;AAAA,EAEL,aAAaoD,GAAQ;AACV,WAAAA,EAAO,KAAK,CAAStD,MAAA,KAAK,UAAUA,CAAK,EAAE,SAAS,CAAC;AAAA,EAAA;AAAA,EAEhE,UAAU;AACC,WAAA,CAAC,KAAK,aAAa;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACH;AAAA,EAAA;AAAA,EAEL,UAAUuD,GAAU;AACV,UAAAC,IAAc,IAAI,IAAI,KAAK,cAAc,IAAI,CAACpD,GAAMqD,MAAU;AAAA,MAChErD,EAAK;AAAA,MACL,EAAE,MAAAA,GAAM,OAAAqD,GAAO,YAAY,KAAK,cAAcA,IAAQ,CAAC,KAAK,KAAK;AAAA,IAAA,CACpE,CAAC,GACIC,IAAc,IAAI,IAAIH,EAAS,IAAI,CAACnD,GAAMqD,MAAU;AAAA,MACtDrD,EAAK;AAAA,MACL,EAAE,MAAAA,GAAM,OAAAqD,GAAO,YAAYF,EAASE,IAAQ,CAAC,KAAK,KAAK;AAAA,IAAA,CAC1D,CAAC;AACE,IAAA,KAAK,aAAa,CAAC,WAAW,gBAAgB,eAAe,SAAS,CAAC,KAE3DD,EAAA,QAAQ,CAAC,EAAE,MAAMG,GAAS,OAAAF,GAAO,YAAYG,QAAoB;AACrE,UAAAC;AACJ,YAAMC,IAAUJ,EAAY,IAAIC,EAAQ,EAAE;AAC1C,MAAIG,KACI,KAAK,aAAa,CAAC,WAAW,cAAc,CAAC,MAExCnD,EAAQmD,EAAQ,MAAMH,CAAO,MACzB,KAAA,KAAK,WAAWG,EAAQ,IAAI,GAC7B,KAAK,aAAa,CAAC,cAAc,CAAC,KAErBhB,EAAS;AAAA,QAClB,GAAG,OAAO,KAAKgB,EAAQ,IAAI;AAAA,QAC3B,GAAG,OAAO,KAAKH,CAAO;AAAA,MAAA,GACvB,OAASvC,CAAK,EACZ,QAAQ,CAACH,MAAQ;AAClB,QAAIN,EAAQmD,EAAQ,KAAK7C,CAAG,GAAG0C,EAAQ1C,CAAG,CAAC,KAEtC,KAAA,KAAK,gBAAgB6C,EAAQ,MAAM7C,GAAK0C,EAAQ1C,CAAG,GAAG6C,EAAQ,KAAK7C,CAAG,CAAC;AAAA,MAAA,CAC/E,KAKT6C,EAAQ,UAAUL,OAAWI,IAAKC,EAAQ,gBAAgB,QAAQD,MAAO,SAAS,SAASA,EAAG,SAASD,KAAkB,OAAmC,SAASA,EAAc,OACnL,KAAK,KAAK,eAAeE,EAAQ,MAAMA,EAAQ,UAAU,KAKxD,KAAA,KAAK,WAAWH,CAAO;AAAA,IAChC,CACH,GAED,KAAK,aAAa,CAAC,SAAS,aAAa,CAAC,KAEjCJ,EAAA,QAAQ,CAACO,GAASL,MAAU;AAE7B,MADYD,EAAY,IAAIM,EAAQ,EAAE,MAIrC,KAAA,KAAK,SAASA,CAAO,GAC1B,KAAK,KAAK,eAAeA,GAASP,EAASE,IAAQ,CAAC,KAAK,IAAI;AAAA,IAAA,CAChE,GAGL,KAAK,gBAAgBF,GACrB,OAAO,KAAK,KAAK,SAAS,EAAE,QAAQ,CAACtC,MAAQ;AACzC,YAAMjB,IAAQiB,GACR8C,IAAY,KAAK,UAAU/D,CAAK;AACtC,WAAK,UAAUA,CAAK,IAAI+D,EAAU,IAAI,CAAAX,MAAa,OAAO,OAAO,OAAO,OAAO,CAAC,GAAGA,CAAQ,GAAG,EAAE,SAAS,OAAO,OAAO,OAAO,OAAO,IAAIA,EAAS,OAAO,GAAG,EAAE,WAAW,GAAO,CAAA,EAAG,CAAA,CAAE;AAAA,IAAA,CACxL;AAAA,EAAA;AAAA,EAEL,OAAO;AACH,SAAK,aAAa;AAAA,EAAA;AAAA,EAEtB,aAAaW,GAAWC,IAAc,IAAO;AACzC,WAAO,KAAKD,CAAS,EAAE,QAAQ,CAAC9C,MAAQ;AACpC,YAAMgD,IAAWhD;AACZ,WAAA,UAAUgD,CAAQ,EAAE,KAAK;AAAA,QAC1B,UAAUF,EAAUE,CAAQ;AAAA,QAC5B,SAAS,EAAE,aAAAD,GAAa,WAAW,GAAK;AAAA,MAAA,CAC3C;AAAA,IAAA,CACJ;AAAA,EAAA;AAAA,EAEL,gBAAgBD,GAAW;AACvB,WAAO,KAAKA,CAAS,EAAE,QAAQ,CAAC9C,MAAQ;AACpC,YAAMgD,IAAWhD,GACXwC,IAAQ,KAAK,UAAUQ,CAAQ,EAChC,UAAU,CAAC,EAAE,UAAAb,EAAS,MAAMA,MAAaW,EAAUE,CAAQ,CAAC;AACjE,WAAK,UAAUA,CAAQ,EAAE,OAAOR,GAAO,CAAC;AAAA,IAAA,CAC3C;AAAA,EAAA;AAET;ACpHO,SAASS,EAAkBC,GAAY;AAC1C,SAAKA,IAEAA,EAAW,YAETA,EAAW,UAAU,IADjB,KAFA;AAIf;AACA,MAAqBC,EAAO;AAAA,EACxB,YAAYC,GAAUhB,GAAS;AAC3B,SAAK,qBAAqB,CAAC,GAC3B,KAAK,mBAAmBgB,GACnB,KAAA,UAAUhB,KAAW,CAAC;AAAA,EAAA;AAAA,EAE/B,WAAWjD,GAAM;AACb,QAAI,CAAC8D,EAAkB,KAAK,QAAQ,QAAQ;AACjC,aAAA9D;AACX,UAAMkE,IAAS,KAAK,OAAO,KAAK,IAAI;AAC7B,WAAA,OAAO,QAAQlE,CAAI,EAAE,OAAO,CAACmE,GAAM,CAACtD,GAAKG,CAAK,OAC1C,OAAA,eAAemD,GAAMtD,GAAK;AAAA,MAC7B,MAAM;AACK,eAAAqD,EAAA;AAAA,UACH,cAAc,CAAAE,MAAU,CAACC,GAAaC,MAAqB;AACvD,YAAIA,MAAqBzD,KAAOwD,EAAY,OAAOrE,EAAK,MAEjDoE,EAAA;AAAA,UAAA;AAAA,QACX,CACH,GACMpD;AAAA,MACX;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,IAAA,CACjB,GACMmD,IACR,EAAE;AAAA,EAAA;AAAA,EAET,UAAUI,GAAS;AACf,UAAMvE,IAAO,KAAK,QAAQ,gBACpB,KAAK,WAAWuE,CAAO,IACvBA;AACF,WAAC,KAAK,QAAQ,YAEX,KAAK,QAAQ,UAAUvE,CAAI,IADvBA;AAAA,EACuB;AAAA,EAEtC,WAAW;AACD,UAAA+B,IAAQ,KAAK,iBAAiB,GAC9B,EAAE,MAAAE,GAAM,MAAAuC,GAAM,OAAAC,MAAU,KAAK,SAC7BC,IAASzC,IAAOH,EAAUC,GAAOE,CAAI,IAAIF,GACzC4C,IAAUH,IAAOE,EAAO,MAAMF,CAAI,IAAIE,GACtCE,IAAUH,IAAQE,EAAQ,MAAM,GAAGF,CAAK,IAAIE,GAC5CE,IAAa,KAAK,QAAQ,UAAU,KAAK,QAAQ,OAAO,OAAO;AAC9D,WAAAD,EAAQ,IAAI,CAAC5E,MACX,KAAK,QAAQ,SAEX,OAAO,OAAO,OAAO,OAAO,IAAI6E,IAAa,CAAA,IAAK,EAAE,IAAI7E,EAAK,GAAI,CAAA,GAAGuC,EAAQvC,GAAM,KAAK,QAAQ,MAAM,CAAC,IADlGA,CAEd;AAAA,EAAA;AAAA,EAEL,OAAO8E,GAAc;AAGjB,QAFI,CAAC,KAAK,QAAQ,YAEd,CAAChB,EAAkB,KAAK,QAAQ,QAAQ;AACxC;AACJ,UAAMiB,IAAS,KAAK,QAAQ,SAAS,OAAO;AAC5C,IAAAA,EAAO,OAAO;AACR,UAAAX,IAAS,MAAMW,EAAO,OAAO;AACnC,aAASC,EAAcpF,GAAO;AACpB,YAAAqF,IAAeH,EAAalF,CAAK;AACvC,aAAO,IAAIE,MAAS;AAEhB,YAAImF,MAAiB,IAAM;AAChB,UAAAb,EAAA;AACP;AAAA,QAAA;AAGJ,QAAI,OAAOa,KAAiB,cAGfA,EAAAb,CAAM,EAAE,GAAGtE,CAAI;AAAA,MAChC;AAAA,IAAA;AAEE,UAAAoF,IAAO,KAAK,kBAAkB;AAAA,MAChC,OAAOF,EAAc,OAAO;AAAA,MAC5B,aAAaA,EAAc,aAAa;AAAA,MACxC,SAASA,EAAc,SAAS;AAAA,MAChC,cAAcA,EAAc,cAAc;AAAA,MAC1C,aAAaA,EAAc,aAAa;AAAA,MACxC,SAASA,EAAc,SAAS;AAAA,OACjC,EAAI;AACH,IAAA,KAAK,QAAQ,SAAS,aACtB,KAAK,QAAQ,SAAS,UAAU,MAAME,KAAQH,CAAM,GAExD,KAAK,UAAUG,CAAI;AAAA,EAAA;AAAA,EAEvB,iBAAiB;AACT,QAAA,CAAC,KAAK,UAAU;AACV,YAAAC,IAAW,IAAIrC,EAAS,MAAM;AAChC,cAAMsC,IAAU,MAAM;AACT,UAAAD,EAAA,UAAU,KAAK,UAAU;AAAA,QACtC,GACME,IAAU,KAAK,QAAQ,cAAc,KAAK,QAAQ,WAAWD,CAAO;AAC1E,eAAO,MAAM;AACL,UAAAC,KACQA,EAAA;AAAA,QAChB;AAAA,MAAA,CACH;AACD,WAAK,UAAU,MAAMF,EAAS,KAAA,CAAM,GACpC,KAAK,WAAWA;AAAA,IAAA;AAEpB,WAAO,KAAK;AAAA,EAAA;AAAA,EAEhB,kBAAkBxB,GAAWC,IAAc,IAAO;AACxC,UAAAuB,IAAW,KAAK,eAAe;AAC5B,WAAAA,EAAA,aAAaxB,GAAWC,CAAW,GACnCuB,EAAA,UAAU,KAAK,UAAU,GAC3B,MAAM;AAEL,MADJA,EAAS,gBAAgBxB,CAAS,GAC7BwB,EAAS,QAAQ,MAGtBA,EAAS,KAAK,GACd,KAAK,WAAW;AAAA,IACpB;AAAA,EAAA;AAAA,EAEJ,UAAU;AACD,SAAA,mBAAmB,QAAQ,CAACnC,MAAa;AACjC,MAAAA,EAAA;AAAA,IAAA,CACZ,GACD,KAAK,qBAAqB,CAAC;AAAA,EAAA;AAAA,EAE/B,UAAUA,GAAU;AACX,SAAA,mBAAmB,KAAKA,CAAQ;AAAA,EAAA;AAAA,EAEzC,QAAQA,GAAU;AACR,UAAAjB,IAAQ,KAAK,SAAS;AACvB,SAAA,OAAO,OAAO,OAAO,EAAE,aAAa,IAAM,SAAS,IAAM,aAAa,MAAQ,KAAK,QAAQ,gBAAgB,CAAC,IAAI,EAAE,SAAS,GAAA,CAAM,CAAC,GACjIA,EAAA,QAAQ,CAAC/B,MAAS;AACX,MAAAgD,EAAA,KAAK,UAAUhD,CAAI,CAAC;AAAA,IAAA,CAChC;AAAA,EAAA;AAAA,EAEL,IAAIgD,GAAU;AACV,UAAMsC,IAAU,CAAC;AACZ,gBAAA,QAAQ,CAACtF,MAAS;AACX,MAAAsF,EAAA,KAAKtC,EAAShD,CAAI,CAAC;AAAA,IAAA,CAC9B,GACMsF;AAAA,EAAA;AAAA,EAEX,QAAQ;AACG,WAAA,KAAK,IAAI,CAAAtF,MAAQA,CAAI;AAAA,EAAA;AAAA,EAEhC,QAAQ;AACE,UAAA+B,IAAQ,KAAK,SAAS;AAC5B,gBAAK,OAAO;AAAA,MACR,OAAO;AAAA,MACP,SAAS;AAAA,IAAA,CACZ,GACMA,EAAM;AAAA,EAAA;AAAA,EAEjB,eAAe4B,GAAWC,IAAc,IAAO;AAC3C,WAAO,KAAK,kBAAkB,OACzB,QAAQD,CAAS,EACjB,OAAO,CAACQ,GAAM,CAACoB,GAAcvC,CAAQ,MACjCA,IAEE,OAAO,OAAO,OAAO,OAAO,CAAI,GAAAmB,CAAI,GAAG,EAAE,CAACoB,CAAY,GAAG,CAACvF,GAAMwF,MAAW;AACpE,YAAAC,IAAmB,KAAK,UAAUzF,CAAI,GACtC0F,IAAiBF,MAAW,QAC5BG,IAAyBD,KAAkBF,IAC3C,KAAK,UAAUA,CAAM,IACrB;AACC,aAAAxC,EAASyC,GAAkB,GAAGC,IAAiB,CAACC,CAAsB,IAAI,EAAE;AAAA,IAAA,GACpF,IARIxB,GASZ,CAAA,CAAE,GAAGP,CAAW;AAAA,EAAA;AAAA,EAEvB,UAAU;AACN,IAAK,KAAK,YAEV,KAAK,SAAS,UAAU,KAAK,SAAA,CAAU;AAAA,EAAA;AAE/C;AC1IO,SAASgC,EAAOC,GAAG,GAAG;AAC3B,MAAI,IAAI,CAAE;AACV,WAASC,KAAKD,EAAG,CAAI,OAAO,UAAU,eAAe,KAAKA,GAAGC,CAAC,KAAK,EAAE,QAAQA,CAAC,IAAI,MAC9E,EAAEA,CAAC,IAAID,EAAEC,CAAC;AACd,MAAID,KAAK,QAAQ,OAAO,OAAO,yBAA0B;AACrD,aAASjF,IAAI,GAAGkF,IAAI,OAAO,sBAAsBD,CAAC,GAAGjF,IAAIkF,EAAE,QAAQlF;AAC/D,MAAI,EAAE,QAAQkF,EAAElF,CAAC,CAAC,IAAI,KAAK,OAAO,UAAU,qBAAqB,KAAKiF,GAAGC,EAAElF,CAAC,CAAC,MACzE,EAAEkF,EAAElF,CAAC,CAAC,IAAIiF,EAAEC,EAAElF,CAAC,CAAC;AAE5B,SAAO;AACT;ACpDA,SAAwBmF,KAAgBC,GAAQ;AAC5C,SAAIA,EAAO,WAAW,IACX,CAAC,IACL,CAAC,GAAG,IAAI,IAAIA,EAAO,OAAO,CAACxF,GAAGC,MAAMD,EAAE,OAAO,OAAKC,EAAE,SAASwF,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7E;ACFgB,SAAAC,GAAmBC,GAAgBlG,GAAU;AACzD,SAAOkG,EAAe,OAAO,CAAChC,GAAMiC,MAAkB;AAAA,IAAA;AAElD,QAAIA,EAAc,kBAAkB;AAC1B,YAAAnF,IAASmF,EAAc,iBAAiBnG,CAAQ;AACtD,aAAIgB,KAAU,OACHkD,IACJ;AAAA,QACH,SAAS;AAAA,QACT,WAAWA,EAAK,UACV4B,EAAa5B,EAAK,WAAWlD,CAAM,IACnCA;AAAA,QACN,mBAAmBkD,EAAK;AAAA,MAC5B;AAAA,IAAA;AAEE,UAAAkC,IAAOD,EAAc,MAAMnG,CAAQ;AACzC,QAAI,CAACoG,EAAK;AACC,aAAAlC;AACX,UAAMmC,IAAoB,OAAO,YAAY,OAAO,QAAQnC,EAAK,iBAAiB,EAC7E,OAAO,CAAC,CAACtD,CAAG,MAAM,CAACwF,EAAK,OAAO,SAASxF,CAAG,CAAC,CAAC;AAC3C,WAAA;AAAA,MACH,SAAS;AAAA,MACT,WAAW,CAAC,GAAG,IAAI,IAAIsD,EAAK,UAClB4B,EAAa5B,EAAK,WAAWkC,EAAK,SAAS,IAC3CA,EAAK,SAAS,CAAC;AAAA,MACzB,mBAAAC;AAAA,IACJ;AAAA,EAAA,GACD;AAAA,IACC,SAAS;AAAA,IACT,WAAW,CAAC;AAAA,IACZ,mBAAmB,OAAO,OAAO,CAAA,GAAIrG,CAAQ;AAAA,EAAA,CAChD;AACL;AACwB,SAAAsG,EAAaJ,GAAgBlG,GAAU;AAC3D,MAAIA,KAAY,QAAQ,OAAO,KAAKA,CAAQ,EAAE,UAAU;AACpD,WAAO,EAAE,SAAS,IAAO,WAAW,CAAC,GAAG,mBAAmBA,EAAS;AAElE,QAAA,EAAE,MAAAuG,GAAM,KAAAC,EAAQ,IAAAxG,GAAUyG,IAAOd,EAAO3F,GAAU,CAAC,QAAQ,KAAK,CAAC,GACjE0G,IAAWT,GAAmBC,GAAgBO,CAAI;AACpD,MAAA,EAAE,SAAAE,GAAS,WAAAC,EAAA,IAAcF;AAC7B,QAAMG,IAAcH,EAAS;AACzB,MAAA,MAAM,QAAQH,CAAI,GAAG;AACrB,UAAMO,IAAU,CAAC;AACjB,eAAWC,KAAOR,GAAM;AACd,YAAA,EAAE,SAASS,GAAY,WAAWC,GAAc,mBAAAZ,MAAuBC,EAAaJ,GAAgBa,CAAG;AAC7G,MAAIC,KACAJ,IAAYD,IAAUb,EAAac,GAAWK,CAAY,IAAIA,GACpDN,IAAA,IACN,OAAO,KAAKN,CAAiB,EAAE,SAAS,KACxCS,EAAQ,KAAKT,CAAiB,KAIlCS,EAAQ,KAAKC,CAAG;AAAA,IACpB;AAEJ,IAAID,EAAQ,SAAS,MACjBD,EAAY,OAAOC;AAAA,EAAA;AAEvB,MAAA,MAAM,QAAQN,CAAG,GAAG;AACpB,UAAMU,IAAS,CAAC;AAChB,eAAWH,KAAOP,GAAK;AACb,YAAA,EAAE,SAASQ,GAAY,WAAWC,GAAc,mBAAAZ,MAAuBC,EAAaJ,GAAgBa,CAAG;AAC7G,MAAIC,KACYJ,IAAA,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAGA,GAAW,GAAGK,CAAY,CAAC,CAAC,GAC9CN,IAAA,IACN,OAAO,KAAKN,CAAiB,EAAE,SAAS,KACxCa,EAAO,KAAKb,CAAiB,KAIjCa,EAAO,KAAKH,CAAG;AAAA,IACnB;AAEJ,IAAIG,EAAO,SAAS,MAChBL,EAAY,MAAMK;AAAA,EAAA;AAEnB,SAAA;AAAA,IACH,SAAAP;AAAA,IACA,WAAWC,KAAa,CAAC;AAAA,IACzB,mBAAmBC;AAAA,EACvB;AACJ;ACpFA,SAAwBM,GAAoBC,GAAY;AAC7C,SAAAA;AACX;ACFA,MAAMC,IAAiB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACA,SAAwBC,EAAkBC,GAAY;AAClD,MAAI,OAAOA,KAAe,YAAYA,KAAc;AACzC,WAAA;AAEL,QAAAC,IAAO,OAAO,KAAKD,CAAU;AAK/B,SAJAC,EAAK,WAAW,KAGGA,EAAK,KAAK,CAAA5G,MAAO,CAACyG,EAAe,SAASzG,CAAG,CAAC,IAE1D,KACU4G,EAAK,MAAM,OAAOH,EAAe,SAASzG,CAAG,CAAC;AAEvE;ACrCwB,SAAA6G,GAAgBC,GAAO1H,GAAU;AACjD,MAAAA,EAAS0H,CAAK,aAAa;AACpB,WAAA;AACP,MAAA1H,EAAS0H,CAAK,KAAK,MAAM;AACzB,QAAIJ,EAAkBtH,EAAS0H,CAAK,CAAC,GAAG;AAIpC,UAHcJ,EAAkBtH,EAAS0H,CAAK,CAAC,KACxC,MAAM,QAAQ1H,EAAS0H,CAAK,EAAE,GAAG,KACjC1H,EAAS0H,CAAK,EAAE,IAAI,QAChB;AACD,cAAArB,IAAoB,OAAO,OAAO,OAAO,OAAO,CAAC,GAAGrG,CAAQ,GAAG,EAAE,CAAC0H,CAAK,GAAG,OAAO,OAAO,CAAA,GAAI1H,EAAS0H,CAAK,CAAC,GAAG;AAC7G,sBAAArB,EAAkBqB,CAAK,EAAE,KAC5B,OAAO,KAAKrB,EAAkBqB,CAAK,CAAC,EAAE,WAAW,KACjD,OAAOrB,EAAkBqB,CAAK,GAE3B1H,EAAS0H,CAAK,EAAE,IAAI,IAAItG,CAAc;AAAA,MAAA;AAE1C,aAAA;AAAA,IAAA;AAEX,WAAO,CAACA,EAAepB,EAAS0H,CAAK,CAAC,CAAC;AAAA,EAAA;AAEpC,SAAA;AACX;ACnBgB,SAAAC,EAAoBD,GAAOtE,GAAO;AAC9C,SAA2B;AAAA,IACvB,MAAMpD,GAAU;AACN,YAAAwH,IAAOC,GAAgBC,GAAO1H,CAAQ;AAC5C,aAAIwH,KAAQ,OACD,EAAE,SAAS,GAAM,IAGrB;AAAA,QACH,SAAS;AAAA,QACT,WAJkBA,EACjB,OAAO,CAACtD,GAAMtD,MAAQ,CAAC,GAAGsD,GAAM,GAAGd,EAAM,IAAIxC,CAAG,KAAK,CAAE,CAAA,GAAG,CAAA,CAAE;AAAA,QAI7D,QAAQ,CAAC8G,CAAK;AAAA,MAClB;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,IAAA;AAAA,EAEV;AAER;AACA,SAAwBE,GAAYF,GAAO;AACjC,QAAAtE,wBAAY,IAAI;AACtB,SAAO,OAAO,OAAO,OAAO,OAAO,CAAC,GAAGuE,EAAoBD,GAAOtE,CAAK,CAAC,GAAG,EAAE,QAAQtB,GAAO;AACpF,IAAAsB,EAAM,MAAM,GACNtB,EAAA,QAAQ,CAAC/B,GAAMY,MAAM;AACvB,YAAMI,IAAQK,EAAeK,EAAI1B,GAAM2H,CAAK,CAAC,GACvC9F,IAAUwB,EAAM,IAAIrC,CAAK,yBAAS,IAAI;AAC5C,MAAAa,EAAQ,IAAIjB,CAAC,GACPyC,EAAA,IAAIrC,GAAOa,CAAO;AAAA,IAAA,CAC3B;AAAA,EAAA,GACF;AACX;ACtBA,SAASiG,EAAkBC,GAAgB;AAChC,SAAAA,EAAe,MAAM,SAAS,KAC9BA,EAAe,SAAS,SAAS,KACjCA,EAAe,QAAQ,SAAS;AAC3C;AACA,SAASC,GAAaC,GAAc,EAAE,OAAAC,GAAO,UAAAC,GAAU,SAAAC,KAAW;AACxD,QAAArG,IAAQkG,EAAa,MAAM;AAC3B,SAAAC,EAAA,QAAQ,CAAClI,MAAS;AACpB,IAAA+B,EAAM,KAAK/B,CAAI;AAAA,EAAA,CAClB,GACQmI,EAAA,QAAQ,CAACnI,MAAS;AACjB,UAAAqD,IAAQtB,EAAM,UAAU,CAAC,EAAE,IAAAsG,QAASA,MAAOrI,EAAK,EAAE;AACxD,IAAIqD,MAAU,OAEdtB,EAAMsB,CAAK,IAAIrD;AAAA,EAAA,CAClB,GACOoI,EAAA,QAAQ,CAACpI,MAAS;AAChB,UAAAqD,IAAQtB,EAAM,UAAU,CAAC,EAAE,IAAAsG,QAASA,MAAOrI,EAAK,EAAE;AACxD,IAAIqD,MAAU,MAERtB,EAAA,OAAOsB,GAAO,CAAC;AAAA,EAAA,CACxB,GACMtB;AACX;AAEA,MAAMuG,UAAmB5I,EAAa;AAAA,EAClC,OAAO,MAAMsD,GAAU;AACnB,IAAAsF,EAAW,2BAA2B,IACtCA,EAAW,YAAY,OAAO,CAACnE,GAAMoE,MAAe,MAAMA,EAAW,MAAM,MAAMpE,GAAM,GAAGnB,CAAQ,EAAE,GACpGsF,EAAW,2BAA2B;AAAA,EAAA;AAAA,EAE1C,YAAYrF,GAAS;AACb,QAAAQ,GAAI+E,GAAIC,GAAIC;AAgChB,QA/BM,MAAA,GACN,KAAK,qBAAqB,MAC1B,KAAK,iBAAiB,CAAC,GACvB,KAAK,kBAAkB,IAClB,KAAA,8BAAc,IAAI,GACvB,KAAK,2BAA2B,IAChC,KAAK,aAAa,IACb,KAAA,yCAAyB,IAAI,GACvBJ,EAAA,YAAY,KAAK,IAAI,GAC3B,KAAA,UAAU,OAAO,OAAO,EAAE,QAAQ,CAAA,KAAMrF,CAAO,GAC/C,KAAA,aAAaQ,IAAK,KAAK,QAAQ,qBAAqB,QAAQA,MAAO,SAASA,IAAK6E,EAAW,WACjG,KAAK,iBAAiB;AAAA,MAClBV,EAAoB,MAAM,KAAK,OAAO;AAAA,MACtC,GAAI,KAAK,QAAQ,WAAW,CAAA;AAAA,IAChC,GACA,KAAK,eAAe,GACf,KAAA,kBAAkBtG,GAAckH,IAAK,KAAK,QAAQ,gBAAgB,QAAQA,MAAO,SAAS,SAASA,EAAG,OAAO,GAAG,CAAC,EAAEvF,KAAY,QAAsCA,EAAQ,YAAY,GAC9L,KAAK,kBAAkB3B,GAAcmH,IAAK,KAAK,QAAQ,gBAAgB,QAAQA,MAAO,SAAS,SAASA,EAAG,UAAU,EAAK,GACrH,KAAA,GAAG,2BAA2B,MAAM;AAChC,WAAA,gBAAgB,IAAI,EAAI;AAAA,IAAA,CAChC,GACI,KAAA,GAAG,6BAA6B,MAAM;AAClC,WAAA,gBAAgB,IAAI,EAAK;AAAA,IAAA,CACjC,GACI,KAAA,GAAG,2BAA2B,MAAM;AAChC,WAAA,gBAAgB,IAAI,EAAI;AAAA,IAAA,CAChC,GACI,KAAA,GAAG,6BAA6B,MAAM;AAClC,WAAA,gBAAgB,IAAI,EAAK;AAAA,IAAA,CACjC,GACI,KAAA,sBAAsBC,IAAK,KAAK,QAAQ,iBAAiB,QAAQA,MAAO,SAASA,IAAK,MACvF,KAAK,oBAAoB;AACzB,UAAIC,IAAe,GACfC,IAAgB;AACd,YAAAb,IAAiB,EAAE,OAAO,CAAA,GAAI,UAAU,CAAC,GAAG,SAAS,GAAG,GACxDc,IAAqB,OAAOC,MAAS;AACvC,YAAI,CAAC,KAAK;AACA,gBAAA,IAAI,MAAM,+BAA+B;AACnD,aAAK,KAAK,yBAAyB;AAEnC,cAAM,EAAE,OAAA/G,GAAO,SAAAgH,MAAYD,KAA0C,MAAM,KAAK,mBAAmB,KAAK;AACxG,YAAI/G,GAAO;AAEP,cAAI4G,IAAe;AACf;AAEC,eAAA,SAAS,OAAO,GAAG,KAAK,YAAY,EAAE,QAAQ,GAAG5G,CAAK,GAC3D,KAAK,QAAQ,MAAM,GAEnB,KAAK,OAAO,EAAE,IAAI,CAAC/B,GAAMqD,MAAU;AAC1B,iBAAA,QAAQ,IAAIhC,EAAerB,EAAK,EAAE,GAAG,oBAAI,IAAI,CAACqD,CAAK,CAAC,CAAC;AAAA,UAAA,CAC7D;AAAA,eAEI0F,MACGA,EAAA,MAAM,QAAQ,CAAC/I,MAAS;AACtB,gBAAAqD,IAAQ,KAAK,OAAO,EAAE,UAAU,CAAO2F,MAAAA,EAAI,OAAOhJ,EAAK,EAAE;AAC/D,cAAIqD,KAAS,GAAG;AACZ,iBAAK,OAAO,EAAE,OAAOA,GAAO,GAAGrD,CAAI;AACnC;AAAA,UAAA;AAGC,eAAA,OAAA,EAAS,KAAKA,CAAI;AACvB,gBAAMiJ,IAAY,KAAK,SAAS,UAAU,CAAAD,MAAOA,MAAQhJ,CAAI;AACxD,eAAA,QAAQ,IAAIqB,EAAerB,EAAK,EAAE,GAAG,oBAAI,IAAI,CAACiJ,CAAS,CAAC,CAAC;AAAA,QAAA,CACjE,GACOF,EAAA,SAAS,QAAQ,CAAC/I,MAAS;AACzB,gBAAAqD,IAAQ,KAAK,OAAO,EAAE,UAAU,CAAO2F,MAAAA,EAAI,OAAOhJ,EAAK,EAAE;AAC/D,cAAIqD,MAAU;AACJ,kBAAA,IAAI,MAAM,+BAA+B;AACnD,eAAK,OAAO,EAAE,OAAOA,GAAO,GAAGrD,CAAI;AAAA,QAAA,CACtC,GACO+I,EAAA,QAAQ,QAAQ,CAAC/I,MAAS;AACxB,gBAAAqD,IAAQ,KAAK,OAAO,EAAE,UAAU,CAAO2F,MAAAA,EAAI,OAAOhJ,EAAK,EAAE;AAC/D,cAAIqD,MAAU;AACJ,kBAAA,IAAI,MAAM,+BAA+B;AACnD,eAAK,OAAO,EAAE,OAAOA,GAAO,CAAC;AAAA,QAAA,CAChC;AAEL,aAAK,eAAe,GACpB,KAAK,KAAK,sBAAsB,GAGhC,WAAW,MAAM,KAAK,KAAK,2BAA2B,GAAG,CAAC;AAAA,MAC9D,GACM6F,IAAY;AAAA,QACd,OAAO,CAAC;AAAA,QACR,UAAU,CAAC;AAAA,QACX,SAAS,CAAA;AAAA,MACb;AACA,UAAIC,IAAa;AACjB,YAAMC,IAAa,MAAM;AACrB,YAAI,CAAC,KAAK;AACA,gBAAA,IAAI,MAAM,+BAA+B;AAK/C,YAJAT,KAAgB,KAChB,KAAK,KAAK,yBAAyB,GACnCQ,KAEA,CAACrB,EAAkBoB,CAAS;AAC5B;AACS,QAAAC,IAAA,IACGR,KAAA;AACV,cAAAV,IAAe,KAAK,YAAY,GAChCc,IAAU,OAAO,OAAO,CAAA,GAAIG,CAAS;AAC3C,QAAAA,EAAU,QAAQ,CAAC,GACnBA,EAAU,WAAW,CAAC,GACtBA,EAAU,UAAU,CAAC,GACrB,KAAK,mBAAmB,KAAKjB,GAAcc,CAAO,EAC7C,KAAK,MAAM;AACZ,eAAK,KAAK,yBAAyB;AAAA,QAAA,CACtC,EAAE,MAAM,CAACM,MAAU;AACX,eAAA,KAAK,qBAAqBA,aAAiB,QAAQA,IAAQ,IAAI,MAAMA,CAAK,CAAC;AAAA,QAAA,CACnF,EAAE,QAAQ,MAAM;AACG,UAAAV,KAAA,GACHQ,IAAA,IACFC,EAAA,GACPT,KAAgB,KAChB,KAAK,KAAK,2BAA2B;AAAA,QAAA,CAC5C;AAAA,MACL;AACK,WAAA,GAAG,SAAS,CAAC3I,MAAS;AACvB,YAAI,CAAC4I,GAAe;AACD,UAAAb,EAAA,MAAM,KAAK/H,CAAI;AAC9B;AAAA,QAAA;AAEM,QAAAkJ,EAAA,MAAM,KAAKlJ,CAAI,GACdoJ,EAAA;AAAA,MAAA,CACd,GACI,KAAA,GAAG,WAAW,CAACpJ,MAAS;AACzB,YAAI,CAAC4I,GAAe;AACD,UAAAb,EAAA,SAAS,KAAK/H,CAAI;AACjC;AAAA,QAAA;AAEM,QAAAkJ,EAAA,SAAS,KAAKlJ,CAAI,GACjBoJ,EAAA;AAAA,MAAA,CACd,GACI,KAAA,GAAG,WAAW,CAACpJ,MAAS;AACzB,YAAI,CAAC4I,GAAe;AACD,UAAAb,EAAA,QAAQ,KAAK/H,CAAI;AAChC;AAAA,QAAA;AAEM,QAAAkJ,EAAA,QAAQ,KAAKlJ,CAAI,GAChBoJ,EAAA;AAAA,MAAA,CACd,GACI,KAAA,mBAAmB,SAAS,CAAQN,MAAAD,EAAmBC,CAAI,CAAC,EAC5D,KAAK,YAAY;AAClB,YAAI,CAAC,KAAK;AACA,gBAAA,IAAI,MAAM,+BAA+B;AAC/C,YAAAb,IAAe,KAAK,YAAY;AAE7B,aADP,MAAMY,EAAmB,GAClBf,EAAkBC,CAAc,KAAG;AACtC,gBAAMG,IAAQH,EAAe,MAAM,OAAO,CAAC,GACrCI,IAAWJ,EAAe,SAAS,OAAO,CAAC,GAC3CK,IAAUL,EAAe,QAAQ,OAAO,CAAC;AAChC,UAAAE,IAAAD,GAAa,KAAK,YAAY,GAAG,EAAE,OAAAE,GAAO,UAAAC,GAAU,SAAAC,GAAS,GAEtE,MAAA,KAAK,mBAAmB,KAAKH,GAAc,EAAE,OAAAC,GAAO,UAAAC,GAAU,SAAAC,EAAQ,CAAC,EACxE,KAAK,MAAM;AACZ,iBAAK,KAAK,yBAAyB;AAAA,UAAA,CACtC;AAAA,QAAA;AAEL,cAAMS,EAAmB,GACTD,IAAA,IAGhB,WAAW,MAAM,KAAK,KAAK,kBAAkB,GAAG,CAAC;AAAA,MAAA,CACpD,EACI,MAAM,CAACS,MAAU;AACb,aAAA,KAAK,qBAAqBA,aAAiB,QAAQA,IAAQ,IAAI,MAAMA,CAAK,CAAC;AAAA,MAAA,CACnF;AAAA,IAAA;AAAA,EACL;AAAA,EAEJ,YAAY;AACJ,QAAA5F;AACI,YAAAA,IAAK,KAAK,gBAAgB,IAAA,OAAW,QAAQA,MAAO,SAASA,IAAK;AAAA,EAAA;AAAA,EAE9E,YAAY;AACJ,QAAAA;AACI,YAAAA,IAAK,KAAK,gBAAgB,IAAA,OAAW,QAAQA,MAAO,SAASA,IAAK;AAAA,EAAA;AAAA,EAE9E,YAAY;AACF,UAAA6F,IAAY,KAAK,UAAU,GAC3BC,IAAY,KAAK,UAAU;AACjC,WAAOD,KAAaC;AAAA,EAAA;AAAA,EAExB,eAAe;AACX,WAAO,KAAK;AAAA,EAAA;AAAA,EAEhB,aAAaC,GAAQ;AACjB,SAAK,YAAYA;AAAA,EAAA;AAAA,EAErB,QAAQ5G,GAAI6G,GAAiB;AACzB,QAAI,CAAC,KAAK;AACN,aAAO7G,EAAG;AACR,UAAA8G,IAAY,YAAY,IAAI,GAC5BzI,IAAS2B,EAAG,GACZ+G,IAAU,YAAY,IAAI;AAChC,WAAAF,EAAgBE,IAAUD,CAAS,GAC5BzI;AAAA,EAAA;AAAA,EAEX,mBAAmB2B,GAAI;AACnB,QAAI,CAAC,KAAK;AACN;AACJ,UAAMgH,IAAY,IAAI,MAAM,EAAE,SAAS;AACvC,IAAAhH,EAAGgH,CAAS;AAAA,EAAA;AAAA,EAEhB,iBAAiB;AAEb,IADA,KAAK,kBAAkB,IACnB,MAAK,4BAET,KAAK,kBAAkB;AAAA,EAAA;AAAA,EAE3B,oBAAoB;AAChB,SAAK,QAAQ,MAAM,GAEnB,KAAK,OAAO,EAAE,IAAI,CAAC5J,GAAMqD,MAAU;AAC1B,WAAA,QAAQ,IAAIhC,EAAerB,EAAK,EAAE,GAAG,oBAAI,IAAI,CAACqD,CAAK,CAAC,CAAC;AAAA,IAAA,CAC7D,GACI,KAAA,eAAe,QAAQ,CAASA,MAAAA,EAAM,QAAQ,KAAK,YAAA,CAAa,CAAC,GACtE,KAAK,kBAAkB;AAAA,EAAA;AAAA,EAE3B,aAAapD,GAAU;AACnB,WAAIA,KAAY,QACT,OAAO,KAAKA,CAAQ,EAAE,WAAW,KACjC,QAAQA,KACR,OAAOA,EAAS,MAAO,WACnB;AAAA,MACH,SAAS;AAAA,MACT,WAAW,MAAM,KAAK,KAAK,QAAQ,IAAIoB,EAAepB,EAAS,EAAE,CAAC,KAAK,CAAA,CAAE;AAAA,MACzE,mBAAmB,CAAA;AAAA,IACvB,IAEAA,KAAY,QAAQ,KAAK,kBAClB;AAAA,MACH,SAAS;AAAA,MACT,WAAW,CAAC;AAAA,MACZ,mBAAmB,CAAA;AAAA,IACvB,IAEGsG,EAAa,KAAK,gBAAgBtG,CAAQ;AAAA,EAAA;AAAA,EAErD,gBAAgBA,GAAU;AAChB,UAAA4J,IAAS,KAAK,YAAY,GAC1BC,IAAY,KAAK,aAAa7J,CAAQ,GAItCD,KAHQ8J,EAAU,UAClBA,EAAU,UAAU,IAAI,CAAAzG,MAASwG,EAAOxG,CAAK,CAAC,IAC9CwG,GACa,KAAK,OAAO9J,EAAMiJ,GAAK/I,CAAQ,CAAC,GAC7CoD,IAASyG,EAAU,WAClBA,EAAU,UAAU,KAAK,CAAab,MAAAY,EAAOZ,CAAS,MAAMjJ,CAAI,KAChE6J,EAAO,UAAU,CAAAb,MAAOA,MAAQhJ,CAAI;AAC3C,QAAIA,KAAQ;AACR,aAAO,EAAE,MAAM,MAAM,OAAO,GAAG;AACnC,QAAIqD,MAAU;AACJ,YAAA,IAAI,MAAM,+BAA+B;AAC5C,WAAA,EAAE,MAAArD,GAAM,OAAAqD,EAAM;AAAA,EAAA;AAAA,EAEzB,kBAAkBgF,GAAIhF,GAAO;AAGzB,IAFA,KAAK,QAAQ,OAAOhC,EAAegH,CAAE,CAAC,GAEjC,KAAK,4BAEV,KAAK,QAAQ,QAAQ,CAAC,CAAC0B,CAAW,GAAGlJ,MAAQ;AACzC,MAAIkJ,IAAc1G,KACT,KAAA,QAAQ,IAAIxC,GAAK,oBAAI,IAAI,CAACkJ,IAAc,CAAC,CAAC,CAAC;AAAA,IACpD,CACH;AAAA,EAAA;AAAA,EAEL,SAAS;AACL,WAAO,KAAK,QAAQ;AAAA,EAAA;AAAA,EAExB,cAAc;AACV,WAAO,KAAK,OAAS,EAAA,IAAI,OAAQ/J,CAAI;AAAA,EAAA;AAAA,EAEzC,UAAUA,GAAM;AACR,WAAC,KAAK,QAAQ,YAEX,KAAK,QAAQ,UAAUA,CAAI,IADvBA;AAAA,EACuB;AAAA,EAEtC,SAASC,GAAU;AACR,WAAA,KAAK,QAAQ,MAAM;AAChB,YAAA6J,IAAY,KAAK,aAAa7J,CAAQ,GACtC+J,IAAa,CAAChK,MACZ8J,EAAU,qBAAqB,QAE/B,OAAO,KAAKA,EAAU,iBAAiB,EAAE,UAAU,IAC5C,KACK/J,EAAMC,GAAM8J,EAAU,iBAAiB;AAI3D,UAAI,CAACA,EAAU;AACX,eAAO,KAAK,SAAS,OAAOE,CAAU;AACpC,YAAAH,IAAS,KAAK,YAAY,GAC1B9H,IAAQ+H,EAAU,UAAU,IAAI,CAASzG,MAAAwG,EAAOxG,CAAK,CAAC;AACvD,kBAAA,KAAK,YAAYpD,CAAQ,GACvB8B,EAAM,OAAOiI,CAAU;AAAA,IAC/B,GAAA,CAAAC,MAAgB,KAAK,mBAAmB,CAAaL,MAAA,KAAK,KAAK,mBAAmBA,GAAW3J,GAAUgK,CAAY,CAAC,CAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5H,MAAM,UAAU;AACR,QAAAxG;AACJ,IAAK,GAAAA,IAAK,KAAK,wBAAwB,QAAQA,MAAO,WAAkBA,EAAG,cACjE,MAAA,KAAK,mBAAmB,WAAW,GAC7C,KAAK,qBAAqB,MACrB,KAAA,OAAA,EAAS,IAAI,MAAM,KAAK,OAAO,EAAE,KAAK,GAC3C,KAAK,QAAQ,MAAM,GACnB,KAAK,iBAAiB,CAAC,GACvB,KAAK,aAAa;AAAA,EAAA;AAAA,EAEtB,KAAKxD,GAAUgD,GAAS;AACpB,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAC5C,QAAIhD,MAAa,WAAc,CAACA,KAAY,OAAOA,KAAa;AACtD,YAAA,IAAI,MAAM,kBAAkB;AACtC,UAAMiK,IAAS,IAAIlG,EAAO,MAAM,KAAK,SAAS/D,CAAQ,GAAG,OAAO,OAAO,OAAO,OAAO,EAAE,UAAU,KAAK,QAAQ,WAAW,GAAGgD,CAAO,GAAG,EAAE,WAAW,KAAK,UAAU,KAAK,IAAI,GAAG,YAAY,CAACmC,MAAY;AAC/L,YAAM+E,IAAgB,MAAM;AACxB,YAAI,KAAK,0BAA0B;AAC1B,eAAA,mBAAmB,IAAI/E,CAAO;AACnC;AAAA,QAAA;AAEI,QAAAA,EAAA;AAAA,MACZ;AACK,kBAAA,YAAY,wBAAwB+E,CAAa,GACjD,KAAA,YAAY,SAASA,CAAa,GAClC,KAAA,YAAY,WAAWA,CAAa,GACpC,KAAA,YAAY,WAAWA,CAAa,GACpC,KAAA,KAAK,oBAAoBlK,GAAUgD,CAAO,GACxC,MAAM;AACJ,aAAA,eAAe,wBAAwBkH,CAAa,GACpD,KAAA,eAAe,SAASA,CAAa,GACrC,KAAA,eAAe,WAAWA,CAAa,GACvC,KAAA,eAAe,WAAWA,CAAa,GACvC,KAAA,KAAK,qBAAqBlK,GAAUgD,CAAO;AAAA,MACpD;AAAA,IACJ,EAAA,CAAG,CAAC;AACR,gBAAK,KAAK,QAAQhD,GAAUgD,GAASiH,CAAM,GACtC,KAAA,mBAAmB,OAAa,KAAK,KAAK,eAAeN,GAAW3J,GAAUgD,GAASiH,CAAM,CAAC,GAC5FA;AAAA,EAAA;AAAA,EAEX,QAAQjK,GAAUgD,GAAS;AACvB,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAE5C,UAAMmH,IADS,KAAK,KAAKnK,GAAU,OAAO,OAAO,EAAE,OAAO,EAAK,GAAAgD,CAAO,CAAC,EAC5C,MAAM,EAAE,CAAC,KAAK;AACzC,gBAAK,KAAK,WAAWhD,GAAUgD,GAASmH,CAAW,GAC9C,KAAA,mBAAmB,OAAa,KAAK,KAAK,kBAAkBR,GAAW3J,GAAUgD,GAASmH,CAAW,CAAC,GACpGA;AAAA,EAAA;AAAA,EAEX,MAAMpH,GAAU;AACZ,SAAK,2BAA2B,IACvBA,EAAA,GACT,KAAK,2BAA2B,IAEhC,KAAK,kBAAkB,GAEvB,KAAK,mBAAmB,QAAQ,CAAMqH,MAAAA,EAAA,CAAI,GAC1C,KAAK,mBAAmB,MAAM;AAAA,EAAA;AAAA,EAElC,OAAOrK,GAAM;AACT,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAC5C,QAAI,CAACA;AACK,YAAA,IAAI,MAAM,cAAc;AAC5B,UAAA0D,IAAU,OAAO,OAAO,EAAE,IAAI5C,EAAS,KAAKd,CAAI;AACtD,QAAI,KAAK,QAAQ,IAAIqB,EAAeqC,EAAQ,EAAE,CAAC;AACrC,YAAA,IAAI,MAAM,kCAAkC;AACjD,SAAA,OAAA,EAAS,KAAKA,CAAO;AAC1B,UAAMuF,IAAY,KAAK,SAAS,UAAU,CAAAD,MAAOA,MAAQtF,CAAO;AAC3D,gBAAA,QAAQ,IAAIrC,EAAeqC,EAAQ,EAAE,GAAG,oBAAI,IAAI,CAACuF,CAAS,CAAC,CAAC,GACjE,KAAK,eAAe,GACf,KAAA,KAAK,SAASvF,CAAO,GACrB,KAAA,KAAK,UAAUA,CAAO,GAC3B,KAAK,mBAAmB,CAAakG,MAAA,KAAK,KAAK,iBAAiBA,GAAWlG,CAAO,CAAC,GAC5EA,EAAQ;AAAA,EAAA;AAAA,EAEnB,WAAW3B,GAAO;AACd,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAC5C,QAAI,CAACA;AACK,YAAA,IAAI,MAAM,eAAe;AAC/B,QAAAA,EAAM,WAAW;AACjB,aAAO,CAAC;AAEZ,UAAMuI,IAAM,CAAC;AACb,gBAAK,MAAM,MAAM;AACP,MAAAvI,EAAA,QAAQ,CAAC/B,MAAS;AACpB,QAAAsK,EAAI,KAAK,KAAK,OAAOtK,CAAI,CAAC;AAAA,MAAA,CAC7B;AAAA,IAAA,CACJ,GACMsK;AAAA,EAAA;AAAA,EAEX,UAAUrK,GAAUG,GAAU;AAC1B,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAC5C,QAAI,CAACH;AACK,YAAA,IAAI,MAAM,kBAAkB;AACtC,QAAI,CAACG;AACK,YAAA,IAAI,MAAM,kBAAkB;AACtC,UAAM,EAAE,MAAAJ,GAAM,OAAAqD,EAAA,IAAU,KAAK,gBAAgBpD,CAAQ;AACrD,QAAID,KAAQ;AACD,aAAA;AACX,UAAMuK,IAAepK,EAAOgB,EAAUnB,CAAI,GAAGI,CAAQ,GAE/CoK,IAAe,KAAK,QAAQ,EAAE,IAAID,EAAa,MAAM,EAAE,UAAU,IAAO;AAC9E,QAAI,CAAChK,EAAQiK,GAAc,OAAO,OAAO,OAAO,OAAO,CAAA,GAAIA,CAAY,GAAG,EAAE,IAAID,EAAa,GAAI,CAAA,CAAC;AACxF,YAAA,IAAI,MAAM,kCAAkC;AACtD,gBAAK,OAAO,EAAE,OAAOlH,GAAO,GAAGkH,CAAY,GAC3C,KAAK,eAAe,GACf,KAAA,KAAK,WAAWA,GAAcnK,CAAQ,GACtC,KAAA,KAAK,aAAaH,GAAUG,CAAQ,GACpC,KAAA,mBAAmB,OAAa,KAAK,KAAK,oBAAoBwJ,GAAW3J,GAAUG,CAAQ,CAAC,GAC1F;AAAA,EAAA;AAAA,EAEX,WAAWH,GAAUG,GAAU;AAC3B,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAC5C,QAAI,CAACH;AACK,YAAA,IAAI,MAAM,kBAAkB;AACtC,QAAI,CAACG;AACK,YAAA,IAAI,MAAM,kBAAkB;AAChC,UAAA2B,IAAQ,KAAK,SAAS9B,CAAQ,GAC9BwK,IAAgB,CAAC;AACjB,WAAA1I,EAAA,QAAQ,CAAC/B,MAAS;AACd,YAAA,EAAE,OAAAqD,EAAU,IAAA,KAAK,gBAAgB,EAAE,IAAIrD,EAAK,IAAI;AACtD,UAAIqD,MAAU;AACJ,cAAA,IAAI,MAAM,+BAA+B;AACnD,YAAMkH,IAAepK,EAAOgB,EAAUnB,CAAI,GAAGI,CAAQ;AACrD,WAAK,OAAO,EAAE,OAAOiD,GAAO,GAAGkH,CAAY,GAC3CE,EAAc,KAAKF,CAAY;AAAA,IAAA,CAClC,GACD,KAAK,eAAe,GACNE,EAAA,QAAQ,CAACF,MAAiB;AAC/B,WAAA,KAAK,WAAWA,GAAcnK,CAAQ;AAAA,IAAA,CAC9C,GACI,KAAA,KAAK,cAAcH,GAAUG,CAAQ,GACrC,KAAA,mBAAmB,OAAa,KAAK,KAAK,qBAAqBwJ,GAAW3J,GAAUG,CAAQ,CAAC,GAC3FqK,EAAc;AAAA,EAAA;AAAA,EAEzB,UAAUxK,GAAU;AAChB,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAC5C,QAAI,CAACA;AACK,YAAA,IAAI,MAAM,kBAAkB;AACtC,UAAM,EAAE,MAAAD,GAAM,OAAAqD,EAAA,IAAU,KAAK,gBAAgBpD,CAAQ;AACrD,WAAID,KAAQ,SACR,KAAK,OAAO,EAAE,OAAOqD,GAAO,CAAC,GACxB,KAAA,kBAAkBrD,EAAK,IAAIqD,CAAK,GACrC,KAAK,eAAe,GACf,KAAA,KAAK,WAAWrD,CAAI,IAExB,KAAA,KAAK,aAAaC,CAAQ,GAC/B,KAAK,mBAAmB,CAAa2J,MAAA,KAAK,KAAK,oBAAoBA,GAAW3J,CAAQ,CAAC,GAChFD,KAAQ,OAAO,IAAI;AAAA,EAAA;AAAA,EAE9B,WAAWC,GAAU;AACjB,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,wBAAwB;AAC5C,QAAI,CAACA;AACK,YAAA,IAAI,MAAM,kBAAkB;AAChC,UAAA8B,IAAQ,KAAK,SAAS9B,CAAQ;AAC9B,WAAA8B,EAAA,QAAQ,CAAC/B,MAAS;AACpB,YAAMqD,IAAQ,KAAK,SAAS,UAAU,CAAA2F,MAAOA,MAAQhJ,CAAI;AACzD,UAAIqD,MAAU;AACJ,cAAA,IAAI,MAAM,+BAA+B;AACnD,WAAK,OAAO,EAAE,OAAOA,GAAO,CAAC,GACxB,KAAA,kBAAkBrD,EAAK,IAAIqD,CAAK,GACrC,KAAK,eAAe;AAAA,IAAA,CACvB,GACKtB,EAAA,QAAQ,CAAC/B,MAAS;AACf,WAAA,KAAK,WAAWA,CAAI;AAAA,IAAA,CAC5B,GACI,KAAA,KAAK,cAAcC,CAAQ,GAChC,KAAK,mBAAmB,CAAa2J,MAAA,KAAK,KAAK,qBAAqBA,GAAW3J,CAAQ,CAAC,GACjF8B,EAAM;AAAA,EAAA;AAErB;AACAuG,EAAW,cAAc,CAAC;AAC1BA,EAAW,YAAY;AACvBA,EAAW,2BAA2B;AACtCA,EAAW,kBAAkB,MAAM;AAC/B,EAAAA,EAAW,YAAY,IACZA,EAAA,YAAY,QAAQ,CAACC,MAAe;AAC3C,IAAAA,EAAW,aAAa,EAAI;AAAA,EAAA,CAC/B;AACL;ACphBA,SAAwBmC,GAAyBrD,GAAY;AAClD,SAAAA;AACX;ACDwB,SAAAsD,EAA0BC,GAAM3H,GAAS;AACvD,QAAA,EAAE,WAAA4H,IAAY,KAAK,WAAW,aAAAC,IAAc,KAAK,UAAU7H,KAAW,CAAC,GACvE8H,IAAe,uBAAuBH,CAAI;AAChD,WAAS3G,IAAW;AAChB,WAAO6G,EAAY,aAAa,QAAQC,CAAY,KAAK,IAAI;AAAA,EAAA;AAEjE,SAAgC;AAAA,IAC5B,MAAM,OAAO;AACT,YAAMhJ,IAAQkC,EAAS;AACvB,aAAO,QAAQ,QAAQ,EAAE,OAAAlC,GAAO;AAAA,IACpC;AAAA,IACA,MAAM,KAAKA,GAAO,EAAE,OAAAmG,GAAO,UAAAC,GAAU,SAAAC,KAAW;AAC5C,YAAMH,IAAehE,EAAS;AACxB,aAAAiE,EAAA,QAAQ,CAAClI,MAAS;AACpB,QAAAiI,EAAa,KAAKjI,CAAI;AAAA,MAAA,CACzB,GACQmI,EAAA,QAAQ,CAACnI,MAAS;AACjB,cAAAqD,IAAQ4E,EAAa,UAAU,CAAC,EAAE,IAAAI,QAASA,MAAOrI,EAAK,EAAE;AAAA,QAAA;AAE/D,YAAIqD,MAAU;AACV,gBAAM,IAAI,MAAM,gBAAgBrD,EAAK,EAAE,YAAY;AACvD,QAAAiI,EAAa5E,CAAK,IAAIrD;AAAA,MAAA,CACzB,GACOoI,EAAA,QAAQ,CAACpI,MAAS;AAChB,cAAAqD,IAAQ4E,EAAa,UAAU,CAAC,EAAE,IAAAI,QAASA,MAAOrI,EAAK,EAAE;AAAA,QAAA;AAE/D,YAAIqD,MAAU;AACV,gBAAM,IAAI,MAAM,gBAAgBrD,EAAK,EAAE,YAAY;AAC1C,QAAAiI,EAAA,OAAO5E,GAAO,CAAC;AAAA,MAAA,CAC/B,GACD,aAAa,QAAQ0H,GAAcF,EAAU5C,CAAY,CAAC,GACnD,QAAQ,QAAQ;AAAA,IAC3B;AAAA,IACA,MAAM,WAAW;AACb,aAAO,QAAQ,QAAQ;AAAA,IAAA;AAAA,EAC3B;AAER;ACrCwB,SAAA+C,GAAwBC,GAAUhI,GAAS;AACzD,QAAA,EAAE,WAAA4H,IAAY,KAAK,WAAW,aAAAC,IAAc,KAAK,UAAU7H,KAAW,CAAC;AAC7E,MAAIiI,IAAc;AAClB,iBAAejH,IAAW;AAChB,UAAAkH,IAAK,MAAM,OAAO,IAAI;AAE5B,QAAI,CADW,MAAMA,EAAG,SAAS,OAAOF,CAAQ,EAAE,KAAK,MAAM,EAAI,EAAE,MAAM,MAAM,EAAK;AAEhF,aAAO,CAAC;AACN,UAAAG,IAAW,MAAMD,EAAG,SAAS,SAASF,GAAU,MAAM,EAAE,MAAM,CAACI,MAAQ;AAAA,MAAA;AAEzE,UAAIA,EAAI,SAAS;AACN,eAAA;AAAA,MAAA;AAEL,YAAAA;AAAA,IAAA,CACT;AACD,WAAOP,EAAYM,CAAQ;AAAA,EAAA;AAE/B,SAAgC;AAAA,IAC5B,MAAM,SAASE,GAAU;AACrB,UAAI,OAAO,SAAW;AACZ,cAAA,IAAI,MAAM,oDAAoD;AAClE,YAAAH,IAAK,MAAM,OAAO,IAAI;AAE5B,MADe,MAAMA,EAAG,SAAS,OAAOF,CAAQ,EAAE,KAAK,MAAM,EAAI,EAAE,MAAM,MAAM,EAAK,KAEhF,MAAME,EAAG,SAAS,UAAUF,GAAU,IAAI,GAC9CE,EAAG,MAAMF,GAAU,EAAE,UAAU,UAAU,MAAM;AAC3C,QAAKK,EAAS;AAAA,MAAA,CACjB;AAAA,IACL;AAAA,IACA,MAAM,OAAO;AACT,UAAI,OAAO,SAAW;AACZ,cAAA,IAAI,MAAM,oDAAoD;AACpE,aAAAJ,KACM,MAAAA,GAEH,EAAE,OADK,MAAMjH,EAAS,EACd;AAAA,IACnB;AAAA,IACA,MAAM,KAAKsH,GAAQ,EAAE,OAAArD,GAAO,UAAAC,GAAU,SAAAC,KAAW;AAC7C,UAAI,OAAO,SAAW;AACZ,cAAA,IAAI,MAAM,oDAAoD;AACpE,MAAA8C,KACM,MAAAA,GACVA,IAAcjH,EAAS,EAClB,KAAK,CAACgE,MAAiB;AAClB,cAAAlG,IAAQkG,EAAa,MAAM;AAC3B,eAAAC,EAAA,QAAQ,CAAClI,MAAS;AACpB,UAAA+B,EAAM,KAAK/B,CAAI;AAAA,QAAA,CAClB,GACQmI,EAAA,QAAQ,CAACnI,MAAS;AACjB,gBAAAqD,IAAQtB,EAAM,UAAU,CAAC,EAAE,IAAAsG,QAASA,MAAOrI,EAAK,EAAE;AAAA,UAAA;AAExD,cAAIqD,MAAU;AACV,kBAAM,IAAI,MAAM,gBAAgBrD,EAAK,EAAE,YAAY;AACvD,UAAA+B,EAAMsB,CAAK,IAAIrD;AAAA,QAAA,CAClB,GACOoI,EAAA,QAAQ,CAACpI,MAAS;AAChB,gBAAAqD,IAAQtB,EAAM,UAAU,CAAC,EAAE,IAAAsG,QAASA,MAAOrI,EAAK,EAAE;AAAA,UAAA;AAExD,cAAIqD,MAAU;AACV,kBAAM,IAAI,MAAM,gBAAgBrD,EAAK,EAAE,YAAY;AACjD,UAAA+B,EAAA,OAAOsB,GAAO,CAAC;AAAA,QAAA,CACxB,GACMtB;AAAA,MAAA,CACV,EACI,KAAK,OAAOA,MAAU;AAEvB,eADW,MAAM,OAAO,IAAI,GACnB,SAAS,UAAUkJ,GAAUJ,EAAU9I,CAAK,CAAC;AAAA,MAAA,CACzD,EACI,KAAK,MAAM;AACE,QAAAmJ,IAAA;AAAA,MAAA,CACjB,GACK,MAAAA;AAAA,IAAA;AAAA,EACV;AAER;ACxEA,SAASM,GAAcZ,GAAM;AACrB,SAAA,OAAO,SAAW,MACXI,GAAwB,yBAAyBJ,CAAI,OAAO,IAEhED,EAA0BC,CAAI;AACzC;AAEA,MAAqBa,WAA6BnD,EAAW;AAAA,EACzD,YAAYsC,GAAM3H,GAAS;AACjB,UAAA,OAAO,OAAO,EAAE,aAAauI,GAAcZ,CAAI,KAAK3H,CAAO,CAAC;AAAA,EAAA;AAE1E;ACbgB,SAAAyI,GAAgCC,GAAyBC,GAA0B3I,GAAS;AACpG,MAAAQ;AACJ,QAAMoI,KAAgBpI,IAAKR,KAAY,OAA6B,SAASA,EAAQ,kBAAkB,QAAQQ,MAAO,SAASA,IAAK;AACpI,MAAIqI,IAAa,IACbC,IAAgB,MAChBC,IAAU,MACVC,IAAmB;AACvB,SAAO,IAAInM,MAAS;AAChB,QAAImM,KAAoB;AACpB,MAAID,MACA,aAAaA,CAAO,GACVA,IAAA,OAEdC,IAAmBL,EAAyB,GAAG9L,CAAI,EAAE,KAAK,CAACmB,OACnD4K,IAAe,MACfG,IAAU,WAAW,MAAM;AACV,QAAAF,IAAA,IACGC,IAAA,MACGE,IAAA;AAAA,SACpBJ,CAAY,IAENC,IAAA,IACGC,IAAA9K,GACZgC,KAAY,QAAsCA,EAAQ,aAC1DA,EAAQ,UAAU8I,CAAa,GAC5B9K,EACV;AAAA,aAEI6K;AACE,aAAAG;AAEJ,WAAAN,EAAwB,GAAG7L,CAAI;AAAA,EAC1C;AACJ;AACwB,SAAAoM,GAA2BC,GAASC,GAAWnJ,GAAS;AACxE,MAAAQ;AACJ,QAAM4I,KAAkB5I,IAAKR,KAAY,OAA6B,SAASA,EAAQ,oBAAoB,QAAQQ,MAAO,SAASA,IAAK,aAClI6I,IAAiBD,MAAmB,YAAYF,IAAUC,GAC1DG,IAAmBF,MAAmB,YAAYD,IAAYD;AACpE,MAAIK,IAAe;AACb,QAAAC,IAAef,GAAgC,MAAMY,EAAe,QAAQ,MAAMC,EAAiB,QAAQ;AAAA,IAC7G,cAAc;AAAA,IACd,WAAW,CAACtL,MAAW;AACnB,UAAIwC,GAAI+E,GAAIC;AACR,MAAA+D,KACKA,EAAa,GACjBF,EAAe,KAAKrL,EAAO,SAAS,CAAA,GAAI;AAAA,QACzC,SAASwC,IAAKxC,EAAO,aAAa,QAAQwC,MAAO,SAAS,SAASA,EAAG,UAAU,CAAC;AAAA,QACjF,YAAY+E,IAAKvH,EAAO,aAAa,QAAQuH,MAAO,SAAS,SAASA,EAAG,aAAa,CAAC;AAAA,QACvF,WAAWC,IAAKxH,EAAO,aAAa,QAAQwH,MAAO,SAAS,SAASA,EAAG,YAAY,CAAA;AAAA,MAAC,CACxF;AAAA,IAAA;AAAA,EACL,CACH;AACD,SAAgC;AAAA,IAC5B,MAAM,SAAS6C,GAAU;AACN,MAAAkB,IAAAlB,GACT,MAAA,QAAQ,IAAI,CAACa,EAAQ,SAASb,CAAQ,GAAGc,EAAU,SAASd,CAAQ,CAAC,CAAC;AAAA,IAChF;AAAA,IACA,MAAM,OAAO;AAEF,aADSmB,EAAa;AAAA,IAEjC;AAAA,IACA,MAAM,KAAK1K,GAAOgH,GAAS;AACvB,YAAM,QAAQ,IAAI;AAAA,QACduD,EAAe,KAAKvK,GAAOgH,CAAO;AAAA,QAClCwD,EAAiB,KAAKxK,GAAOgH,CAAO;AAAA,MAAA,CACvC;AAAA,IAAA;AAAA,EACL;AAER;AClEO,SAAS2D,GAAyBzJ,GAAS;AAC9C,SAAgC;AAAA,IAC5B,MAAM,SAASqI,GAAU;AACrB,MAAKrI,EAAQ,wBAEP,MAAAA,EAAQ,qBAAqBqI,CAAQ;AAAA,IAC/C;AAAA,IACA,MAAM,MAAMrI,EAAQ,KAAK;AAAA,IACzB,MAAM,CAAClB,GAAOgH,MAAY;AACtB,UAAI,CAAC9F,EAAQ;AACH,cAAA,IAAI,MAAM,yGAAyG;AACtH,aAAAA,EAAQ,KAAK8F,GAAShH,CAAK;AAAA,IAAA;AAAA,EACtC;AAER;AACA,MAAqB4K,WAA6BrE,EAAW;AAAA,EACzD,YAAYrF,GAAS;AACjB,QAAIQ,GAAI+E;AACR,UAAMoE,IAAqBF,GAAyB;AAAA,MAChD,sBAAsBzJ,EAAQ;AAAA,MAC9B,MAAM,YAAY;AACT,aAAA,sBAAsB,IAAI,EAAI;AAC/B,YAAA;AACO,iBAAA,MAAMA,EAAQ,KAAK;AAAA,QAAA,UAE9B;AACS,eAAA,sBAAsB,IAAI,EAAK;AAAA,QAAA;AAAA,MAE5C;AAAA,MACA,MAAMA,EAAQ,OAAQ,OAAO8F,GAAShH,MAAU;AAC5C,YAAI,CAACkB,EAAQ;AACH,gBAAA,IAAI,MAAM,yGAAyG;AACxH,aAAA,sBAAsB,IAAI,EAAI;AAC/B,YAAA;AACM,gBAAAA,EAAQ,KAAK8F,GAAShH,CAAK;AAAA,QAAA,UAErC;AACS,eAAA,sBAAsB,IAAI,EAAK;AAAA,QAAA;AAAA,MACxC,IACC;AAAA,IAAA,CACR,GACK8K,IAAsB5J,KAAY,QAAsCA,EAAQ,cAChFiJ,GAA2BU,GAAoB3J,EAAQ,WAAW,IAClE2J;AACN,UAAM,OAAO,OAAO,OAAO,OAAO,IAAI3J,CAAO,GAAG,EAAE,aAAa4J,EAAoB,CAAA,CAAC,GACpF,KAAK,wBAAwBvL,GAAcmC,IAAKR,EAAQ,gBAAgB,QAAQQ,MAAO,SAAS,SAASA,EAAG,OAAO,GAAG,EAAK,GAC3H,KAAK,wBAAwBnC,GAAckH,IAAKvF,EAAQ,gBAAgB,QAAQuF,MAAO,SAAS,SAASA,EAAG,OAAO,GAAG,EAAK;AAAA,EAAA;AAAA,EAE/H,YAAY;AACF,UAAAsE,IAAkB,KAAK,sBAAsB,IAAI,GACjDC,IAAkB,KAAK,sBAAsB,IAAI,GACjDC,IAAY,MAAM,UAAU;AAClC,WAAOF,KAAmBC,KAAmBC;AAAA,EAAA;AAErD;ACrDA,MAAqBC,WAA4BN,GAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMlE,YAAY1J,GAAS;AACb,QAAAQ,GAAI+E,GAAIC,GAAIC;AACZ,QAAAwE;AA4BJ,QA3BA,MAAM,OAAO,OAAO,OAAO,OAAO,CAAA,GAAIjK,CAAO,GAAG,EAAE,MAAM,MAAM,QAAQ,QAAQ;AAAA,MACtE,OAAO,CAAC,GAAG,KAAK,WAAW,OAAQ,CAAA,EAAE,OAAO,CAACkB,GAAMpC,MAAU;AACnD,cAAAoB,IAAW,CAAC,GAAGgB,CAAI;AACnB,eAAApC,EAAA,QAAQ,CAAC/B,MAAS;AACpB,gBAAMqD,IAAQF,EAAS,UAAU,OAAKvC,EAAE,OAAOZ,EAAK,EAAE;AACtD,cAAIqD,MAAU,IAAI;AACd,YAAAF,EAAS,KAAKnD,CAAI;AAClB;AAAA,UAAA;AAEJ,UAAAmD,EAASE,CAAK,IAAI,KAAK,WAAWF,EAASE,CAAK,GAAGrD,CAAI;AAAA,QAAA,CAC1D,GACMmD;AAAA,MAAA,GACR,CAAE,CAAA;AAAA,IAAA,CACR,GAAG,sBAAsB,OAAOmI,OACP4B,IAAA5B,GACf,QAAQ,QAAQ,GAC3B,CAAG,CAAC,GACH,KAAA,sCAAsB,IAAI,GAC1B,KAAA,uCAAuB,IAAI,GAC3B,KAAA,mCAAmB,IAAI,GACvB,KAAA,iCAAiB,IAAI,GAC1B,KAAK,gBAAgB,MACrB,KAAK,oBAAoB,MACpB,KAAA,qCAAqB,IAAI,GAC9B,KAAK,cAAc7H,IAAKR,EAAQ,gBAAgB,QAAQQ,MAAO,SAASA,IAAM,CAAC0J,GAAOC,MAAW,OAAO,OAAO,OAAO,OAAO,CAAI,GAAAD,CAAK,GAAGC,CAAK,GAC9I,KAAK,cAAc5E,IAAKvF,EAAQ,gBAAgB,QAAQuF,MAAO,SAASA,IAAK,KAC7E,KAAK,mBAAmBlH,GAAcmH,IAAKxF,EAAQ,gBAAgB,QAAQwF,MAAO,SAAS,SAASA,EAAG,OAAO,GAAG,EAAK,GAClH,CAACyE;AACK,YAAA,IAAI,MAAM,6FAA6F;AACjH,SAAK,gBAAgBA,GACrB,KAAK,qBAAqBxE,IAAKzF,EAAQ,gBAAgB,QAAQyF,MAAO,SAASA,IAAK,MACpF,KAAK,kBAAkBzF,EAAQ,iBAC/B,KAAK,GAAG,oBAAoB,CAAYhD,MAAA,KAAK,uBAAuBA,KAAsD,CAAE,CAAA,CAAC,GAC7H,KAAK,GAAG,qBAAqB,CAAAA,MAAY,WAAW,MAAM,KAAK,uBAAuBA,KAAsD,CAAE,CAAA,GAAG,GAAG,CAAC,GACjJgD,EAAQ,wBACHA,EAAQ,qBAAqB,MAAM,KAAK,cAAc;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMJ,cAAchD,GAAU;AACpB,SAAK,uBAAuBA,CAAQ;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMxC,gBAAgBA,GAAU;AACtB,SAAK,uBAAuBA,CAAQ;AAAA,EAAA;AAAA;AAAA,EAGxC,kBAAkBA,GAAU;AACjB,WAAA,KAAK,UAAUA,CAAQ;AAAA,EAAA;AAAA,EAElC,MAAM,eAAe;AACV,WAAA,QAAQ,IAAI,CAAC,GAAG,KAAK,gBAAgB,OAAA,CAAQ,EAAE,IAAI,CAAC,EAAE,UAAAA,QAAe,KAAK,cAAcA,CAAQ,CAAC,CAAC,EAAE,KAAK,MAAM;AAAA,IAAA,CAAG;AAAA,EAAA;AAAA,EAE7H,cAAcA,GAAU;AACf,gBAAA,iBAAiB,IAAI,EAAI,GACvB,KAAK,gBAAgBA,CAAQ,EAC/B,KAAK,CAACoN,MAAa;AACpB,UAAI,CAACA,EAAS;AACJ,cAAA,IAAI,MAAM,oEAAoE;AAaxF,UAXA,KAAK,WAAW,IAAI,KAAK,kBAAkBpN,CAAQ,GAAGoN,EAAS,KAAK,GAC3DA,EAAA,MAAM,QAAQ,CAACrN,MAAS;AACzB,YAAAyD;AACJ,cAAM6J,KAAW7J,IAAK,KAAK,aAAa,IAAIzD,EAAK,EAAE,OAAO,QAAQyD,MAAO,SAASA,IAAK,CAAC;AACxF,QAAA6J,EAAQ,KAAKrN,CAAQ,GACrB,KAAK,aAAa,IAAID,EAAK,IAAIsN,CAAO;AAAA,MAAA,CACzC,GACI,KAAA,WAAWrN,GAAU,EAAI,GACzB,KAAA,KAAK,wBAAwB,MAAM;AAC/B,aAAA,WAAWA,GAAU,EAAK;AAAA,MAAA,CAClC,GACG,CAAC,KAAK;AACA,cAAA,IAAI,MAAM,uFAAuF;AAC3G,MAAK,KAAK,cAAc;AAAA,IAAA,CAC3B,EACI,MAAM,CAACoJ,MAAU;AACb,WAAA,KAAK,qBAAqBA,CAAK;AAAA,IAAA,CACvC,EACI,QAAQ,MAAM;AACV,WAAA,iBAAiB,IAAI,EAAK;AAAA,IAAA,CAClC;AAAA,EAAA;AAAA,EAEL,uBAAuBpJ,GAAU;AAC7B,QAAIwD,GAAI+E;AACF,UAAA+E,KAAmB/E,KAAM/E,IAAK,KAAK,gBAAgB,IAAI,KAAK,kBAAkBxD,CAAQ,CAAC,OAAO,QAAQwD,MAAO,SAAS,SAASA,EAAG,WAAW,QAAQ+E,MAAO,SAASA,IAAK;AAEhL,SAAK,gBAAgB,IAAI,KAAK,kBAAkBvI,CAAQ,GAAG;AAAA,MACvD,UAAAA;AAAA,MACA,OAAOsN,IAAkB;AAAA,IAAA,CAC5B;AACD,UAAMvB,IAAU,KAAK,iBAAiB,IAAI,KAAK,kBAAkB/L,CAAQ,CAAC;AACtE,IAAA+L,KACA,aAAaA,CAAO,GAEpBuB,MAAoB,KACf,KAAK,cAActN,CAAQ;AAAA,EAAA;AAAA,EAExC,uBAAuBA,GAAU;AAC7B,QAAIwD,GAAI+E;AAGR,UAAM+E,MADoB/E,KAAM/E,IAAK,KAAK,gBAAgB,IAAI,KAAK,kBAAkBxD,CAAQ,CAAC,OAAO,QAAQwD,MAAO,SAAS,SAASA,EAAG,WAAW,QAAQ+E,MAAO,SAASA,IAAK,KACtI;AAC3C,QAAI+E,IAAkB,GAAG;AACrB,WAAK,gBAAgB,IAAI,KAAK,kBAAkBtN,CAAQ,GAAG;AAAA,QACvD,UAAAA;AAAA,QACA,OAAOsN;AAAA,MAAA,CACV;AACD;AAAA,IAAA;AAEJ,UAAMvB,IAAU,KAAK,iBAAiB,IAAI,KAAK,kBAAkB/L,CAAQ,CAAC;AACtE,IAAA+L,KACA,aAAaA,CAAO;AACxB,UAAMwB,IAAiB,MAAM;AAKzB,UAHA,KAAK,gBAAgB,OAAO,KAAK,kBAAkBvN,CAAQ,CAAC,GAE5D,KAAK,WAAW,OAAO,KAAK,kBAAkBA,CAAQ,CAAC,GACnD,CAAC,KAAK;AACA,cAAA,IAAI,MAAM,uFAAuF;AAC3G,MAAK,KAAK,cAAc;AAAA,IAC5B;AACI,QAAA,KAAK,eAAe,GAAG;AAER,MAAAuN,EAAA;AACf;AAAA,IAAA;AAEC,SAAA,iBAAiB,IAAI,KAAK,kBAAkBvN,CAAQ,GAAG,WAAWuN,GAAgB,KAAK,UAAU,CAAC;AAAA,EAAA;AAAA,EAE3G,aAAavN,GAAU;AACnB,QAAI,CAAC,KAAK;AACA,YAAA,IAAI,MAAM,6BAA6B;AAC7C,WAAC,KAAK,eAAe,IAAI,KAAK,kBAAkBA,CAAQ,CAAC,KACzD,KAAK,eAAe,IAAI,KAAK,kBAAkBA,CAAQ,GAAGqB,EAAa,KAAK,kBAAkB,OAAU,GAAA,EAAK,CAAC,GAE3G,KAAK,eAAe,IAAI,KAAK,kBAAkBrB,CAAQ,CAAC;AAAA,EAAA;AAAA,EAEnE,WAAWA,GAAUe,GAAO;AAExB,IADe,KAAK,aAAaf,CAAQ,EAClC,IAAIe,CAAK;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOpB,UAAUf,GAAU;AACV,UAAAsJ,IAAY,KAAK,UAAU;AACjC,WAAKtJ,IAGU,KAAK,aAAaA,CAAQ,EAC3B,SAASsJ,IAHZ,KAAK,iBAAiB,IAAA,KAASA;AAAA,EAGnB;AAE/B;AC5KwB,SAAAkE,GAAkBxC,GAAUhI,GAAS;AACnD,QAAA,EAAE,WAAA4H,IAAY,KAAK,WAAW,aAAAC,IAAc,KAAK,UAAU7H,KAAW,CAAC;AAC7E,MAAIiI,IAAc;AAClB,iBAAejH,IAAW;AAGhB,UAAAmH,IAAW,OADU,OADV,MAAM,UAAU,QAAQ,aAAa,GACZ,cAAcH,GAAU,EAAE,QAAQ,IAAM,GACxC,UAAU,KAAK,CAAA/J,MAAOA,EAAI,MAAM;AACnE,WAAA4J,EAAYM,KAAY,IAAI;AAAA,EAAA;AAEvC,SAAgC;AAAA,IAC5B,MAAM,SAASE,GAAU;AAErB,aADiB,MAAM,UAAU,QAAQ,aAAa,GACvC,cAAcL,GAAU,EAAE,QAAQ,IAAM,GAClDK,EAAS;AAAA,IAClB;AAAA,IACA,MAAM,OAAO;AACL,aAAAJ,KACM,MAAAA,GAEH,EAAE,OADK,MAAMjH,EAAS,EACd;AAAA,IACnB;AAAA,IACA,MAAM,KAAKsH,GAAQ,EAAE,OAAArD,GAAO,UAAAC,GAAU,SAAAC,KAAW;AACzC,MAAA8C,KACM,MAAAA;AAEJ,YAAAwC,IAAqB,OADV,MAAM,UAAU,QAAQ,aAAa,GACZ,cAAczC,GAAU,EAAE,QAAQ,IAAM;AAC9E,UAAA/C,EAAM,WAAW,KAAKC,EAAS,WAAW,KAAKC,EAAQ,WAAW,GAAG;AAC/D,cAAAuF,IAAc,MAAMD,EAAmB,eAAe;AAC5D,cAAMC,EAAY,MAAM9C,EAAUU,CAAM,CAAC,GACzC,MAAMoC,EAAY,MAAM,GAClB,MAAAzC;AACN;AAAA,MAAA;AAEJ,MAAAA,IAAcjH,EAAS,EAClB,KAAK,CAACgE,MAAiB;AAClB,cAAAlG,IAAQkG,EAAa,MAAM;AAC3B,eAAAC,EAAA,QAAQ,CAAClI,MAAS;AACpB,UAAA+B,EAAM,KAAK/B,CAAI;AAAA,QAAA,CAClB,GACQmI,EAAA,QAAQ,CAACnI,MAAS;AACjB,gBAAAqD,IAAQtB,EAAM,UAAU,CAAC,EAAE,IAAAsG,QAASA,MAAOrI,EAAK,EAAE;AAAA,UAAA;AAExD,cAAIqD,MAAU;AACV,kBAAM,IAAI,MAAM,gBAAgBrD,EAAK,EAAE,YAAY;AACvD,UAAA+B,EAAMsB,CAAK,IAAIrD;AAAA,QAAA,CAClB,GACOoI,EAAA,QAAQ,CAACpI,MAAS;AAChB,gBAAAqD,IAAQtB,EAAM,UAAU,CAAC,EAAE,IAAAsG,QAASA,MAAOrI,EAAK,EAAE;AAAA,UAAA;AAExD,cAAIqD,MAAU;AACV,kBAAM,IAAI,MAAM,gBAAgBrD,EAAK,EAAE,YAAY;AACjD,UAAA+B,EAAA,OAAOsB,GAAO,CAAC;AAAA,QAAA,CACxB,GACMtB;AAAA,MAAA,CACV,EACI,KAAK,OAAOA,MAAU;AACjB,cAAA4L,IAAc,MAAMD,EAAmB,eAAe;AAC5D,cAAMC,EAAY,MAAM9C,EAAU9I,CAAK,CAAC,GACxC,MAAM4L,EAAY,MAAM;AAAA,MAAA,CAC3B,EACI,KAAK,MAAM;AACE,QAAAzC,IAAA;AAAA,MAAA,CACjB,GACK,MAAAA;AAAA,IAAA;AAAA,EACV;AAER;ACnEA,SAAwB0C,GAAoBvG,GAAY;AAC7C,SAAAA;AACX;ACFA,SAAwBwG,GAAwBxG,GAAY;AACjD,SAAAA;AACX;ACOA,SAAwByG,GAASC,GAAMC,GAAM/K,IAAU,CAAA,GAAI;AACnD,MAAA+I,GACA/K;AACJ,QAAM,EAAE,SAAAgN,IAAU,IAAO,UAAAC,IAAW,GAAS,IAAAjL;AAC7C,WAASkL,KAAarO,GAAM;AAClB,UAAAsO,IAAwBH,KAAW,CAACjC,GACpCqC,IAAqBH,KAAY,CAAClC;AACxC,WAAIA,KACA,aAAaA,CAAO,GAExBA,IAAU,WAAW,MAAM;AACb,MAAAA,IAAA,MACNkC,KAAY,CAACE,MACJnN,IAAA8M,EAAK,MAAM,MAAMjO,CAAI;AAAA,OAEnCkO,CAAI,GACHI,IACSnN,IAAA8M,EAAK,MAAM,MAAMjO,CAAI,IAExBuO,MACGpN,IAAA,OAENA;AAAA,EAAA;AAEJ,SAAAkN;AACX;ACzBA,MAAqBG,GAAa;AAAA,EAC9B,cAAc;AACV,SAAK,QAAQ,CAAC,GACd,KAAK,iBAAiB;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO1B,IAAIC,GAAM;AACN,WAAO,IAAI,QAAQ,CAACC,GAASC,MAAW;AAE/B,WAAA,MAAM,KAAK,MAAMF,EAAK,EACtB,KAAKC,CAAO,EACZ,MAAM,CAACnF,MAAU;AAClB,cAAAoF,EAAOpF,CAAK,GACNA;AAAA,MAAA,CACT,CAAC,GACF,KAAK,QAAQ;AAAA,IAAA,CAChB;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAML,oBAAoB;AAChB,WAAO,KAAK;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAKhB,UAAU;AACN,QAAI,KAAK,kBAAkB,KAAK,MAAM,WAAW;AAC7C;AAEE,UAAAkF,IAAO,KAAK,MAAM,MAAM;AAC9B,IAAKA,MAEL,KAAK,iBAAiB,IACjBA,EAAA,EACA,KAAK,MAAM;AACZ,WAAK,iBAAiB,IACtB,KAAK,QAAQ;AAAA,IAAA,CAChB,EACI,MAAM,MAAM;AACb,WAAK,iBAAiB,IACtB,KAAK,QAAQ;AAAA,IAAA,CAChB;AAAA,EAAA;AAET;ACpDwB,SAAAG,EAAeC,GAAUxL,GAAU;AACvD,QAAM+E,IAAQ,CAAC,GACTC,IAAW,CAAC,GACZC,IAAU,CAAC,GACXhF,IAAc,IAAI,IAAIuL,EAAS,IAAI,CAAQ3O,MAAA,CAACA,EAAK,IAAIA,CAAI,CAAC,CAAC,GAC3DsD,IAAc,IAAI,IAAIH,EAAS,IAAI,CAAQnD,MAAA,CAACA,EAAK,IAAIA,CAAI,CAAC,CAAC;AACjE,aAAW,CAACqI,GAAI9E,CAAO,KAAKH,GAAa;AAC/B,UAAAM,IAAUJ,EAAY,IAAI+E,CAAE;AAClC,IAAK3E,IAGKnD,EAAQmD,GAASH,CAAO,KAC9B4E,EAAS,KAAKzE,CAAO,IAHrB0E,EAAQ,KAAK7E,CAAO;AAAA,EAIxB;AAEJ,aAAW,CAAC8E,GAAI3E,CAAO,KAAKJ;AACxB,IAAKF,EAAY,IAAIiF,CAAE,KACnBH,EAAM,KAAKxE,CAAO;AAGnB,SAAA,EAAE,OAAAwE,GAAO,UAAAC,GAAU,SAAAC,EAAQ;AACtC;ACtBwB,SAAAwG,EAAYC,GAAc/F,GAAM;AACpD,MAAIA,EAAK,SAAS;AACd,WAAOA,EAAK;AACV,QAAA/G,IAAQ8M,KAAgB,CAAC;AAC/B,SAAA/F,EAAK,QAAQ,MAAM,QAAQ,OAAQ/G,EAAM,KAAK/B,CAAI,CAAC,GACnD8I,EAAK,QAAQ,SAAS,QAAQ,CAAC9I,MAAS;AACpC,UAAMqD,IAAQtB,EAAM,UAAU,OAAKnB,EAAE,OAAOZ,EAAK,EAAE;AACnD,IAAIqD,MAAU,OACVtB,EAAMsB,CAAK,IAAIrD;AAAA,EAAA,CACtB,GACD8I,EAAK,QAAQ,QAAQ,QAAQ,CAAC9I,MAAS;AACnC,UAAMqD,IAAQtB,EAAM,UAAU,OAAKnB,EAAE,OAAOZ,EAAK,EAAE;AACnD,IAAIqD,MAAU,MACJtB,EAAA,OAAOsB,GAAO,CAAC;AAAA,EAAA,CAC5B,GACMtB;AACX;ACdwB,SAAA+M,EAAa/M,GAAOgH,GAAS;AAC3C,QAAAR,IAAa,IAAID,EAAW;AAClC,SAAAC,EAAW,MAAM,MAAM;AACnB,IAAAxG,EAAM,QAAQ,CAAA/B,MAAQuI,EAAW,OAAOvI,CAAI,CAAC,GACrC+I,EAAA,QAAQ,CAACgG,MAAW;AACpB,UAAAA,EAAO,SAAS,UAAU;AAC1B,QAAAxG,EAAW,UAAU,EAAE,IAAIwG,EAAO,MAAM;AACxC;AAAA,MAAA;AAEJ,YAAM9O,IAAW,EAAE,IAAI8O,EAAO,KAAK,GAAG,GAChCC,IAAazG,EAAW,QAAQtI,CAAQ;AAC1C,UAAA8O,EAAO,SAAS,UAAU;AAC1B,QAAIC,IACAzG,EAAW,UAAUtI,GAAU,EAAE,MAAM8O,EAAO,MAAM,IAGzCxG,EAAA,OAAOwG,EAAO,IAAI;AAEjC;AAAA,MAAA;AAGJ,MAAIC,IACAzG,EAAW,UAAUtI,GAAU8O,EAAO,KAAK,QAAQ,IAGnDxG,EAAW,OAAOpI,EAAOF,GAAU8O,EAAO,KAAK,QAAQ,CAAC;AAAA,IAC5D,CACH;AAAA,EAAA,CACJ,GACMxG,EAAW,KAAK,EAAE,MAAM;AACnC;ACnCA,SAAS0G,EAAWlG,GAAS;AAClB,SAAAA,EAAQ,MAAM,SAAS,KACvBA,EAAQ,SAAS,SAAS,KAC1BA,EAAQ,QAAQ,SAAS;AACpC;AACA,SAASmG,GAAcP,GAAUxL,GAAU;AACvC,SAAO8L,EAAWP,EAAeC,GAAUxL,CAAQ,CAAC;AACxD;AAgB8B,eAAAgM,GAAK,EAAE,SAAApG,GAAS,cAAA8F,GAAc,MAAA/F,GAAM,MAAAsG,GAAM,MAAAC,GAAM,QAAAC,GAAQ,QAAAC,GAAQ,QAAAC,GAAQ,OAAAC,EAAA,GAAU;AAC5G,MAAIC,IAAU5G,GACV6G,IAAmBd,KAAgB,CAAC,GACpCe,IAAchB,EAAYC,GAAca,CAAO;AAC/C,MAAA3G,EAAQ,SAAS,GAAG;AAEd,UAAA8G,IAA0Bf,EAAaa,GAAkB5G,CAAO;AAClE,QAAAmG,GAAcS,GAAkBE,CAAuB,GAAG;AAEpD,YAAAC,IAAyBhB,EAAac,GAAa7G,CAAO,GAC1DgH,IAAgBrB,EAAekB,GAAaE,CAAsB;AACpE,MAAAb,EAAWc,CAAa,MAExB,MAAMV,EAAKU,CAAa,GAExBL,IAAU,MAAMN,EAAK,GACPQ,IAAAhB,EAAYgB,GAAaF,CAAO,IAE/BC,IAAAE;AAAA,IAAA;AAAA,EACvB;AAGE,QAAAG,IAAaN,EAAQ,WAAW,OAChChB,EAAeiB,GAAkBD,EAAQ,KAAK,IAC9CA,EAAQ;AACd,SAAAD,EAAM,MAAM;AACR,IAAAO,EAAW,MAAM,QAAQ,CAAQhQ,MAAAsP,EAAOtP,CAAI,CAAC,GAClCgQ,EAAA,SAAS,QAAQ,CAAAhQ,MAAQuP,EAAOvP,EAAK,IAAI,EAAE,MAAMA,EAAM,CAAA,CAAC,GACnEgQ,EAAW,QAAQ,QAAQ,CAAAhQ,MAAQwP,EAAOxP,EAAK,EAAE,CAAC;AAAA,EAAA,CACrD,GACM4P;AACX;ACxBA,MAAqBK,GAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW7B,YAAYhN,GAAS;AACjB,QAAIQ,GAAI+E;AACH,SAAA,kCAAkB,IAAI,GAC3B,KAAK,gBAAgB,CAAC,GACjB,KAAA,iCAAiB,IAAI,GAC1B,KAAK,aAAa,IAClB,KAAK,aAAa1H,EAAS,GACtB,KAAA,eAAegN,GAAS,CAAClD,MAAS;AACnC,WAAK,YAAYA,CAAI,EAAE,MAAM,MAAM;AAAA,MAAA,CAAG;AAAA,OACvC,GAAG,GACN,KAAK,UAAU3H;AACT,UAAAoF,KAAM5E,IAAK,KAAK,QAAQ,QAAQ,QAAQA,MAAO,SAASA,IAAK,wBAC7D,EAAE,YAAAM,MAAe,KAAK;AAC5B,QAAImM,IAAsB,MAAM;AAAA,IAAE,GAC9BC,IAAwB,MAAM;AAAA,IAAE,GAChCC,IAA6B,MAAM;AAAA,IAAE;AACzC,UAAMvD,KAAsBrE,IAAKvF,EAAQ,wBAAwB,QAAQuF,MAAO,SAASA,IAAKmC,GACxF0F,IAA4BxD,EAAmB,GAAGxE,CAAE,YAAY,CAACiI,MAAY;AACzD,MAAAJ,IAAAI;AAAA,IAAA,CACzB,GACKC,IAA8B1D,EAAmB,GAAGxE,CAAE,cAAc,CAACiI,MAAY;AAC3D,MAAAH,IAAAG;AAAA,IAAA,CAC3B,GACKE,IAAmC3D,EAAmB,GAAGxE,CAAE,oBAAoB,CAACiI,MAAY;AACjE,MAAAF,IAAAE;AAAA,IAAA,CAChC;AACI,SAAA,UAAU,IAAIhI,EAAW;AAAA,MAC1B,aAAa+H;AAAA,MACb,YAAAtM;AAAA,IAAA,CACH,GACI,KAAA,YAAY,IAAIuE,EAAW;AAAA,MAC5B,aAAaiI;AAAA,MACb,YAAAxM;AAAA,IAAA,CACH,GACI,KAAA,iBAAiB,IAAIuE,EAAW;AAAA,MACjC,aAAakI;AAAA,MACb,YAAAzM;AAAA,IAAA,CACH,GACD,KAAK,QAAQ,GAAG,qBAAqB,CAASsF,MAAA6G,EAAoB7G,CAAK,CAAC,GACxE,KAAK,UAAU,GAAG,qBAAqB,CAASA,MAAA8G,EAAsB9G,CAAK,CAAC,GAC5E,KAAK,eAAe,GAAG,qBAAqB,CAASA,MAAA+G,EAA2B/G,CAAK,CAAC,GACjF,KAAA,mBAAmB,QAAQ,IAAI;AAAA,MAChC,IAAI,QAAQ,CAACmF,GAASC,MAAW;AACxB,aAAA,eAAe,KAAK,qBAAqBA,CAAM,GAC/C,KAAA,eAAe,KAAK,oBAAoBD,CAAO;AAAA,MAAA,CACvD;AAAA,MACD,IAAI,QAAQ,CAACA,GAASC,MAAW;AACxB,aAAA,QAAQ,KAAK,qBAAqBA,CAAM,GACxC,KAAA,QAAQ,KAAK,oBAAoBD,CAAO;AAAA,MAAA,CAChD;AAAA,MACD,IAAI,QAAQ,CAACA,GAASC,MAAW;AACxB,aAAA,UAAU,KAAK,qBAAqBA,CAAM,GAC1C,KAAA,UAAU,KAAK,oBAAoBD,CAAO;AAAA,MAClD,CAAA;AAAA,IAAA,CACJ,EAAE,KAAK,MAAM;AAAA,IAAA,CAAG,GACZ,KAAA,QAAQ,gBAAgB,GAAI,GAC5B,KAAA,UAAU,gBAAgB,GAAI,GAC9B,KAAA,eAAe,gBAAgB,GAAI;AAAA,EAAA;AAAA,EAE5C,aAAa5D,GAAM;AACf,WAAI,KAAK,WAAW,IAAIA,CAAI,KAAK,QAC7B,KAAK,WAAW,IAAIA,GAAM,IAAI0D,IAAc,GAEzC,KAAK,WAAW,IAAI1D,CAAI;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAKnC,MAAM,UAAU;AACZ,SAAK,YAAY,MAAM,GACvB,KAAK,WAAW,MAAM,GACtB,KAAK,cAAc,OAAO,GAAG,KAAK,cAAc,MAAM,GACtD,MAAM,QAAQ,IAAI;AAAA,MACd,KAAK,QAAQ,QAAQ;AAAA,MACrB,KAAK,UAAU,QAAQ;AAAA,MACvB,KAAK,eAAe,QAAQ;AAAA,IAAA,CAC/B,GACD,KAAK,aAAa;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtB,cAAcA,GAAM;AAChB,UAAM6F,IAAQ,KAAK,YAAY,IAAI7F,CAAI;AACvC,QAAI6F,KAAS;AACT,YAAM,IAAI,MAAM,uBAAuB7F,CAAI,aAAa;AACrD,WAAA6F;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQX,cAAclI,GAAYtF,GAAS;AAC/B,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,yBAAyB;AACzC,IAAA,KAAK,QAAQ,wBACb,KAAK,QAAQ,qBAAqBA,GAAS,OAAO6F,MAAS;AACvD,UAAIA,KAAQ;AACF,cAAA,KAAK,KAAK7F,EAAQ,IAAI;AAAA,WAE3B;AACK,cAAAyN,IAAW,KAAK,IAAI,GACpBC,IAAS,KAAK,eAAe,OAAO;AAAA,UACtC,OAAOD;AAAA,UACP,gBAAgBzN,EAAQ;AAAA,UACxB,YAAY,KAAK;AAAA,UACjB,QAAQ;AAAA,QAAA,CACX;AACD,cAAM,KAAK,aAAaA,EAAQ,MAAM6F,CAAI,EACrC,KAAK,MAAM;AAEZ,eAAK,eAAe,WAAW;AAAA,YAC3B,IAAI,EAAE,KAAK6H,EAAO;AAAA,YAClB,gBAAgB1N,EAAQ;AAAA,YACxB,KAAK;AAAA,cACD,EAAE,KAAK,EAAE,MAAMyN,IAAW;AAAA,cAC1B,EAAE,QAAQ,SAAS;AAAA,YAAA;AAAA,UACvB,CACH,GAED,KAAK,eAAe,UAAU,EAAE,IAAIC,KAAU;AAAA,YAC1C,MAAM,EAAE,QAAQ,QAAQ,KAAK,KAAK,IAAM,EAAA;AAAA,UAAA,CAC3C;AAAA,QAAA,CACJ,EACI,MAAM,CAACtH,MAAU;AAClB,gBAAI,KAAK,QAAQ,WACR,KAAA,QAAQ,QAAQpG,GAASoG,CAAK,GACvC,KAAK,eAAe,UAAU,EAAE,IAAIsH,KAAU;AAAA,YAC1C,MAAM,EAAE,QAAQ,SAAS,KAAK,KAAK,IAAI,GAAG,OAAOtH,EAAM,SAASA,EAAM,QAAQ;AAAA,UAAA,CACjF,GACKA;AAAA,QAAA,CACT;AAAA,MAAA;AAAA,IACL,CACH,GAEL,KAAK,YAAY,IAAIpG,EAAQ,MAAM,CAACsF,GAAYtF,CAAO,CAAC;AAClD,UAAA2N,IAAkB,CAAC7B,MAAW;AACrB,iBAAA8B,KAAgB,KAAK;AACxB,YAAAtQ,EAAQsQ,GAAc9B,CAAM;AACrB,iBAAA;AAGR,aAAA;AAAA,IACX,GACM+B,IAAqB,CAAC/B,MAAW;AACnC,eAASnO,IAAI,GAAGA,IAAI,KAAK,cAAc,QAAQA,KAAK;AAChD,YAAIL,EAAQ,KAAK,cAAcK,CAAC,GAAGmO,CAAM,GAAG;AACnC,eAAA,cAAc,OAAOnO,GAAG,CAAC;AAC9B;AAAA,QAAA;AAAA,IAGZ;AACW,IAAA2H,EAAA,GAAG,SAAS,CAACvI,MAAS;AAEzB,UAAA4Q,EAAgB,EAAE,gBAAgB3N,EAAQ,MAAM,MAAM,UAAU,MAAMjD,EAAK,CAAC,GAAG;AAC5D,QAAA8Q,EAAA,EAAE,gBAAgB7N,EAAQ,MAAM,MAAM,UAAU,MAAMjD,GAAM;AAC/E;AAAA,MAAA;AAEJ,WAAK,QAAQ,OAAO;AAAA,QAChB,gBAAgBiD,EAAQ;AAAA,QACxB,MAAM,KAAK,IAAI;AAAA,QACf,MAAM;AAAA,QACN,MAAMjD;AAAA,MAAA,CACT,GACI,KAAA,aAAaiD,EAAQ,IAAI;AAAA,IAAA,CACjC,GACDsF,EAAW,GAAG,WAAW,CAAC,EAAE,IAAAF,EAAA,GAAMjI,MAAa;AACrC,YAAA0I,IAAO,EAAE,IAAAT,GAAI,UAAAjI,EAAS;AAExB,UAAAwQ,EAAgB,EAAE,gBAAgB3N,EAAQ,MAAM,MAAM,UAAU,MAAA6F,EAAK,CAAC,GAAG;AACzE,QAAAgI,EAAmB,EAAE,gBAAgB7N,EAAQ,MAAM,MAAM,UAAU,MAAA6F,GAAM;AACzE;AAAA,MAAA;AAEJ,WAAK,QAAQ,OAAO;AAAA,QAChB,gBAAgB7F,EAAQ;AAAA,QACxB,MAAM,KAAK,IAAI;AAAA,QACf,MAAM;AAAA,QACN,MAAA6F;AAAA,MAAA,CACH,GACI,KAAA,aAAa7F,EAAQ,IAAI;AAAA,IAAA,CACjC,GACDsF,EAAW,GAAG,WAAW,CAAC,EAAE,IAAAF,QAAS;AAE7B,UAAAuI,EAAgB,EAAE,gBAAgB3N,EAAQ,MAAM,MAAM,UAAU,MAAMoF,EAAG,CAAC,GAAG;AAC1D,QAAAyI,EAAA,EAAE,gBAAgB7N,EAAQ,MAAM,MAAM,UAAU,MAAMoF,GAAI;AAC7E;AAAA,MAAA;AAEJ,WAAK,QAAQ,OAAO;AAAA,QAChB,gBAAgBpF,EAAQ;AAAA,QACxB,MAAM,KAAK,IAAI;AAAA,QACf,MAAM;AAAA,QACN,MAAMoF;AAAA,MAAA,CACT,GACI,KAAA,aAAapF,EAAQ,IAAI;AAAA,IAAA,CACjC;AAAA,EAAA;AAAA,EAEL,aAAa2H,GAAM;AACf,SAAK,aAAaA,CAAI;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAK1B,MAAM,UAAU;AACZ,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,yBAAyB;AAC7C,UAAMmG,IAAS,CAAC;AAIhB,QAHA,MAAM,QAAQ,IAAI,CAAC,GAAG,KAAK,YAAY,MAAM,EAAE,IAAI,OAAM,KAAK,KAAK1I,CAAE,EAAE,MAAM,CAACgB,MAAU;AACpF,MAAA0H,EAAO,KAAK,EAAE,IAAA1I,GAAI,OAAAgB,EAAA,CAAO;AAAA,IAC5B,CAAA,CAAC,CAAC,GACC0H,EAAO,SAAS;AAChB,YAAM,IAAI,MAAM;AAAA,EAAqCA,EAAO,IAAI,CAAKC,MAAA,GAAGA,EAAE,EAAE,KAAKA,EAAE,MAAM,OAAO,EAAE,EAAE,KAAK;AAAA;AAAA,CAAM,CAAC,EAAE;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO1H,UAAUpG,GAAM;AACZ,WAAO,KAAK,eAAe,QAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,GAAIA,IAAO,EAAE,gBAAgBA,MAAS,CAAA,CAAE,GAAG,EAAE,QAAQ,UAAU,GAAG,EAAE,QAAQ,EAAE,QAAQ,EAAE,EAAA,CAAG,KAAK;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMnK,MAAM,UAAU;AACZ,UAAM,KAAK;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASf,MAAM,KAAKA,GAAM3H,IAAU,IAAI;AAC3B,QAAI,KAAK;AACC,YAAA,IAAI,MAAM,yBAAyB;AAC7C,UAAM,KAAK,QAAQ;AAEb,UAAAgO,IADQ,KAAK,cAAcrG,CAAI,EACL,CAAC,GAC3BsG,IAAiB,KAAK,eAAe,KAAK;AAAA,MAC5C,gBAAgBtG;AAAA,MAChB,YAAY,KAAK;AAAA,MACjB,QAAQ;AAAA,IAAA,CACX,EAAE,MAAA,IAAU,GACP8F,IAAW,KAAK,IAAI;AAC1B,QAAIC,IAAS;AAEP,UAAA,IAAI,QAAQ,CAACnC,MAAY;AAAE,iBAAWA,GAAS,CAAC;AAAA,IAAA,CAAI;AAC1D,UAAM2C,IAAS,YAAY;AACvB,YAAMC,IAAmB,KAAK,eAAe,QAAQ,EAAE,gBAAgBxG,GAAM,QAAQ,OAAO,GAAG,EAAE,MAAM,EAAE,KAAK,GAAA,GAAM;AACpH,UAAI3H,KAAY,QAAsCA,EAAQ,mBACnC,KAAK,QAAQ,KAAK;AAAA,QACrC,gBAAgB2H;AAAA,QAChB,MAAM;AAAA,UACF,EAAE,MAAM,EAAE,MAAM8F,EAAW,EAAA;AAAA,QAAA;AAAA,MAC/B,GACD,EAAE,MAAM,EAAE,MAAM,EAAE,EAAA,CAAG,EAAE,MAAM,MACT;AACnB;AAER,MAAKQ,MACQP,IAAA,KAAK,eAAe,OAAO;AAAA,QAChC,OAAOD;AAAA,QACP,gBAAgB9F;AAAA,QAChB,YAAY,KAAK;AAAA,QACjB,QAAQ;AAAA,MAAA,CACX;AAEL,YAAM9B,IAAO,MAAM,KAAK,QAAQ,KAAKmI,GAAmB;AAAA,QACpD,uBAAuBG,KAAqB,OAAsC,SAASA,EAAiB;AAAA,QAC5G,qBAAqBA,KAAqB,OAAsC,SAASA,EAAiB;AAAA,MAAA,CAC7G;AACK,YAAA,KAAK,aAAaxG,GAAM9B,CAAI;AAAA,IACtC;AACA,WAAQ7F,KAAY,QAAsCA,EAAQ,QAASkO,EAAO,IAAI,KAAK,aAAavG,CAAI,EAAE,IAAIuG,CAAM,GACnH,MAAM,CAAC9H,MAAU;AAClB,YAAIsH,KAAU,SACN,KAAK,QAAQ,WACR,KAAA,QAAQ,QAAQM,GAAmB5H,CAAK,GACjD,KAAK,eAAe,UAAU,EAAE,IAAIsH,KAAU;AAAA,QAC1C,MAAM,EAAE,QAAQ,SAAS,KAAK,KAAK,IAAI,GAAG,OAAOtH,EAAM,SAASA,EAAM,QAAQ;AAAA,MAAA,CACjF,IAECA;AAAA,IAAA,CACT,GACGsH,KAAU,SAEV,KAAK,eAAe,WAAW;AAAA,MAC3B,IAAI,EAAE,KAAKA,EAAO;AAAA,MAClB,gBAAgB/F;AAAA,MAChB,KAAK;AAAA,QACD,EAAE,KAAK,EAAE,MAAM8F,IAAW;AAAA,QAC1B,EAAE,QAAQ,SAAS;AAAA,MAAA;AAAA,IACvB,CACH,GAED,KAAK,eAAe,UAAU,EAAE,IAAIC,KAAU;AAAA,MAC1C,MAAM,EAAE,QAAQ,QAAQ,KAAK,KAAK,IAAM,EAAA;AAAA,IAAA,CAC3C;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAMJ,MAAM,YAAY/F,GAAM;AACd,UAAA,KAAK,KAAKA,GAAM;AAAA,MAClB,iBAAiB;AAAA,IAAA,CACpB;AAAA,EAAA;AAAA,EAEL,MAAM,aAAaA,GAAM9B,GAAM;AACrB,UAAA2H,IAAQ,KAAK,cAAc7F,CAAI,GAC/B,CAACrC,GAAY0I,CAAiB,IAAIR,GAClCC,IAAW,KAAK,IAAI,GACpBU,IAAmB,KAAK,eAAe,QAAQ,EAAE,gBAAgBxG,GAAM,QAAQ,OAAO,GAAG,EAAE,MAAM,EAAE,KAAK,GAAA,GAAM,GAC9GiE,IAAe,KAAK,UAAU,QAAQ,EAAE,gBAAgBjE,EAAQ,GAAA,EAAE,MAAM,EAAE,MAAM,MAAM,GACtFyG,IAAiB,KAAK,QAAQ,KAAK;AAAA,MACrC,gBAAgBzG;AAAA,MAChB,MAAM;AAAA,QACF,EAAE,MAAM,EAAE,MAAM8F,EAAW,EAAA;AAAA,MAAA;AAAA,IAC/B,GACD,EAAE,MAAM,EAAE,MAAM,EAAE,EAAA,CAAG,EAAE,MAAM;AAChC,UAAMvB,GAAK;AAAA,MACP,SAASkC;AAAA,MACT,cAAcxC,KAAiB,OAAkC,SAASA,EAAa;AAAA,MACvF,MAAA/F;AAAA,MACA,MAAM,MAAM,KAAK,QAAQ,KAAKmI,GAAmB;AAAA,QAC7C,uBAAuBG,KAAqB,OAAsC,SAASA,EAAiB;AAAA,QAC5G,qBAAqBA,KAAqB,OAAsC,SAASA,EAAiB;AAAA,MAAA,CAC7G;AAAA,MACD,MAAM,OAAW,KAAK,QAAQ,KAAKH,GAAmB,EAAE,SAAAlI,GAAS;AAAA,MACjE,QAAQ,CAAC/I,MAAS;AACV,YAAAA,EAAK,MAAQuI,EAAW,QAAQ,EAAE,IAAIvI,EAAK,GAAG,CAAC,GAAG;AAClD,eAAK,cAAc,KAAK;AAAA,YACpB,gBAAgB4K;AAAA,YAChB,MAAM;AAAA,YACN,MAAM,EAAE,IAAI5K,EAAK,IAAI,UAAU,EAAE,MAAMA,EAAO,EAAA;AAAA,UAAA,CACjD,GAEUuI,EAAA,UAAU,EAAE,IAAIvI,EAAK,MAAM,EAAE,MAAMA,GAAM;AACpD;AAAA,QAAA;AAEJ,aAAK,cAAc,KAAK;AAAA,UACpB,gBAAgB4K;AAAA,UAChB,MAAM;AAAA,UACN,MAAM5K;AAAA,QAAA,CACT,GACDuI,EAAW,OAAOvI,CAAI;AAAA,MAC1B;AAAA,MACA,QAAQ,CAACsR,GAAQlR,MAAa;AACtB,YAAAkR,KAAU,CAAC/I,EAAW,QAAQ,EAAE,IAAI+I,EAAA,CAAQ,GAAG;AAC/C,gBAAMtR,IAAO,OAAO,OAAO,OAAO,OAAO,IAAII,EAAS,IAAI,GAAG,EAAE,IAAIkR,GAAQ;AAC3E,eAAK,cAAc,KAAK;AAAA,YACpB,gBAAgB1G;AAAA,YAChB,MAAM;AAAA,YACN,MAAM5K;AAAA,UAAA,CACT,GAEDuI,EAAW,OAAOvI,CAAI;AACtB;AAAA,QAAA;AAEJ,aAAK,cAAc,KAAK;AAAA,UACpB,gBAAgB4K;AAAA,UAChB,MAAM;AAAA,UACN,MAAM,EAAE,IAAI0G,GAAQ,UAAAlR,EAAS;AAAA,QAAA,CAChC,GACDmI,EAAW,UAAU,EAAE,IAAI+I,EAAA,GAAUlR,CAAQ;AAAA,MACjD;AAAA,MACA,QAAQ,CAACkR,MAAW;AAChB,aAAK,cAAc,KAAK;AAAA,UACpB,gBAAgB1G;AAAA,UAChB,MAAM;AAAA,UACN,MAAM0G;AAAA,QAAA,CACT,GACD/I,EAAW,UAAU,EAAE,IAAI+I,EAAA,CAAQ;AAAA,MACvC;AAAA,MACA,OAAO,CAAC1O,MAAO;AACX,QAAA2F,EAAW,MAAM,MAAM;AAChB,UAAA3F,EAAA;AAAA,QAAA,CACN;AAAA,MAAA;AAAA,IACL,CACH,EACI,KAAK,OAAO2O,MAAa;AAErB,WAAA,UAAU,WAAW,EAAE,gBAAgB3G,GAAM,MAAM,EAAE,MAAM8F,EAAS,GAAG,GAE5E,KAAK,QAAQ,WAAW;AAAA,QACpB,gBAAgB9F;AAAA,QAChB,IAAI,EAAE,KAAKyG,EAAe,IAAI,CAAKpL,MAAAA,EAAE,EAAE,EAAE;AAAA,MAAA,CAC5C,GAED,KAAK,UAAU,OAAO;AAAA,QAClB,MAAMyK;AAAA,QACN,gBAAgB9F;AAAA,QAChB,OAAO2G;AAAA,MAAA,CACV,GAEK,MAAA,IAAI,QAAQ,CAAC/C,MAAY;AAAE,mBAAWA,GAAS,CAAC;AAAA,MAAA,CAAI;AAAA,IAC7D,CAAA,EAGI,KAAK,MAAM,KAAK,KAAK5D,GAAM;AAAA,MAC5B,OAAO;AAAA,MACP,iBAAiB;AAAA,IAAA,CACpB,CAAC;AAAA,EAAA;AAEV;","x_google_ignoreList":[15]}